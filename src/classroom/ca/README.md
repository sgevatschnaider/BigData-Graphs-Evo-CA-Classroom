# ğŸ¦  AutoCell â€” AutÃ³matas Celulares

<p align="center">
  <img src="https://github.com/sgevatschnaider/BigData-Graphs-Evo-CA-Classroom/blob/main/src/classroom/ca/recursos/Origami_Turing_Machine.gif?raw=true"
       width="420"
       alt="AutoCell â€” Origami Turing Machine">
</p>

<p align="center">
  <strong>Repositorio integral para el estudio e implementaciÃ³n de AutÃ³matas Celulares (AC)</strong><br>
  Desde fundamentos teÃ³ricos hasta variantes avanzadas: Reversibles, EstocÃ¡sticos, Multi-estado,<br>
  en Grafos y Acelerados por GPU ğŸš€
</p>

---

## ğŸ¯ CaracterÃ­sticas Principales

| âœ¨ CaracterÃ­stica | ğŸ“ DescripciÃ³n |
|-------------------|---------------|
| ğŸ”¬ **Fundamentos** | Conway, Wolfram, clases Iâ€“IV, universalidad |
| ğŸ”„ **Variantes Avanzadas** | Reversibles (Margolus), EstocÃ¡sticos, Outer-totalistas |
| ğŸ•¸ï¸ **Grafos** | Vecindades no-regulares en redes complejas |
| âš¡ **GPU Acceleration** | Numba, CuPy, PyTorch para simulaciones masivas |
| ğŸ“Š **MÃ©tricas Integradas** | EntropÃ­a, densidad, autocorrelaciÃ³n, censos de gliders |
| ğŸ¨ **VisualizaciÃ³n** | GIFs, heatmaps, diagramas de espacio-tiempo |
| ğŸ“¦ **Formatos EstÃ¡ndar** | Soporte RLE, .npy, .txt, configuraciones YAML |
| ğŸ§ª **Reproducibilidad** | Seeds controladas, tests unitarios, pre-commit hooks |

---

## ğŸš€ Empieza AquÃ­ (Modo Clases)

<div align="center">

### ğŸ“š Notebook Central: AC 1D, 2D y MÃ¡quina de Turing

<a href="https://colab.research.google.com/github/sgevatschnaider/GraphAI-Data-Science-ML/blob/a59bee63ffa0f5452fc13aa79136e458ef9262e5/notebooks/Aut%C3%B3matas_celulares_unidimensionales%2C_bidimensional_y_maquina_de_turing.ipynb">
  <img alt="Abrir Notebook AC en Colab" src="https://colab.research.google.com/assets/colab-badge.svg">
</a>
<a href="https://github.com/sgevatschnaider/GraphAI-Data-Science-ML/blob/a59bee63ffa0f5452fc13aa79136e458ef9262e5/notebooks/Aut%C3%B3matas_celulares_unidimensionales%2C_bidimensional_y_maquina_de_turing.ipynb">
  <img alt="Ver Notebook en GitHub" src="https://img.shields.io/badge/Ver%20Notebook-en%20GitHub-0366d6?style=for-the-badge&logo=github">
</a>

### ğŸ¨ LecciÃ³n Interactiva: Origami + AutÃ³matas Celulares

<a href="https://htmlpreview.github.io/?https://github.com/sgevatschnaider/BigData-Graphs-Evo-CA-Classroom/blob/main/src/classroom/graphs/recursos/Origami_origami_Cuando_%20el_Papel_%20Empieza_a_Calcular.html">
  <img alt="Ver LecciÃ³n Interactiva Origami + AutÃ³matas Celulares" src="https://img.shields.io/badge/LecciÃ³n%20Interactiva-Origami%20%2B%20Aut%C3%B3matas%20Celulares-ff9800?style=for-the-badge&logo=html5">
</a>

### ğŸ“‚ Explorar Todos los Notebooks

<a href="./notebooks/">
  <img alt="Ver todos los notebooks de AutoCell" src="https://img.shields.io/badge/ ğŸ““%20Notebooks-AutoCell%20Classroom-9cf?style=for-the-badge&logo=jupyter">
</a>

</div>

> ğŸ’¡ **GuÃ­a RÃ¡pida para Estudiantes**
> 
> 1. **Inicia** con el notebook central en Colab (no necesitas instalaciÃ³n)
> 2. **Explora** la lecciÃ³n interactiva de origami para ver la conexiÃ³n teÃ³rica
> 3. **Practica** con los ejercicios propuestos en cada notebook
> 4. **Experimenta** modificando reglas y parÃ¡metros en tiempo real

---

## ğŸ”– Estado del Proyecto

### ğŸ› ï¸ TecnologÃ­as & Calidad

<p>
  <a href="https://www.python.org/">
    <img alt="Python" src="https://img.shields.io/badge/Python-3.10%20%7C%203.11-3776AB?logo=python">
  </a>
  <a href="../LICENSE">
    <img alt="License: MIT" src="https://img.shields.io/badge/License-MIT-blue.svg">
  </a>
  <a href="https://pre-commit.com/">
    <img alt="pre-commit" src="https://img.shields.io/badge/pre--commit-enabled-brightgreen?logo=pre-commit&logoColor=white">
  </a>
  <a href="https://colab.research.google.com/">
    <img alt="Colab Ready" src="https://img.shields.io/badge/Colab-ready-F9AB00?logo=googlecolab">
  </a>
  <a href="#">
    <img alt="Code Style: Black" src="https://img.shields.io/badge/code%20style-black-000000.svg?logo=python">
  </a>
  <a href="#">
    <img alt="Tests" src="https://img.shields.io/badge/tests-passing-brightgreen">
  </a>
</p>

### ğŸ“ NavegaciÃ³n RÃ¡pida

<p>
  <a href="./notebooks/">
    <img alt="Notebooks" src="https://img.shields.io/badge/ ğŸ““%20Notebooks-AC-orange">
  </a>
  <a href="./src/">
    <img alt="Source Code" src="https://img.shields.io/badge/ ğŸ“¦%20Source-Core-purple">
  </a>
  <a href="./data/">
    <img alt="Data" src="https://img.shields.io/badge/ ğŸ—‚ï¸%20Data-Patterns-lightgrey">
  </a>
  <a href="./references/">
    <img alt="References" src="https://img.shields.io/badge/ ğŸ“š%20References-Papers-lightgrey">
  </a>
</p>

---

## ğŸ¯ VisiÃ³n General

**AutoCell** es un framework educacional y de investigaciÃ³n que te guÃ­a desde la definiciÃ³n bÃ¡sica de autÃ³matas celulares hasta aplicaciones de vanguardia. Cubre:

- **Fundamentos**: Celdas, vecindades, reglas de transiciÃ³n, condiciones de frontera
- **ClÃ¡sicos**: Juego de la Vida de Conway, Reglas de Wolfram (0-255)
- **ClasificaciÃ³n**: Clases de comportamiento Iâ€“IV, universalidad computacional (Regla 110)
- **Variantes Avanzadas**: Reversibles (Margolus), EstocÃ¡sticos, Outer-totalistas, Multi-estado
- **Grafos**: AC en redes complejas con vecindades no-regulares
- **Rendimiento**: OptimizaciÃ³n NumPy, aceleraciÃ³n JIT con Numba, backends GPU (CuPy/PyTorch)

---

## ğŸ§® Origami Turing Machine â€” CÃ³mputo Inscrito en el Papel

<p align="center">
  <img src="https://github.com/sgevatschnaider/BigData-Graphs-Evo-CA-Classroom/blob/main/src/classroom/ca/recursos/Origami_Turing_Machine.gif?raw=true"
       width="380"
       alt="Origami Turing Machine">
</p>

### ğŸ§© Conceptos Clave

<details>
<summary><strong>Ver explicaciÃ³n completa del modelo computacional</strong></summary>

La animaciÃ³n muestra un patrÃ³n de origami que implementa una **MÃ¡quina de Turing** mediante geometrÃ­a pura. Cada pliegue actÃºa como una **instrucciÃ³n**, cada regiÃ³n como un **estado**, y las capas superpuestas funcionan como **memoria fÃ­sica**.

**Principios fundamentales:**

- **MontaÃ±a = 1, Valle = 0**: Los pliegues codifican bits directamente
- **Compatibilidad fÃ­sica = LÃ³gica**: Pliegues opcionales implementan compuertas AND, OR, NOT
- **TeselaciÃ³n = AutÃ³mata**: Replicando estos "gadgets" se simula la **Regla 110**, un AC Turing-completo

Una hoja de papel con el patrÃ³n correcto se convierte en una **computadora universal**. La lecciÃ³n interactiva HTML explora esta conexiÃ³n en profundidad con simuladores y diagramas paso a paso.

</details>

---

## ğŸ“‚ Estructura del Repositorio

```text
AutoCell/
â”œâ”€â”€ README.md                          # Este archivo
â”œâ”€â”€ notebooks/                         # ğŸ“š Tutoriales y experimentos (Colab-ready)
â”‚   â”œâ”€â”€ 01_intro_ac.ipynb             # IntroducciÃ³n y fundamentos
â”‚   â”œâ”€â”€ 02_wolfram_1d.ipynb           # AC 1D y clases de Wolfram
â”‚   â”œâ”€â”€ 03_life_2d.ipynb              # Juego de la Vida y patrones
â”‚   â”œâ”€â”€ 04_reversible.ipynb           # Bloques Margolus
â”‚   â”œâ”€â”€ 05_stochastic.ipynb           # Ruido y percolaciÃ³n
â”‚   â””â”€â”€ 06_gpu_perf.ipynb             # Benchmarks y optimizaciÃ³n
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ autocell/
â”‚   â”‚   â”œâ”€â”€ core.py                   # Motor de evoluciÃ³n (1D/2D/ND)
â”‚   â”‚   â”œâ”€â”€ rules.py                  # Reglas: Wolfram, Life, totalistas, custom
â”‚   â”‚   â”œâ”€â”€ neighborhoods.py          # Vecindades: Moore, von Neumann, Margolus, grafos
â”‚   â”‚   â”œâ”€â”€ bc.py                     # Condiciones de frontera (BC)
â”‚   â”‚   â”œâ”€â”€ io.py                     # Carga/guardado: RLE, .npy, .txt
â”‚   â”‚   â”œâ”€â”€ viz.py                    # VisualizaciÃ³n: matplotlib, GIF
â”‚   â”‚   â”œâ”€â”€ rng.py                    # Semillas y ruido
â”‚   â”‚   â””â”€â”€ gpu.py                    # Backends: Numba/CuPy/PyTorch
â”‚   â””â”€â”€ cli.py                        # Interfaz de lÃ­nea de comandos
â”œâ”€â”€ data/
â”‚   â”œâ”€â”€ patterns/                     # Patrones RLE: gliders, pulsars, guns
â”‚   â””â”€â”€ random/                       # Semillas aleatorias reproducibles
â”œâ”€â”€ images/                           # Figuras, diagramas y animaciones
â”œâ”€â”€ tests/                            # Pruebas unitarias y de propiedad
â”œâ”€â”€ references/                       # BibliografÃ­a y papers clave
â”œâ”€â”€ CITATION.cff                      # Cita acadÃ©mica
â””â”€â”€ pyproject.toml                    # Dependencias y configuraciÃ³n
```

---

## ğŸ“ Objetivos de Aprendizaje

Al completar este repositorio, podrÃ¡s:

- [x] **Definir** formalmente un AC: estados, vecindades, reglas y dinÃ¡mica
- [x] **Distinguir** clases de comportamiento (Iâ€“IV), estabilidad, periodicidad y caos
- [x] **Implementar** AC 1D/2D/ND con variantes avanzadas (reversibles, estocÃ¡sticos)
- [x] **Analizar** mÃ©tricas cuantitativas: densidad, entropÃ­a, correlaciones, espectros
- [x] **Optimizar** simulaciones con tÃ©cnicas vectorizadas, JIT y GPU
- [x] **Aplicar** AC en modelado real: difusiÃ³n, percolaciÃ³n, crecimiento, trÃ¡fico
- [x] **Extender** a grafos complejos y redes sociales

---

## âš™ï¸ InstalaciÃ³n RÃ¡pida

### ğŸ–¥ï¸ Local Development

```bash
# 1. Clona el repositorio
git clone <URL_DEL_REPOSITORIO>
cd AutoCell

# 2. Crea entorno virtual
python -m venv .venv
source .venv/bin/activate     # Linux/macOS
# .venv\Scripts\activate      # Windows

# 3. Instala dependencias
pip install -U pip
pip install -e ".[all]"       # Instala todo: numpy, matplotlib, numba, cupy, etc.

# 4. (Opcional) Configura pre-commit hooks
pre-commit install
```

### â˜ï¸ Sin InstalaciÃ³n: Google Colab

Abre directamente cualquier notebook en Colab (ver secciÃ³n [Empieza AquÃ­](#-empieza-aquÃ­-modo-clases)). No necesitas instalar nada.

---

## ğŸ§ª Quickstart

### ğŸ”§ Interfaz de LÃ­nea de Comandos

```bash
# Juego de la Vida con "glider gun" de 200x200, 400 pasos, frontera periÃ³dica
python -m src.cli life \
  --size 200 200 \
  --steps 400 \
  --bc periodic \
  --pattern data/patterns/glider_gun.rle \
  --gif images/life_demo.gif
```

### ğŸ Python API

```python
import numpy as np
from autocell.core import evolve, step_life
from autocell.viz import animate_gif
from autocell.io import load_rle

# OpciÃ³n 1: Usar patrÃ³n RLE (glider gun)
grid = load_rle("data/patterns/glider_gun.rle")

# OpciÃ³n 2: Crear patrÃ³n manual (blinker)
# grid = np.zeros((100, 100), dtype=np.uint8)
# grid[50, 49:52] = 1

# Evolucionar y guardar GIF
frames = list(evolve(grid, step_life, steps=200, record=True))
animate_gif(frames, "images/blinker.gif", fps=10, cmap="binary")
```

### ğŸ›ï¸ ConfiguraciÃ³n con YAML

```python
from autocell.io import load_config, run_from_config

config = load_config("config.yaml")
# config.yaml define: model, size, steps, bc, seed, record, metrics
results = run_from_config(config)
```

---

## ğŸ“š Recursos Docentes (Notebooks + HTML)

### ğŸ““ Notebook Fundamentos: AC 1D, 2D y MÃ¡quina de Turing

| DescripciÃ³n | Acceso |
|-------------|--------|
| **AutÃ³matas celulares unidimensionales, bidimensionales y mÃ¡quina de Turing** | [![Ver en GitHub](https://img.shields.io/badge/Ver%20en-GitHub-blue?style=for-the-badge&logo=github)](https://github.com/sgevatschnaider/GraphAI-Data-Science-ML/blob/a59bee63ffa0f5452fc13aa79136e458ef9262e5/notebooks/Aut%C3%B3matas_celulares_unidimensionales%2C_bidimensional_y_maquina_de_turing.ipynb) [![Open In Colab](https://colab.research.google.com/assets/colab-badge.svg)](https://colab.research.google.com/github/sgevatschnaider/GraphAI-Data-Science-ML/blob/a59bee63ffa0f5452fc13aa79136e458ef9262e5/notebooks/Aut%C3%B3matas_celulares_unidimensionales%2C_bidimensional_y_maquina_de_turing.ipynb) |

### ğŸ¨ LecciÃ³n Interactiva: Origami + AutÃ³matas Celulares

| DescripciÃ³n | Acceso |
|-------------|--------|
| **Origami origami Cuando el Papel Empieza a Calcular (HTML interactivo)** | [![Ver LecciÃ³n Interactiva](https://img.shields.io/badge/Ver%20LecciÃ³n-Interactiva-9cf?style=for-the-badge&logo=html5)](https://htmlpreview.github.io/?https://github.com/sgevatschnaider/BigData-Graphs-Evo-CA-Classroom/blob/main/src/classroom/graphs/recursos/Origami_origami_Cuando_%20el_Papel_%20Empieza_a_Calcular.html) |

<details>
<summary><strong>Â¿QuÃ© contiene esta lecciÃ³n?</strong></summary>

- **6 secciones interactivas** con simuladores en vivo
- Fundamentos geomÃ©tricos del origami computacional
- Axioma H6 y resoluciÃ³n de ecuaciones cÃºbicas
- CodificaciÃ³n binaria en pliegues (MontaÃ±a=1, Valle=0)
- SimulaciÃ³n de la **Regla 110** mediante teselaciones de origami
- DemostraciÃ³n de universalidad de Turing en papel

</details>

---

## ğŸ“– Tabla de Contenidos

1. [Fundamentos TeÃ³ricos](#1-fundamentos-teÃ³ricos)
2. [Componentes de un AC](#2-componentes-de-un-ac)
3. [Implementaciones Esenciales](#3-implementaciones-esenciales)
4. [DinÃ¡micas Emergentes y MÃ©tricas](#4-dinÃ¡micas-emergentes-y-mÃ©tricas)
5. [Datos y Formatos](#5-datos-y-formatos)
6. [Rendimiento y GPU](#6-rendimiento-y-gpu)
7. [Aplicaciones](#7-aplicaciones)
8. [Roadmap de Notebooks](#8-roadmap-de-notebooks)
9. [Ejercicios Propuestos](#9-ejercicios-propuestos)
10. [Errores Comunes](#10-errores-comunes)
11. [API Breve](#11-api-breve)
12. [CÃ³mo Contribuir](#12-cÃ³mo-contribuir)
13. [Licencia](#13-licencia)
14. [ApÃ©ndices](#apÃ©ndice-a-diagramas-mermaid)

---

## 1. Fundamentos TeÃ³ricos

Un **autÃ³mata celular** es formalmente una tupla $(\mathcal{L}, \mathcal{S}, \mathcal{N}, f)$:

| SÃ­mbolo | DefiniciÃ³n |
|---------|------------|
| $\mathcal{L}$ | RetÃ­cula de celdas (1D, 2D, ND o grafo) |
| $\mathcal{S}$ | Conjunto de estados por celda (binario, multi-estado, continuo) |
| $\mathcal{N}$ | Vecindad (Moore, von Neumann, radio $r$, Margolus, grafos) |
| $f$ | FunciÃ³n de transiciÃ³n local $f:\mathcal{S}^{|\mathcal{N}|} \to \mathcal{S}$ |

### ğŸ”¢ Clases de Wolfram (1D binario, radio 1)

| Clase | Comportamiento | Ejemplo |
|-------|----------------|---------|
| **I** | FijaciÃ³n atractor puntual | Regla 0, 8, 160 |
| **II** | Periodicidad (osciladores) | Regla 108, 178 |
| **III** | Caos (pseudoaleatorio) | Regla 30, 90, 126 |
| **IV** | Complejidad + estructuras mÃ³viles | **Regla 110 (universal)** |

### ğŸ·ï¸ Familias de AC

- **Totalistas**: $f$ depende del conteo de estados vecinos
- **Outer-totalistas** (Life): $f$ depende del conteo y el estado central
- **Reversibles**: $f$ es biyectiva (invertible paso a paso)
- **EstocÃ¡sticos**: $f$ incorpora probabilidad $p \in [0,1]$
- **En grafos**: $\mathcal{N}$ definida por matriz de adyacencia

---

## 2. Componentes de un AC

```python
# Ejemplo de componentes en AutoCell
from autocell import neighborhoods as nb

# Estados: uint8 (binario) hasta uint32 (multi-estado)
# Vecindad: box de 3Ã—3 desplazada con roll
# BC: periodic, fixed(k), reflect, zero-gradient
# Calendario: sÃ­ncrono (default), async_random, block_margolus

grid = np.random.randint(0, 2, size=(100, 100), dtype=np.uint8)
neighbors = nb.moore_sum(grid, radius=1, bc="periodic")  # Suma de 8 vecinos
```

---

## 3. Implementaciones Esenciales

### 3.1 Juego de la Vida (outer-totalista 2D)

```python
import numpy as np
from autocell.neighborhoods import moore_sum

def step_life(grid: np.ndarray, bc="periodic") -> np.ndarray:
    """ImplementaciÃ³n vectorizada del Juego de la Vida B3/S23."""
    # Cuenta vecinos (8 para Moore)
    n = moore_sum(grid, radius=1, bc=bc)
    
    # Aplica reglas: nace con 3, sobrevive con 2-3
    births = (n == 3)
    survives = (grid == 1) & (n == 2)
    
    return (births | survives).astype(grid.dtype)
```

### 3.2 Wolfram 1D (radio 1, 8 patrones)

```python
def step_wolfram(cells: np.ndarray, rule: int, bc="periodic") -> np.ndarray:
    """EvoluciÃ³n de regla Wolfram 1D usando LUT."""
    lut = np.array([int(b) for b in f"{rule:08b}"[::-1]], dtype=np.uint8)
    
    # Vecindades: 3 celdas (izq, centro, der)
    left = np.roll(cells, -1)
    right = np.roll(cells, 1)
    idx = (left << 2) | (cells << 1) | right
    
    return lut[idx]
```

### 3.3 Reversible por Bloques (Margolus)

```python
def step_margolus(grid, block_rule, parity):
    """AC reversible usando particiÃ³n de bloques 2Ã—2."""
    # Alterna particiÃ³n segÃºn paridad t%2
    # Aplica permutaciÃ³n reversible en cada bloque
    # Garantiza invertibilidad fÃ­sica
    pass  # Ver notebook 04_reversible.ipynb
```

---

## 4. DinÃ¡micas Emergentes y MÃ©tricas

### ğŸ­ Patrones ClÃ¡sicos

| Tipo | DescripciÃ³n | Ejemplo Life |
|------|-------------|--------------|
| **Still Life** | ConfiguraciÃ³n estÃ¡tica | Block, Beehive, Loaf |
| **Oscillator** | PerÃ­odo finito >1 | Blinker, Toad, Pulsar |
| **Spaceship** | Se mueve en espacio | Glider, LWSS, MWSS, HWSS |
| **Gun** | Emite spaceships periÃ³dicamente | Gosper Glider Gun |

### ğŸ“ˆ MÃ©tricas Cuantitativas

```python
from autocell.metrics import density, shannon_entropy, glider_census

# Densidad activa
rho_t = density(grid)

# EntropÃ­a de Shannon (por ventana o global)
H = shannon_entropy(grid, base=2)

# Censo de gliders (pattern matching)
gliders = glider_census(frames, pattern="glider")
```

**FÃ³rmulas:**

- **Densidad**: $\rho_t = \frac{1}{|\mathcal{L}|} \sum_{c \in \mathcal{L}} s_t(c)$
- **EntropÃ­a**: $H = -\sum_{s \in \mathcal{S}} p(s) \log_2 p(s)$
- **AutocorrelaciÃ³n**: $C(\tau) = \langle s_t \cdot s_{t+\tau} \rangle$

---

## 5. Datos y Formatos

### ğŸ“¦ Formatos Soportados

| Formato | ExtensiÃ³n | Uso | Carga |
|---------|-----------|-----|-------|
| **RLE** | `.rle` | Patrones clÃ¡sicos (Life) | `load_rle()` |
| **Numpy** | `.npy` | Estados binarios/multi | `np.load()` |
| **Texto** | `.txt` | Matriz simple | `np.loadtxt()` |
| **YAML** | `.yaml` | ConfiguraciÃ³n completa | `load_config()` |

**Ejemplo de `config.yaml`:**
```yaml
model: life
size: [100, 100]
steps: 2000
bc: periodic
seed: 42
record:
  gif: images/run.gif
  fps: 15
metrics: [density, entropy, glider_census]
output_dir: results/
```

---

## 6. Rendimiento y GPU

### âš¡ Benchmarks (1000Ã—1000, 100 steps)

| Backend | Tiempo | Speedup | Notas |
|---------|--------|---------|-------|
| Pure Python | 120s | 1Ã— | No recomendado |
| NumPy | 2.1s | 57Ã— | VectorizaciÃ³n |
| Numba JIT | 0.3s | 400Ã— | Ideal para reglas custom |
| CuPy (GPU) | 0.08s | 1500Ã— | Requiere CUDA |
| PyTorch (GPU) | 0.05s | 2400Ã— | Mejor para batches |

**Best Practices:**
- âœ… Usa `np.roll` para vecindades pequeÃ±as (â‰¤ radio 3)
- âœ… Pre-alloca buffers con `np.empty_like`
- âœ… JIT con `@nb.njit` para reglas complejas
- âŒ Evita loops Python en el hot path
- âŒ Minimiza hostâ†”device transfers en GPU

---

## 7. Aplicaciones

### ğŸŒ Modelado Interdisciplinario

| Campo | Modelo AC | MÃ©trica Clave |
|-------|-----------|---------------|
| ğŸ”¬ **FÃ­sica** | DifusiÃ³n, PercolaciÃ³n, LBM simplificado | Umbral crÃ­tico $p_c$ |
| ğŸ§¬ **BiologÃ­a** | Crecimiento, MorfogÃ©nesis, Lenia | EntropÃ­a espacial |
| ğŸ™ï¸ **Sociales** | Contagio, OpiniÃ³n, Rumores en grafos | Tiempo de convergencia |
| ğŸ¨ **IngenierÃ­a** | Texturas procedurales, Arte generativo | EstÃ©tica/diversidad |
| ğŸ” **CriptografÃ­a** | CA caÃ³ticos (Rule 30) | EntropÃ­a/aperiodicidad |

---

## 8. Roadmap de Notebooks

| # | Notebook | Tema | DuraciÃ³n | Dificultad |
|---|----------|------|----------|------------|
| 01 | `01_intro_ac.ipynb` | Conceptos bÃ¡sicos, vecindades y BC | 30 min | â­ |
| 02 | `02_wolfram_1d.ipynb` | Reglas 1D (0-255), clases I-IV | 45 min | â­â­ |
| 03 | `03_life_2d.ipynb` | Juego de la Vida: gliders y osciladores | 60 min | â­â­ |
| 04 | `04_reversible.ipynb` | Bloques Margolus y reversibilidad | 45 min | â­â­â­ |
| 05 | `05_stochastic.ipynb` | Ruido, percolaciÃ³n, incendios | 60 min | â­â­ |
| 06 | `06_gpu_perf.ipynb` | Numba/CuPy/PyTorch benchmarks | 45 min | â­â­â­ |
| 07 | `07_graph_ca.ipynb` | AC en grafos complejos | 60 min | â­â­â­ |

*Todos los notebooks son **Colab-ready** con ejemplos ejecutables.*

---

## 9. Ejercicios Propuestos

### ğŸ“ TeÃ³ricos (Pensamiento CrÃ­tico)

1. **ClasificaciÃ³n**: Analiza Regla 18 vs 110. Â¿Por quÃ© 110 es universal y 18 no? Argumenta con gliders y gaps.
2. **Reversibilidad**: DiseÃ±a un esquema por bloques 3Ã—3 que sea reversible. Demuestra la inversibilidad matemÃ¡tica.
3. **Universalidad**: Si Rule 110 es universal, Â¿por quÃ© el Juego de la Vida es mÃ¡s famoso? Discute trade-offs.

### ğŸ”¬ PrÃ¡cticos (ImplementaciÃ³n)

| Ejercicio | Objetivo | Dificultad | Hints |
|-----------|----------|------------|-------|
| **Incendios** | AC estocÃ¡stico B/S con probabilidad $p$. Encuentra $p_c$ de percolaciÃ³n | â­â­ | Usa `np.random.random` |
| **Detector de Gliders** | Automatiza detecciÃ³n de gliders en Life | â­â­â­ | Pattern matching con `scipy.signal` |
| **Numba vs NumPy** | Benchmark: Life 1000Ã—1000, 100 steps | â­ | `@nb.njit(parallel=True)` |
| **CA en Grafos** | Implementa SIR en red BarabÃ¡si-Albert | â­â­â­ | Usa `networkx` para el grafo |
| **Lenia Continuo** | AC continuo en 2D con kernel gaussiano | â­â­â­â­ | Ver paper de Bert Wang-Chak Chan |

---

## 10. Errores Comunes & Soluciones

| âŒ Error | âš ï¸ Impacto | âœ… SoluciÃ³n |
|----------|------------|--------------|
| **BC incorrecta** | Artefactos en bordes | Verifica `bc="fixed"` para experimentos abiertos |
| **Loops Python** | Simulaciones lentas | Vectoriza con NumPy o JIT con Numba |
| **Seed no fijada** | Resultados irreproducibles | `np.random.seed(42)` o usa `rng.py` |
| **Ruido transitorio** | ClasificaciÃ³n errÃ³nea | Analiza $t \to \infty$ y mÃºltiples seeds |
| **Overflow en estados** | Valores incorrectos | Usa `dtype=np.uint8` o superior |

---

## 11. API Breve (Completa)

```python
# src/autocell/core.py
evolve(init: np.ndarray, step_fn: Callable, steps: int, 
       record: bool = False, **kwargs) -> Iterator[np.ndarray]
step_life(grid: np.ndarray, bc="periodic") -> np.ndarray
step_wolfram(grid: np.ndarray, rule: int, bc="periodic") -> np.ndarray
step_margolus(grid, block_rule, parity: int) -> np.ndarray

# src/autocell/neighborhoods.py
moore_sum(grid, radius=1, bc="periodic") -> np.ndarray
von_neumann_sum(grid, radius=1, bc="periodic") -> np.ndarray
graph_neighbors(grid, adjacency_matrix) -> np.ndarray

# src/autocell/rules.py
rule_totalistic(counts, survive: tuple, born: tuple) -> np.ndarray
rule_outer_totalistic(counts, center, survive: tuple, born: tuple) -> np.ndarray
rule_wolfram_table(rule: int) -> np.ndarray  # LUT 8â†’1

# src/autocell/viz.py
animate_gif(frames: List[np.ndarray], path: str, fps: int = 10, 
            cmap: str = "binary", dpi: int = 100)
plot_space_time(evolution, rule: int = None) -> plt.Figure

# src/autocell/metrics.py
density(grid) -> float
entropy(grid, base: int = 2) -> float
glider_census(frames, pattern: str = "glider") -> Dict
```

---

## 12. CÃ³mo Contribuir

Â¡Nos encanta la colaboraciÃ³n! Sigue estos pasos:

1. **Fork** el repo y crea una rama: `git checkout -b feature/mi-aporte`
2. **Sigue el estilo**: `black` y `ruff` (configurado en `pyproject.toml`)
3. **AÃ±ade tests**: Usa `pytest` y `hypothesis` para propiedades
4. **Ejecuta checks**: `pre-commit run -a && pytest -q`
5. **Haz PR**: Describe el cambio, aÃ±ade benchmarks si aplica

**Ãreas abiertas:**
- [ ] AC cuÃ¡nticos (QCA)
- [ ] OptimizaciÃ³n multi-GPU
- [ ] MÃ¡s formatos de importaciÃ³n (CATIA, Life 1.06)
- [ ] VisualizaciÃ³n 3D para AC 3D
- [ ] ExportaciÃ³n a WebGL para web

---

## 13. Licencia

- **CÃ³digo fuente**: [MIT License](../LICENSE) â€” Usa, modifica, distribuye libremente
- **Contenido educativo**: [CC BY 4.0](https://creativecommons.org/licenses/by/4.0/) â€” Atribuye al autor

---

## ApÃ©ndice A: Diagramas Mermaid

### A.1 Flujo General de SimulaciÃ³n

```mermaid
flowchart TD
    S([Inicio]) --> Cfg["Definir: tamaÃ±o, estados, vecindad, BC, seed"]
    Cfg --> Init["Inicializar patrÃ³n (aleatorio/RLE/custom)"]
    Init --> Loop{"Â¿t < T?"}
    Loop -- SÃ­ --> Neigh["Calcular vecindarios / conteos"]
    Neigh --> Rule["Aplicar regla local f"]
    Rule --> State["Actualizar estado (buffer doble)"]
    State --> Rec["Registrar mÃ©tricas/frames"]
    Rec --> Loop
    Loop -- No --> Viz["Visualizar/guardar GIF/CSV"]
    Viz --> End([Fin])
```

### A.2 Juego de la Vida (outer-totalista)

```mermaid
graph LR
    A["Conteo de 8 vecinos (n)"] --> B{"Â¿n == 3?"}
    B -- SÃ­ --> Alive["Viva (1)"]
    B -- No --> C{"Â¿(n == 2) y (celda == 1)?"}
    C -- SÃ­ --> Alive
    C -- No --> Dead["Muerta (0)"]
```

---

## ApÃ©ndice B: PseudocÃ³digo y Reglas

### GenÃ©rico (SÃ­ncrono, Buffer Doble)

```text
func Evolve(L, S, N, f, T, bc, seed):
    x â† init_state(L, seed)
    for t in 1..T:
        for cell in L:
            v â† neighborhood(x, cell, N, bc)
            y[cell] â† f(v)
        swap(x, y)
    return x
```

### Wolfram 1D (radio 1)

```python
# RepresentaciÃ³n como entero 0-255
# Ãndice: idx = 4*a + 2*b + c
# PatrÃ³n 111..000 â†’ bits 7..0
lut = np.array([int(b) for b in f"{rule:08b}"[::-1]])
```

### Life (B3/S23)

```python
# Nace con 3 vecinos (B3)
# Sobrevive con 2-3 vecinos (S23)
births = (n == 3)
survives = (grid == 1) & (n == 2)
new_grid = (births | survives).astype(np.uint8)
```

---

## ApÃ©ndice C: Plantilla de Notebook

Usa esta plantilla para crear notebooks consistentes:

```markdown
# TÃ­tulo: [AC Tema] â€” [Enfoque]

## 1. Objetivos
- QuÃ© aprenderÃ¡s y quÃ© mÃ©tricas medirÃ¡s.

## 2. ConfiguraciÃ³n
```python
SEED = 42
SIZE = (100, 100)
STEPS = 200
BC = "periodic"
BACKEND = "numba"  # numpy, numba, cupy
```

## 3. ImplementaciÃ³n
- CÃ³digo base
- VersiÃ³n optimizada

## 4. Experimentos
- VariaciÃ³n de parÃ¡metros
- Benchmarks

## 5. Resultados
- Visualizaciones (GIFs, plots)
- Tablas de mÃ©tricas

## 6. Conclusiones
- QuÃ© funcionÃ³ y lÃ­mites encontrados
- Trabajo futuro
```

---

## ğŸ“š Referencias y Recursos Clave

### ğŸ“„ BibliografÃ­a Fundamental

* **S. Wolfram**, *A New Kind of Science* (2002) â€” Clases de comportamiento
* **A. Ilachinski**, *Cellular Automata: A Discrete Universe* (2001) â€” Fundamentos matemÃ¡ticos
* **A. Adamatzky** (Ed.), *Game of Life Cellular Automata* (2010) â€” Life avanzado
* **T. Toffoli & N. Margolus**, *Cellular Automata Machines* (1987) â€” Reversibilidad
* **B. Chopard & M. Droz**, *Cellular Automata Modeling of Physical Systems* (1998) â€” Aplicaciones fÃ­sicas

### ğŸ”— Enlaces Adicionales

- [ConwayLife.com](http://conwaylife.com) â€” Base de datos de patrones Life
- [Catagolue](https://catagolue.appspot.com) â€” Censo de objetos en Life
- [Wolfram Atlas](http://atlas.wolfram.com) â€” Reglas elementales 1D

> ğŸ¯ **Cita este trabajo**: Si usas AutoCell en tu investigaciÃ³n, por favor cita usando el archivo [`CITATION.cff`](../CITATION.cff).

---

<p align="center">
  <em>Desarrollado con â¤ï¸ para la comunidad de ciencias de la computaciÃ³n</em><br>
  <em>Â¿Preguntas? Abre un issue o contacta: <a href="mailto:contact@example.com">contact@example.com</a></em>
</p>
