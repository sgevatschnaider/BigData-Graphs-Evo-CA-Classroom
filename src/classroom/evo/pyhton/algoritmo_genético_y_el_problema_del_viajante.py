# -*- coding: utf-8 -*-
"""Algoritmo_gen√©tico_y_el_problema_del_viajante.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1TZHeEzV5YuyXC4SlCBWbTzClo5h4sUP2
"""

# Importar las funciones necesarias de IPython para mostrar HTML
from IPython.core.display import display, HTML

# Definir el contenido HTML, CSS y JavaScript como un string multil√≠nea
html_content = """
<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>AlphaEvolve: AG con Q-learning para el TSP</title>
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&family=Lora:ital,wght@0,400;0,700;1,400&display=swap" rel="stylesheet">
  <style>
    /* Definici√≥n de variables CSS para temas */
    :root {
      --bg-color: #fdfefe; /* Blanco hueso */
      --text-color: #34495e; /* Azul pizarra */
      --header-color: #2c3e50; /* Azul medianoche */
      --header-dark-color: #bdc3c7; /* Plata */
      --accent-color: #16a085; /* Verde mar */
      --accent-dark-color: #48c9b0; /* Turquesa */
      --button-bg: #3498db; /* Azul Peter River */
      --button-hover-bg: #2980b9; /* Azul Belize Hole */
      --button-dark-bg: #8e44ad; /* Amatista */
      --button-dark-hover-bg: #9b59b6; /* Lila */
      --button-text-color: white;
      --theme-button-bg: #7f8c8d; /* Gris asfalto */
      --theme-button-dark-bg: #f39c12; /* Naranja */
      --content-panel-bg: #ecf0f1; /* Nubes */
      --content-panel-dark-bg: #3b5368; /* Un gris azulado m√°s oscuro */
      --author-color: #566573; /* Gris pizarra m√°s claro */
      --index-button-bg: #5dade2; /* Azul claro para botones de √≠ndice */
      --index-button-hover-bg: #2e86c1;
      --index-button-dark-bg: #af7ac5; /* Morado claro para √≠ndice oscuro */
      --index-button-dark-hover-bg: #9b59b6;
    }

    body {
      font-family: 'Lora', 'Roboto', serif;
      line-height: 1.9;
      background-color: var(--bg-color);
      color: var(--text-color);
      transition: background-color 0.3s, color 0.3s;
      padding: 20px;
      margin: 0;
    }
    .container {
      max-width: 1000px;
      margin: auto;
      padding: 30px;
      position: relative;
      background-color: var(--bg-color);
      border-radius: 8px;
      box-shadow: 0 4px 10px rgba(0,0,0,0.05);
    }
    body.dark-mode .container {
        box-shadow: 0 4px 15px rgba(0,0,0,0.15);
    }
    body.dark-mode {
      --bg-color: #2c3e50;
      --text-color: #ecf0f1;
      --header-color: var(--header-dark-color);
      --accent-color: var(--accent-dark-color);
      --button-bg: var(--button-dark-bg);
      --button-hover-bg: var(--button-dark-hover-bg);
      --content-panel-bg: var(--content-panel-dark-bg);
      --author-color: #bdc3c7;
      --index-button-bg: var(--index-button-dark-bg);
      --index-button-hover-bg: var(--index-button-dark-hover-bg);
    }

    h1 {
      font-family: 'Roboto', sans-serif;
      font-size: 2.6em;
      color: var(--header-color);
      text-align: center;
      margin-bottom: 15px;
    }
    .author-line {
        font-family: 'Roboto', sans-serif;
        text-align: center;
        color: var(--author-color);
        font-size: 1.1em;
        margin-bottom: 30px;
        font-style: italic;
    }
    .section-toggle-button h2 {
      font-family: 'Roboto', sans-serif;
      font-size: 1.6em;
      color: var(--button-text-color);
      margin: 0;
      padding: 0;
      font-weight: 700;
      text-align: left;
    }
     .content-panel h3 {
      font-family: 'Roboto', sans-serif;
      font-size: 1.4em;
      color: var(--accent-color);
      margin-top: 15px;
      margin-bottom: 10px;
      padding-bottom: 5px;
      border-bottom: 1px solid var(--accent-color);
      text-align: left;
    }
    .index-item-panel p, .index-item-panel ul {
        font-family: 'Lora', serif;
        font-size: 1em;
        margin-bottom: 0.5em;
    }
    .index-item-panel ul { padding-left: 20px; }


    .content-panel {
      display: none;
      margin-top: 0;
      padding: 20px 25px;
      border-left: 4px solid var(--accent-color);
      background-color: var(--content-panel-bg);
      border-radius: 0 0 6px 6px;
    }
    .content-panel.is-visible {
      display: block;
    }
    /* Estilo espec√≠fico para el panel de Objetivo */
    #alpha_objetivo ul {
        list-style-type: disc; /* Vi√±etas est√°ndar para la lista de objetivos */
    }


    .section-toggle-button {
      background-color: var(--button-bg);
      border: none;
      padding: 14px 20px;
      border-radius: 6px;
      cursor: pointer;
      margin-top: 18px;
      transition: background-color 0.3s, border-radius 0.2s;
      width: 100%;
      display: flex;
      align-items: center;
    }
    .section-toggle-button:hover {
      background-color: var(--button-hover-bg);
    }
    .section-toggle-button.is-expanded {
        border-radius: 6px 6px 0 0;
    }

    /* --- MODIFICACI√ìN AQU√ç --- */
    .index-main-button {
        /* background-color: var(--header-color); Ya no es necesario, heredar√° de .section-toggle-button */
        margin-top: 25px; /* Mantenemos el margen superior espec√≠fico */
    }
    /* body.dark-mode .index-main-button {
        background-color: var(--header-dark-color); Ya no es necesario
        color: var(--bg-color); Esto hac√≠a que el texto del h2 fuera oscuro sobre fondo oscuro del bot√≥n,
                                ahora el h2 heredar√° el color de .section-toggle-button h2 (blanco)
    } */
    .index-main-button h2 { font-size: 1.8em; } /* Mantenemos el tama√±o de fuente espec√≠fico para el h2 */

    .index-item-button {
        background-color: var(--index-button-bg);
        font-size: 1.1em;
        padding: 10px 15px;
        margin-top: 8px;
        margin-left: 20px;
        width: calc(100% - 20px);
    }
     .index-item-button h2 {
        font-size: 1.1em;
        font-weight: normal;
    }


    .theme-toggle {
      background-color: var(--theme-button-bg);
      color: white;
      border: none;
      padding: 9px 14px;
      border-radius: 6px;
      cursor: pointer;
      position: absolute;
      top: 30px;
      right: 30px;
      font-size: 0.9em;
      transition: background-color 0.3s;
      z-index: 10;
    }
    body.dark-mode .theme-toggle {
       background-color: var(--theme-button-dark-bg);
       color: var(--text-color);
    }

    button:focus, a:focus {
        outline: 2px solid var(--accent-color);
        outline-offset: 3px;
    }
    body.dark-mode button:focus, body.dark-mode a:focus {
         outline-color: var(--accent-dark-color);
    }
    .content-panel p, .content-panel ul {
        margin-bottom: 1.1em;
    }
    .content-panel p:last-child, .content-panel ul:last-child {
        margin-bottom: 0;
    }
    ul {
        padding-left: 30px;
    }
    li {
        margin-bottom: 0.6em;
    }
    strong {
        font-weight: 700;
    }
    hr {
        border: 0;
        height: 1px;
        background-image: linear-gradient(to right, rgba(0,0,0,0), var(--text-color), rgba(0,0,0,0));
        opacity: 0.5;
        margin: 30px 0;
    }
  </style>
</head>
<body>
  <div class="container">
    <button id="theme-toggle-btn" class="theme-toggle" onclick="toggleTheme()" title="Cambiar tema de color">Modo Oscuro</button>

    <!-- --- MODIFICACI√ìN AQU√ç --- -->
    <h1>El Problema del viajante y el algoritmo gen√©tico</h1>
    <p class="author-line">Material Elaborado por Sergio Gevatschnaider</p>

    <!-- Secci√≥n: Introducci√≥n  -->
    <button class="section-toggle-button" onclick="toggleSection('alpha_intro', this)" aria-expanded="false" aria-controls="alpha_intro">
      <h2>Introducci√≥n  al M√≥dulo</h2>
    </button>
    <div id="alpha_intro" class="content-panel">
      <h3>El Desaf√≠o del Problema del Viajante (TSP)</h3>
      <p>El Problema del Viajante (TSP, por sus siglas en ingl√©s) es uno de los desaf√≠os m√°s emblem√°ticos en la teor√≠a de la optimizaci√≥n combinatoria. Su formulaci√≥n simple ‚Äîencontrar la ruta m√°s corta que recorre un conjunto de ciudades visitando cada una exactamente una vez y regresando al punto de origen‚Äî contrasta con su complejidad computacional, al ser un problema NP-hard. Esta dificultad ha motivado el desarrollo de estrategias heur√≠sticas y metaheur√≠sticas capaces de hallar soluciones eficientes en contextos reales, donde m√©todos exactos resultan inabordables.</p>
      <h3>Algoritmos Gen√©ticos y la Hibridaci√≥n con Aprendizaje por Refuerzo</h3>
      <p>En este contexto, los algoritmos gen√©ticos (AG) destacan como una herramienta poderosa, gracias a su capacidad de adaptaci√≥n y exploraci√≥n de espacios de soluciones extensos. El presente m√≥dulo se centra en el dise√±o, implementaci√≥n y an√°lisis de un algoritmo gen√©tico extendido con aprendizaje por refuerzo (espec√≠ficamente, Q-learning) para la selecci√≥n adaptativa de operadores de mutaci√≥n. Esta hibridaci√≥n evolutiva refuerza el proceso de b√∫squeda local y global, permitiendo al algoritmo evolucionar su propia estrategia de variaci√≥n en funci√≥n del desempe√±o observado.</p>
      <h3>Enfoque del M√≥dulo: AlphaEvolve</h3>
      <p>A trav√©s de visualizaciones din√°micas, formulaciones te√≥ricas y resultados cuantitativos, se busca ofrecer una experiencia integral que combina la teor√≠a evolutiva con la implementaci√≥n computacional moderna. Esta aproximaci√≥n, denominada AlphaEvolve, propone una arquitectura flexible y extensible para abordar instancias complejas del TSP y, potencialmente, de otros problemas combinatorios.</p>
    </div>
    <hr>

    <!-- Secci√≥n: Objetivo -->
    <button class="section-toggle-button" onclick="toggleSection('alpha_objetivo', this)" aria-expanded="false" aria-controls="alpha_objetivo">
      <h2>Objetivo </h2>
    </button>
    <div id="alpha_objetivo" class="content-panel">
      <p>Desarrollar e implementar un algoritmo gen√©tico h√≠brido con aprendizaje por refuerzo (Q-learning) para resolver de manera eficiente el Problema del Viajante, analizando su comportamiento adaptativo en la selecci√≥n de operadores de mutaci√≥n, su capacidad de escape del estancamiento evolutivo, y su desempe√±o frente a estrategias tradicionales.</p>
      <p>Este objetivo incluye:</p>
      <ul>
        <li>Explorar la sinergia entre t√©cnicas evolutivas y aprendizaje por refuerzo.</li>
        <li>Medir la influencia del agente Q-learning sobre la convergencia y la diversidad poblacional.</li>
        <li>Evaluar la escalabilidad y generalizaci√≥n del enfoque a distintas instancias del TSP.</li>
      </ul>
    </div>
    <hr>

    <!-- Secci√≥n: √çndice Propuesto -->
    <!-- La clase index-main-button se mantiene para otros estilos como margin-top o el tama√±o del h2, pero el color de fondo ahora lo hereda -->
    <button class="section-toggle-button index-main-button" onclick="toggleSection('alpha_indice', this)" aria-expanded="false" aria-controls="alpha_indice">
      <h2>√çndice del M√≥dulo</h2>
    </button>
    <div id="alpha_indice" class="content-panel">
      <!-- Fundamentos del TSP -->
      <button class="section-toggle-button index-item-button" onclick="toggleSection('idx_fund_tsp', this)" aria-expanded="false" aria-controls="idx_fund_tsp">
        <h2>Fundamentos del Problema del Viajante (TSP)</h2>
      </button>
      <div id="idx_fund_tsp" class="content-panel index-item-panel">
        <p>Definici√≥n formal del problema</p>
        <p>Complejidad computacional y espacio de soluciones</p>
      </div>

      <!-- Teor√≠a de AG -->
      <button class="section-toggle-button index-item-button" onclick="toggleSection('idx_teoria_ag', this)" aria-expanded="false" aria-controls="idx_teoria_ag">
        <h2>Teor√≠a de Algoritmos Gen√©ticos</h2>
      </button>
      <div id="idx_teoria_ag" class="content-panel index-item-panel">
        <p>Principios biol√≥gicos y computacionales</p>
        <p>Representaci√≥n gen√©tica para problemas de permutaci√≥n</p>
        <p>Operadores cl√°sicos: selecci√≥n, cruce, mutaci√≥n</p>
      </div>

      <!-- Dise√±o del AG para TSP -->
      <button class="section-toggle-button index-item-button" onclick="toggleSection('idx_diseno_ag_tsp', this)" aria-expanded="false" aria-controls="idx_diseno_ag_tsp">
        <h2>Dise√±o del AG para TSP</h2>
      </button>
      <div id="idx_diseno_ag_tsp" class="content-panel index-item-panel">
        <p>Codificaci√≥n del recorrido</p>
        <p>Heur√≠sticas iniciales (aleatorio, vecino m√°s cercano, greedy)</p>
        <p>Evaluaci√≥n de fitness y penalizaci√≥n estructurada</p>
      </div>

      <!-- Extensi√≥n con Q-learning: AlphaEvolve -->
      <button class="section-toggle-button index-item-button" onclick="toggleSection('idx_qlearning', this)" aria-expanded="false" aria-controls="idx_qlearning">
        <h2>Extensi√≥n con Q-learning: AlphaEvolve</h2>
      </button>
      <div id="idx_qlearning" class="content-panel index-item-panel">
        <p>Motivaci√≥n para aprendizaje adaptativo de mutaciones</p>
        <p>Estados, acciones y recompensas en el contexto evolutivo</p>
        <p>Adaptaci√≥n del par√°metro epsilon y exploraci√≥n/explotaci√≥n</p>
      </div>

      <!-- Visualizaci√≥n Din√°mica -->
      <button class="section-toggle-button index-item-button" onclick="toggleSection('idx_visualizacion', this)" aria-expanded="false" aria-controls="idx_visualizacion">
        <h2>Visualizaci√≥n Din√°mica del Proceso Evolutivo</h2>
      </button>
      <div id="idx_visualizacion" class="content-panel index-item-panel">
        <p>Evoluci√≥n de la mejor soluci√≥n</p>
        <p>Diversidad poblacional y estancamiento</p>
        <p>Comportamiento del agente RL (acciones, epsilon, recompensas)</p>
      </div>

      <!-- Evaluaci√≥n de Resultados -->
      <button class="section-toggle-button index-item-button" onclick="toggleSection('idx_evaluacion', this)" aria-expanded="false" aria-controls="idx_evaluacion">
        <h2>Evaluaci√≥n de Resultados</h2>
      </button>
      <div id="idx_evaluacion" class="content-panel index-item-panel">
        <p>An√°lisis cuantitativo del desempe√±o</p>
        <p>Comparaci√≥n con estrategias no adaptativas</p>
        <p>Observaciones sobre convergencia y diversidad</p>
      </div>

      <!-- Discusi√≥n y Extensiones -->
      <button class="section-toggle-button index-item-button" onclick="toggleSection('idx_discusion', this)" aria-expanded="false" aria-controls="idx_discusion">
        <h2>Discusi√≥n y Extensiones</h2>
      </button>
      <div id="idx_discusion" class="content-panel index-item-panel">
        <p>Uso de experience replay (futuro)</p>
        <p>Hibridaci√≥n con t√©cnicas como simulated annealing o local search</p>
        <p>Aplicabilidad a otros problemas NP-hard</p>
      </div>

      <!-- Conclusi√≥n -->
      <button class="section-toggle-button index-item-button" onclick="toggleSection('idx_conclusion_final', this)" aria-expanded="false" aria-controls="idx_conclusion_final">
        <h2>Conclusi√≥n</h2>
      </button>
      <div id="idx_conclusion_final" class="content-panel index-item-panel">
        <p>Reflexi√≥n sobre la efectividad de la arquitectura</p>
        <p>Aportes del enfoque adaptativo al campo de la optimizaci√≥n evolutiva</p>
      </div>

      <!-- Anexos -->
      <button class="section-toggle-button index-item-button" onclick="toggleSection('idx_anexos', this)" aria-expanded="false" aria-controls="idx_anexos">
        <h2>Anexos</h2>
      </button>
      <div id="idx_anexos" class="content-panel index-item-panel">
        <p>C√≥digo fuente documentado</p>
        <p>Par√°metros utilizados</p>
        <p>Instancias de prueba reproducibles</p>
      </div>
    </div> <!-- Fin del panel principal del √≠ndice -->

  </div> <!-- Fin de .container -->

  <script>
    // Funci√≥n para cambiar entre modo claro y oscuro
    function toggleTheme() {
      document.body.classList.toggle("dark-mode");
      let themeButton = document.getElementById('theme-toggle-btn');
      let isDarkMode = document.body.classList.contains("dark-mode");
      localStorage.setItem("theme", isDarkMode ? "dark" : "light");
      if (themeButton) {
          themeButton.textContent = isDarkMode ? "Modo Claro" : "Modo Oscuro";
      }
    }

    // Funci√≥n para mostrar/ocultar paneles de contenido
    function toggleSection(id, buttonElement) {
      let panel = document.getElementById(id);
      if (panel && buttonElement) {
          panel.classList.toggle('is-visible');
          let isVisible = panel.classList.contains('is-visible');
          buttonElement.setAttribute('aria-expanded', isVisible);
          buttonElement.classList.toggle('is-expanded', isVisible);
      }
    }

    // Funci√≥n que se ejecuta cuando la p√°gina carga
    window.onload = function() {
      let themeButton = document.getElementById('theme-toggle-btn');
      const savedTheme = localStorage.getItem("theme");

      if (savedTheme === "dark") {
        document.body.classList.add("dark-mode");
        if (themeButton) {
            themeButton.textContent = "Modo Claro";
        }
      } else {
        document.body.classList.remove("dark-mode");
        if (themeButton) {
            themeButton.textContent = "Modo Oscuro";
        }
      }

       document.querySelectorAll('.content-panel').forEach(panel => {
         panel.classList.remove('is-visible');
       });
       document.querySelectorAll('.section-toggle-button').forEach(button => {
          button.setAttribute('aria-expanded', 'false');
          button.classList.remove('is-expanded');
       });
    }
  </script>
</body>
</html>
"""

# Mostrar el HTML en la salida de la celda
display(HTML(html_content))

# Importar las funciones necesarias de IPython para mostrar HTML
from IPython.core.display import display, HTML

# Definir el contenido HTML, CSS y JavaScript como un string multil√≠nea
html_content = """
<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Algoritmos Gen√©ticos: Una Introducci√≥n Detallada</title>
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet">
  <style>
    /* Definici√≥n de variables CSS para temas */
    :root {
      --bg-color: #f9f9f9;
      --text-color: #333;
      --header-color: #2c3e50;
      --header-dark-color: #ecf0f1;
      --accent-color: #16a085; /* Verde azulado para GA */
      --accent-dark-color: #76d7c4; /* Verde azulado m√°s claro para modo oscuro */
      --button-bg: #1abc9c; /* Verde azulado m√°s brillante para botones */
      --button-hover-bg: #16a085; /* Verde azulado para hover */
      --button-dark-bg: #e67e22; /* Naranja para modo oscuro */
      --button-dark-hover-bg: #d35400; /* Naranja oscuro para hover */
      --button-text-color: white;
      --theme-button-bg: #8e44ad; /* Morado claro */
      --theme-button-dark-bg: #f39c12; /* Naranja */
      --content-panel-bg: #f1fefd;
      --content-panel-dark-bg: #283747;
      --table-border-color: #bdc3c7;
      --table-header-bg: #e8f6f3;
      --table-header-dark-bg: #3e5b76;
    }

    body {
      font-family: 'Roboto', Arial, sans-serif;
      line-height: 1.8;
      background-color: var(--bg-color);
      color: var(--text-color);
      transition: background-color 0.3s, color 0.3s;
      padding: 20px;
      margin: 0;
    }
    .container {
      max-width: 900px;
      margin: auto;
      padding: 20px;
      position: relative;
      background-color: var(--bg-color);
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    }
    body.dark-mode .container {
        box-shadow: 0 2px 10px rgba(0,0,0,0.3);
    }
    body.dark-mode {
      --bg-color: #2c3e50;
      --text-color: #ecf0f1;
      --header-color: var(--header-dark-color);
      --accent-color: var(--accent-dark-color);
      --button-bg: var(--button-dark-bg);
      --button-hover-bg: var(--button-dark-hover-bg);
      --content-panel-bg: var(--content-panel-dark-bg);
      --table-border-color: #566573;
      --table-header-bg: var(--table-header-dark-bg);
    }

    h1 {
      font-size: 2.4em;
      color: var(--header-color);
      text-align: center;
      margin-bottom: 15px;
    }
     h2 { /* Para subt√≠tulos dentro de las secciones */
      font-size: 1.6em;
      color: var(--accent-color);
      margin-top: 20px;
      margin-bottom: 10px;
      padding-bottom: 3px;
      border-bottom: 2px solid var(--accent-color);
      text-align: left;
    }
    h3 { /* Para sub-subt√≠tulos */
      font-size: 1.3em;
      color: var(--header-color);
      margin-top: 15px;
      margin-bottom: 8px;
      text-align: left;
    }


    .content-panel {
      display: none;
      margin-top: 0;
      padding: 20px;
      border-left: 4px solid var(--accent-color);
      background-color: var(--content-panel-bg);
      border-radius: 0 0 5px 5px;
    }
    .content-panel.is-visible {
      display: block;
    }

    .section-toggle-button {
      background-color: var(--button-bg);
      color: var(--button-text-color);
      border: none;
      padding: 12px 18px;
      border-radius: 5px;
      cursor: pointer;
      margin-top: 15px;
      transition: background-color 0.3s, border-radius 0.2s;
      width: 100%;
      text-align: left;
      font-size: 1.2em;
      font-weight: 700; /* Roboto bold */
    }
    .section-toggle-button:hover {
      background-color: var(--button-hover-bg);
    }
    .section-toggle-button.is-expanded {
        border-radius: 5px 5px 0 0;
    }

    .theme-toggle {
      background-color: var(--theme-button-bg);
      color: white;
      border: none;
      padding: 8px 12px;
      border-radius: 5px;
      cursor: pointer;
      position: absolute;
      top: 20px;
      right: 20px;
      font-size: 0.9em;
      transition: background-color 0.3s;
      z-index: 10;
    }
    body.dark-mode .theme-toggle {
       background-color: var(--theme-button-dark-bg);
    }

    button:focus, a:focus {
        outline: 2px solid var(--accent-color);
        outline-offset: 2px;
    }
    body.dark-mode button:focus, body.dark-mode a:focus {
         outline-color: var(--accent-dark-color);
    }
    .content-panel p, .content-panel ul, .content-panel ol {
        margin-bottom: 1em;
    }
    .content-panel p:last-child, .content-panel ul:last-child, .content-panel ol:last-child {
        margin-bottom: 0;
    }
    ul, ol {
        padding-left: 30px;
    }
    li {
        margin-bottom: 0.5em;
    }
    strong {
        font-weight: 700; /* Roboto bold */
    }

    /* Estilos para la tabla Ventajas/Desventajas */
    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 15px;
      margin-bottom: 15px;
    }
    th, td {
      border: 1px solid var(--table-border-color);
      padding: 10px;
      text-align: left;
      vertical-align: top;
    }
    th {
      background-color: var(--table-header-bg);
      color: var(--header-color);
      font-weight: 700;
    }
    body.dark-mode th {
        color: var(--header-dark-color);
    }
    caption {
      caption-side: top;
      font-size: 1.2em;
      font-weight: bold;
      color: var(--header-color);
      margin-bottom: 10px;
      text-align: center;
    }

  </style>
</head>
<body>
  <div class="container">
    <button id="theme-toggle-btn" class="theme-toggle" onclick="toggleTheme()" title="Cambiar tema de color">Modo Oscuro</button>

    <h1>Algoritmos Gen√©ticos: Una Introducci√≥n Detallada</h1>

    <!-- Secci√≥n: ¬øQu√© es un Algoritmo Gen√©tico? -->
    <button class="section-toggle-button" onclick="toggleSection('ga_que_es', this)" aria-expanded="false" aria-controls="ga_que_es">
      ¬øQu√© es un Algoritmo Gen√©tico?
    </button>
    <div id="ga_que_es" class="content-panel">
      <p>Un algoritmo gen√©tico (GA, por sus siglas en ingl√©s) es un m√©todo de optimizaci√≥n y b√∫squeda heur√≠stica inspirado en los principios de la selecci√≥n natural y la evoluci√≥n biol√≥gica propuestos por Charles Darwin. Forma parte del campo de la inteligencia artificial y m√°s espec√≠ficamente de los algoritmos evolutivos.</p>
      <p>Su fortaleza radica en la capacidad de explorar grandes espacios de soluciones y encontrar √≥ptimos aproximados en problemas donde los m√©todos cl√°sicos de optimizaci√≥n son poco eficaces o inviables por la complejidad del problema.</p>
      <h3>Definici√≥n Formal</h3>
      <p>Un algoritmo gen√©tico es un procedimiento estoc√°stico que simula la evoluci√≥n de una poblaci√≥n de individuos para resolver un problema de optimizaci√≥n. Cada individuo representa una posible soluci√≥n codificada como un genotipo (cromosoma), y su calidad se eval√∫a mediante una funci√≥n de aptitud (fitness).</p>
    </div>

    <!-- Secci√≥n: ¬øC√≥mo funciona un Algoritmo Gen√©tico? -->
    <button class="section-toggle-button" onclick="toggleSection('ga_como_funciona', this)" aria-expanded="false" aria-controls="ga_como_funciona">
      ¬øC√≥mo funciona un Algoritmo Gen√©tico?
    </button>
    <div id="ga_como_funciona" class="content-panel">
      <p>El proceso puede resumirse en los siguientes pasos fundamentales:</p>
      <ol>
        <li><strong>Inicializaci√≥n:</strong> Se genera una poblaci√≥n inicial de soluciones aleatorias.</li>
        <li><strong>Evaluaci√≥n:</strong> Cada individuo es evaluado con la funci√≥n de fitness, que mide qu√© tan buena es esa soluci√≥n.</li>
        <li><strong>Selecci√≥n:</strong> Se seleccionan los individuos m√°s aptos para reproducirse. Se usan m√©todos como ruleta, torneo o elitismo.</li>
        <li><strong>Cruzamiento (Crossover):</strong> Se combinan pares de individuos seleccionados para producir descendientes con mezcla gen√©tica.</li>
        <li><strong>Mutaci√≥n:</strong> Se introducen cambios aleatorios en los descendientes para mantener diversidad gen√©tica.</li>
        <li><strong>Reemplazo:</strong> Se forman nuevas generaciones con los descendientes, reemplazando parte o toda la poblaci√≥n anterior.</li>
        <li><strong>Criterio de parada:</strong> El algoritmo se detiene cuando se cumple un n√∫mero de generaciones, se alcanza un valor objetivo, o no hay mejoras significativas.</li>
      </ol>
    </div>

    <!-- Secci√≥n: Representaci√≥n Gen√©tica (Codificaci√≥n) -->
    <button class="section-toggle-button" onclick="toggleSection('ga_representacion', this)" aria-expanded="false" aria-controls="ga_representacion">
      Representaci√≥n Gen√©tica (Codificaci√≥n)
    </button>
    <div id="ga_representacion" class="content-panel">
      <p>Existen m√∫ltiples formas de codificar una soluci√≥n:</p>
      <ul>
        <li><strong>Binaria:</strong> uso de cadenas de 0s y 1s.</li>
        <li><strong>Entera o real:</strong> para problemas con variables num√©ricas.</li>
        <li><strong>Permutaciones:</strong> com√∫n en problemas de grafos como el viajero (TSP).</li>
        <li><strong>√Årboles:</strong> como en la programaci√≥n gen√©tica.</li>
      </ul>
    </div>

    <!-- Secci√≥n: Aplicaciones Pr√°cticas -->
    <button class="section-toggle-button" onclick="toggleSection('ga_aplicaciones', this)" aria-expanded="false" aria-controls="ga_aplicaciones">
      Aplicaciones Pr√°cticas
    </button>
    <div id="ga_aplicaciones" class="content-panel">
      <p>Los algoritmos gen√©ticos tienen una gran diversidad de aplicaciones reales en ingenier√≠a, inform√°tica, log√≠stica y m√°s:</p>
      <h3>1. Optimizaci√≥n Combinatoria</h3>
      <ul>
        <li>Problema del Viajero (TSP)</li>
        <li>Coloraci√≥n de grafos</li>
        <li>Asignaci√≥n de tareas</li>
        <li>Problemas de rutas de veh√≠culos (VRP)</li>
      </ul>
      <h3>2. Ingenier√≠a y Dise√±o</h3>
      <ul>
        <li>Optimizaci√≥n de estructuras mec√°nicas.</li>
        <li>Dise√±o de circuitos el√©ctricos.</li>
        <li>Generaci√≥n de dise√±os CAD.</li>
      </ul>
      <h3>3. Machine Learning y Data Science</h3>
      <ul>
        <li>Selecci√≥n de atributos (feature selection).</li>
        <li>Optimizaci√≥n de hiperpar√°metros.</li>
        <li>Aprendizaje de reglas.</li>
      </ul>
      <h3>4. Rob√≥tica y Control</h3>
      <ul>
        <li>Planificaci√≥n de trayectorias.</li>
        <li>Controladores adaptativos.</li>
      </ul>
      <h3>5. Finanzas</h3>
      <ul>
        <li>Optimizaci√≥n de carteras de inversi√≥n.</li>
        <li>Trading algor√≠tmico basado en reglas evolucionadas.</li>
      </ul>
      <h3>6. Bioinform√°tica</h3>
      <ul>
        <li>Alineamiento de secuencias.</li>
        <li>Modelado de prote√≠nas.</li>
        <li>Evoluci√≥n de redes g√©nicas.</li>
      </ul>
    </div>

    <!-- Secci√≥n: Ejemplo en Grafos: Coloraci√≥n de Grafos -->
    <button class="section-toggle-button" onclick="toggleSection('ga_ejemplo_grafos', this)" aria-expanded="false" aria-controls="ga_ejemplo_grafos">
      Ejemplo en Grafos: Coloraci√≥n de Grafos
    </button>
    <div id="ga_ejemplo_grafos" class="content-panel">
      <p>El problema de la coloraci√≥n de grafos consiste en asignar colores a los v√©rtices de un grafo tal que dos v√©rtices adyacentes no tengan el mismo color, minimizando el n√∫mero total de colores usados (n√∫mero crom√°tico).</p>
      <p><strong>¬øC√≥mo aplica un algoritmo gen√©tico aqu√≠?</strong></p>
      <ul>
        <li><strong>Codificaci√≥n:</strong> cada cromosoma es un vector donde cada entrada representa el color de un nodo.</li>
        <li><strong>Fitness:</strong> penaliza conflictos (adyacentes con mismo color) y favorece menos colores.</li>
        <li><strong>Operadores:</strong> se definen cruces entre vectores de color y mutaciones aleatorias.</li>
      </ul>
      <p>Esto permite resolver de forma aproximada este problema NP-hard, donde m√©todos exactos se vuelven costosos en grafos grandes.</p>
    </div>

    <!-- Secci√≥n: Ventajas y Desventajas -->
    <button class="section-toggle-button" onclick="toggleSection('ga_ventajas_desventajas', this)" aria-expanded="false" aria-controls="ga_ventajas_desventajas">
      Ventajas y Desventajas
    </button>
    <div id="ga_ventajas_desventajas" class="content-panel">
      <table>
        <caption>Comparativa de Algoritmos Gen√©ticos</caption>
        <thead>
          <tr>
            <th>Ventajas</th>
            <th>Desventajas</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>Alta capacidad de exploraci√≥n</td>
            <td>Puede ser lento para converger</td>
          </tr>
          <tr>
            <td>Robusto ante m√∫ltiples √≥ptimos locales</td>
            <td>Necesita ajuste fino de par√°metros</td>
          </tr>
          <tr>
            <td>Adaptable a distintos tipos de problemas</td>
            <td>Sin garant√≠as de encontrar el √≥ptimo real</td>
          </tr>
        </tbody>
      </table>
    </div>

    <!-- Secci√≥n: Conclusi√≥n -->
    <button class="section-toggle-button" onclick="toggleSection('ga_conclusion', this)" aria-expanded="false" aria-controls="ga_conclusion">
      Conclusi√≥n
    </button>
    <div id="ga_conclusion" class="content-panel">
      <p>Los algoritmos gen√©ticos son herramientas poderosas dentro de la computaci√≥n evolutiva. Su capacidad para manejar espacios de b√∫squeda complejos, discretos o continuos, y su aplicabilidad a problemas reales de gran escala, los convierten en una pieza clave en la caja de herramientas del cient√≠fico computacional, ingeniero o matem√°tico aplicado.</p>
      <p>Su implementaci√≥n puede variar dependiendo del problema, pero los principios de selecci√≥n, cruza y mutaci√≥n permanecen como el n√∫cleo del proceso de evoluci√≥n artificial.</p>
    </div>

  </div> <!-- Fin de .container -->

  <script>
    // Funci√≥n para cambiar entre modo claro y oscuro
    function toggleTheme() {
      document.body.classList.toggle("dark-mode");
      let themeButton = document.getElementById('theme-toggle-btn');
      let isDarkMode = document.body.classList.contains("dark-mode");
      localStorage.setItem("theme", isDarkMode ? "dark" : "light");
      if (themeButton) {
          themeButton.textContent = isDarkMode ? "Modo Claro" : "Modo Oscuro";
      }
    }

    // Funci√≥n para mostrar/ocultar paneles de contenido
    function toggleSection(id, buttonElement) {
      let panel = document.getElementById(id);
      if (panel && buttonElement) {
          panel.classList.toggle('is-visible');
          let isVisible = panel.classList.contains('is-visible');
          buttonElement.setAttribute('aria-expanded', isVisible);
          buttonElement.classList.toggle('is-expanded', isVisible);
      }
    }

    // Funci√≥n que se ejecuta cuando la p√°gina carga
    window.onload = function() {
      let themeButton = document.getElementById('theme-toggle-btn');
      const savedTheme = localStorage.getItem("theme");

      if (savedTheme === "dark") {
        document.body.classList.add("dark-mode");
        if (themeButton) {
            themeButton.textContent = "Modo Claro";
        }
      } else {
        document.body.classList.remove("dark-mode");
        if (themeButton) {
            themeButton.textContent = "Modo Oscuro";
        }
      }

       document.querySelectorAll('.content-panel').forEach(panel => {
         panel.classList.remove('is-visible');
       });
       document.querySelectorAll('.section-toggle-button').forEach(button => {
          button.setAttribute('aria-expanded', 'false');
          button.classList.remove('is-expanded');
       });
    }
  </script>
</body>
</html>
"""

# Mostrar el HTML en la salida de la celda
display(HTML(html_content))

import numpy as np
import matplotlib.pyplot as plt
import math

# Funci√≥n objetivo
def objective_function(x: float) -> float:
    return x * math.sin(10 * math.pi * x) + 1.0

# Valores en el dominio [0, 1]
x_vals = np.linspace(0, 1, 1000)
y_vals = [objective_function(x) for x in x_vals]

# Detectar m√°ximos locales
local_maxima = []
for i in range(1, len(y_vals) - 1):
    if y_vals[i] > y_vals[i - 1] and y_vals[i] > y_vals[i + 1]:
        local_maxima.append((x_vals[i], y_vals[i]))

# Encontrar el √≥ptimo global
if local_maxima:
    global_max = max(local_maxima, key=lambda t: t[1])
    # Excluir el global de los locales para no marcar dos veces
    local_maxima_sin_global = [p for p in local_maxima if p != global_max]
else:
    global_max = (x_vals[np.argmax(y_vals)], max(y_vals))
    local_maxima_sin_global = []

# Graficar
plt.figure(figsize=(10, 6))
plt.plot(x_vals, y_vals, label=r'$f(x) = x \cdot \sin(10\pi x) + 1$', linewidth=2)
# Marcar √≥ptimo global
plt.plot(global_max[0], global_max[1], 'ro', markersize=10, label=f'√ìptimo global: x={global_max[0]:.4f}, f(x)={global_max[1]:.4f}')
# Marcar √≥ptimos locales
if local_maxima_sin_global:
    lx, ly = zip(*local_maxima_sin_global)
    plt.plot(lx, ly, 'o', color='orange', markersize=8, label='√ìptimos locales')
plt.title("√ìptimos local y global de $f(x)$", fontsize=14)
plt.xlabel("x")
plt.ylabel("f(x)")
plt.grid(True, alpha=0.3)
plt.legend()
plt.tight_layout()
plt.show()

"""o,0,1  continua  conjunto de soluciones  o espacio de solucion  20 25 2 elevado 20

1,1, 0  1,0, 1 1.1.1
"""

import numpy as np
import matplotlib.pyplot as plt
from scipy.optimize import minimize, differential_evolution
import random
from typing import List, Tuple
import math

class MultimodalOptimizationComparison:
    def __init__(self):
        self.function_name = "f(x) = x‚ãÖsin(10œÄx) + 1.0"

    def objective_function(self, x):
        """Funci√≥n objetivo multimodal"""
        if isinstance(x, (list, np.ndarray)):
            x = x[0] if len(x) > 0 else x
        return x * math.sin(10 * math.pi * x) + 1.0

    def objective_function_minimize(self, x):
        """Versi√≥n para minimizaci√≥n (negativa)"""
        return -self.objective_function(x)

    def gradient_function(self, x):
        """Gradiente anal√≠tico de f(x)"""
        if isinstance(x, (list, np.ndarray)):
            x = x[0] if len(x) > 0 else x
        # df/dx = sin(10œÄx) + x‚ãÖ10œÄ‚ãÖcos(10œÄx)
        return math.sin(10 * math.pi * x) + x * 10 * math.pi * math.cos(10 * math.pi * x)

    def analyze_function_landscape(self):
        """Analiza el paisaje de la funci√≥n para entender su complejidad"""
        x = np.linspace(0, 1, 2000)
        y = [self.objective_function(xi) for xi in x]

        # Encontrar m√°ximos locales
        local_maxima = []
        for i in range(1, len(y)-1):
            if y[i] > y[i-1] and y[i] > y[i+1] and y[i] > 1.5:  # Solo picos significativos
                local_maxima.append((x[i], y[i]))

        # Ordenar por valor de funci√≥n
        local_maxima.sort(key=lambda point: point[1], reverse=True)

        print("=== AN√ÅLISIS DEL PAISAJE DE LA FUNCI√ìN ===")
        print(f"Funci√≥n: {self.function_name}")
        print(f"Dominio: x ‚àà [0,1]")
        print(f"N√∫mero de m√°ximos locales significativos: {len(local_maxima)}")
        print(f"M√°ximo global: x = {local_maxima[0][0]:.6f}, f(x) = {local_maxima[0][1]:.6f}")
        print("\nTop 5 m√°ximos locales:")
        for i, (xi, fi) in enumerate(local_maxima[:5]):
            print(f"  {i+1}. x = {xi:.6f}, f(x) = {fi:.6f}")
        print()

        return x, y, local_maxima

    def test_gradient_methods(self, num_starts=15):
        """Prueba m√©todos basados en gradiente desde m√∫ltiples puntos iniciales"""
        print("=== M√âTODOS BASADOS EN GRADIENTE ===")

        # Puntos iniciales distribuidos uniformemente
        start_points = np.linspace(0.05, 0.95, num_starts)

        results_bfgs = []
        results_lbfgs = []
        results_cg = []

        print("Probando desde m√∫ltiples puntos iniciales...")

        for i, x0 in enumerate(start_points):
            print(f"\rPunto inicial {i+1}/{num_starts}: x0 = {x0:.3f}", end="")

            # BFGS
            try:
                res_bfgs = minimize(self.objective_function_minimize, [x0],
                                 method='BFGS',
                                 options={'gtol': 1e-8, 'maxiter': 1000})
                if res_bfgs.success and 0 <= res_bfgs.x[0] <= 1:
                    results_bfgs.append((res_bfgs.x[0], -res_bfgs.fun))
            except:
                pass

            # L-BFGS-B (con l√≠mites)
            try:
                res_lbfgs = minimize(self.objective_function_minimize, [x0],
                                   method='L-BFGS-B',
                                   bounds=[(0, 1)],
                                   options={'gtol': 1e-8, 'maxiter': 1000})
                if res_lbfgs.success:
                    results_lbfgs.append((res_lbfgs.x[0], -res_lbfgs.fun))
            except:
                pass

            # Conjugate Gradient
            try:
                res_cg = minimize(self.objective_function_minimize, [x0],
                                method='CG',
                                options={'gtol': 1e-8, 'maxiter': 1000})
                if res_cg.success and 0 <= res_cg.x[0] <= 1:
                    results_cg.append((res_cg.x[0], -res_cg.fun))
            except:
                pass

        print("\n")

        # Analizar resultados
        def analyze_results(results, method_name):
            if not results:
                print(f"{method_name}: No se encontraron soluciones v√°lidas")
                return None

            # Eliminar duplicados (misma soluci√≥n desde diferentes puntos)
            unique_results = []
            for x, f in results:
                is_duplicate = False
                for ux, uf in unique_results:
                    if abs(x - ux) < 1e-4:  # Mismo punto
                        is_duplicate = True
                        break
                if not is_duplicate:
                    unique_results.append((x, f))

            unique_results.sort(key=lambda point: point[1], reverse=True)
            best_x, best_f = unique_results[0]

            print(f"\n{method_name}:")
            print(f"  Soluciones √∫nicas encontradas: {len(unique_results)}")
            print(f"  Mejor soluci√≥n: x = {best_x:.6f}, f(x) = {best_f:.6f}")
            print(f"  Tasa de √©xito: {len(results)}/{num_starts} = {len(results)/num_starts*100:.1f}%")

            if len(unique_results) > 1:
                print("  Top 3 soluciones:")
                for i, (x, f) in enumerate(unique_results[:3]):
                    print(f"    {i+1}. x = {x:.6f}, f(x) = {f:.6f}")

            return unique_results

        bfgs_solutions = analyze_results(results_bfgs, "BFGS")
        lbfgs_solutions = analyze_results(results_lbfgs, "L-BFGS-B")
        cg_solutions = analyze_results(results_cg, "Conjugate Gradient")

        return {
            'bfgs': bfgs_solutions,
            'lbfgs': lbfgs_solutions,
            'cg': cg_solutions,
            'start_points': start_points
        }

    def run_genetic_algorithm(self):
        """Ejecuta algoritmo gen√©tico simplificado"""
        print("\n=== ALGORITMO GEN√âTICO ===")

        # Par√°metros del AG
        population_size = 100
        generations = 300
        mutation_rate = 0.02
        crossover_rate = 0.8

        # Inicializar poblaci√≥n
        population = [random.uniform(0, 1) for _ in range(population_size)]
        best_history = []

        for gen in range(generations):
            # Evaluar fitness
            fitness = [self.objective_function(x) for x in population]

            # Encontrar mejor
            best_idx = fitness.index(max(fitness))
            best_x = population[best_idx]
            best_f = fitness[best_idx]
            best_history.append((best_x, best_f))

            if gen % 50 == 0:
                print(f"  Generaci√≥n {gen}: x = {best_x:.6f}, f(x) = {best_f:.6f}")

            # Selecci√≥n por torneo y reproducci√≥n
            new_population = []

            # Elitismo: mantener 10% mejores
            elite_size = population_size // 10
            elite_indices = sorted(range(len(fitness)), key=lambda i: fitness[i], reverse=True)[:elite_size]
            new_population.extend([population[i] for i in elite_indices])

            # Generar resto
            while len(new_population) < population_size:
                # Selecci√≥n por torneo
                parent1 = self.tournament_selection(population, fitness)
                parent2 = self.tournament_selection(population, fitness)

                # Cruce
                if random.random() < crossover_rate:
                    alpha = random.uniform(0, 1)
                    child1 = alpha * parent1 + (1 - alpha) * parent2
                    child2 = (1 - alpha) * parent1 + alpha * parent2
                else:
                    child1, child2 = parent1, parent2

                # Mutaci√≥n
                if random.random() < mutation_rate:
                    child1 += random.gauss(0, 0.05)
                    child1 = max(0, min(1, child1))  # Mantener en [0,1]

                if random.random() < mutation_rate:
                    child2 += random.gauss(0, 0.05)
                    child2 = max(0, min(1, child2))  # Mantener en [0,1]

                new_population.extend([child1, child2])

            population = new_population[:population_size]

        # Resultado final
        final_fitness = [self.objective_function(x) for x in population]
        best_idx = final_fitness.index(max(final_fitness))
        ga_best_x = population[best_idx]
        ga_best_f = final_fitness[best_idx]

        print(f"\nAlgoritmo Gen√©tico - Resultado final:")
        print(f"  Mejor soluci√≥n: x = {ga_best_x:.6f}, f(x) = {ga_best_f:.6f}")

        return ga_best_x, ga_best_f, best_history

    def tournament_selection(self, population, fitness, tournament_size=5):
        """Selecci√≥n por torneo"""
        tournament_indices = random.sample(range(len(population)), tournament_size)
        tournament_fitness = [fitness[i] for i in tournament_indices]
        winner_idx = tournament_indices[tournament_fitness.index(max(tournament_fitness))]
        return population[winner_idx]

    def test_differential_evolution(self):
        """Prueba evoluci√≥n diferencial (scipy)"""
        print("\n=== EVOLUCI√ìN DIFERENCIAL ===")

        result = differential_evolution(self.objective_function_minimize,
                                      bounds=[(0, 1)],
                                      maxiter=300,
                                      popsize=15,
                                      seed=42)

        de_best_x = result.x[0]
        de_best_f = -result.fun

        print(f"Evoluci√≥n Diferencial:")
        print(f"  Mejor soluci√≥n: x = {de_best_x:.6f}, f(x) = {de_best_f:.6f}")
        print(f"  Convergi√≥: {'S√≠' if result.success else 'No'}")
        print(f"  Evaluaciones de funci√≥n: {result.nfev}")

        return de_best_x, de_best_f

    def visualize_comparison(self, gradient_results, ga_result, de_result, landscape_data):
        """Visualiza la comparaci√≥n de m√©todos"""
        x_range, y_range, local_maxima = landscape_data
        ga_x, ga_f, ga_history = ga_result
        de_x, de_f = de_result

        fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2, figsize=(16, 12))

        # 1. Paisaje de la funci√≥n con todas las soluciones
        ax1.plot(x_range, y_range, 'b-', linewidth=2, label='f(x) = x‚ãÖsin(10œÄx) + 1')

        # Marcar m√°ximos locales te√≥ricos
        local_x = [x for x, _ in local_maxima[:10]]  # Top 10
        local_y = [y for _, y in local_maxima[:10]]
        ax1.scatter(local_x, local_y, c='lightgray', s=50, alpha=0.7, label='M√°ximos locales')

        # Soluciones de m√©todos de gradiente
        colors = ['red', 'orange', 'purple']
        methods = ['bfgs', 'lbfgs', 'cg']
        method_names = ['BFGS', 'L-BFGS-B', 'Conj. Gradient']

        for i, method in enumerate(methods):
            if gradient_results[method]:
                solutions_x = [x for x, _ in gradient_results[method]]
                solutions_y = [y for _, y in gradient_results[method]]
                ax1.scatter(solutions_x, solutions_y, c=colors[i], s=80,
                           marker='s', alpha=0.8, label=f'{method_names[i]} solutions')

        # Mejor soluci√≥n del AG
        ax1.scatter([ga_x], [ga_f], c='green', s=150, marker='*',
                   label=f'AG: x={ga_x:.3f}', edgecolors='black', linewidth=2)

        # Mejor soluci√≥n de DE
        ax1.scatter([de_x], [de_f], c='cyan', s=120, marker='D',
                   label=f'DE: x={de_x:.3f}', edgecolors='black', linewidth=1)

        ax1.set_xlabel('x')
        ax1.set_ylabel('f(x)')
        ax1.set_title('Comparaci√≥n de M√©todos de Optimizaci√≥n')
        ax1.legend()
        ax1.grid(True, alpha=0.3)

        # 2. Convergencia del algoritmo gen√©tico
        generations = range(len(ga_history))
        ga_fitness = [f for _, f in ga_history]

        ax2.plot(generations, ga_fitness, 'g-', linewidth=2)
        ax2.set_xlabel('Generaci√≥n')
        ax2.set_ylabel('Mejor Fitness')
        ax2.set_title('Convergencia del Algoritmo Gen√©tico')
        ax2.grid(True, alpha=0.3)

        # 3. Distribuci√≥n de soluciones por m√©todo
        method_performance = {}
        for i, method in enumerate(methods):
            if gradient_results[method]:
                best_f = max([f for _, f in gradient_results[method]])
                method_performance[method_names[i]] = best_f

        method_performance['Algoritmo Gen√©tico'] = ga_f
        method_performance['Evoluci√≥n Diferencial'] = de_f

        methods_list = list(method_performance.keys())
        performance_list = list(method_performance.values())

        bars = ax3.bar(methods_list, performance_list,
                      color=['red', 'orange', 'purple', 'green', 'cyan'])
        ax3.set_ylabel('Mejor Fitness Encontrado')
        ax3.set_title('Comparaci√≥n de Rendimiento por M√©todo')
        ax3.tick_params(axis='x', rotation=45)

        # A√±adir valores en las barras
        for bar, value in zip(bars, performance_list):
            ax3.text(bar.get_x() + bar.get_width()/2, bar.get_height() + 0.05,
                    f'{value:.3f}', ha='center', va='bottom')

        ax3.grid(True, alpha=0.3, axis='y')

        # 4. An√°lisis de diversidad de soluciones
        ax4.set_title('An√°lisis de Exploraci√≥n del Espacio')

        # Puntos iniciales vs soluciones finales para m√©todos de gradiente
        start_points = gradient_results['start_points']
        ax4.scatter(start_points, [1.0] * len(start_points),
                   c='gray', alpha=0.5, s=30, label='Puntos iniciales')

        # Soluciones encontradas
        for i, method in enumerate(methods):
            if gradient_results[method]:
                solutions_x = [x for x, _ in gradient_results[method]]
                y_offset = 1.5 + i * 0.3
                ax4.scatter(solutions_x, [y_offset] * len(solutions_x),
                           c=colors[i], s=60, alpha=0.8, label=f'{method_names[i]}')

        # AG y DE
        ax4.scatter([ga_x], [3.0], c='green', s=100, marker='*', label='AG')
        ax4.scatter([de_x], [3.2], c='cyan', s=80, marker='D', label='DE')

        ax4.set_xlabel('x')
        ax4.set_ylabel('M√©todo')
        ax4.set_ylim(0.5, 3.5)
        ax4.legend()
        ax4.grid(True, alpha=0.3)

        plt.tight_layout()
        plt.show()

    def run_complete_comparison(self):
        """Ejecuta la comparaci√≥n completa"""
        print("üîç COMPARACI√ìN DE M√âTODOS DE OPTIMIZACI√ìN")
        print("=" * 60)

        # 1. Analizar paisaje
        landscape_data = self.analyze_function_landscape()

        # 2. Probar m√©todos de gradiente
        gradient_results = self.test_gradient_methods()

        # 3. Ejecutar algoritmo gen√©tico
        ga_result = self.run_genetic_algorithm()

        # 4. Probar evoluci√≥n diferencial
        de_result = self.test_differential_evolution()

        # 5. Resumen comparativo
        print("\n" + "=" * 60)
        print("üìä RESUMEN COMPARATIVO")
        print("=" * 60)

        # Obtener m√°ximo te√≥rico
        _, _, local_maxima = landscape_data
        theoretical_max = local_maxima[0][1]

        def print_method_summary(name, best_f, comment=""):
            error = abs(theoretical_max - best_f)
            percentage = (best_f / theoretical_max) * 100
            print(f"{name:20} | f(x) = {best_f:.6f} | Error: {error:.6f} | {percentage:.2f}% del √≥ptimo {comment}")

        # M√©todos de gradiente
        for method, name in [('bfgs', 'BFGS'), ('lbfgs', 'L-BFGS-B'), ('cg', 'Conj. Gradient')]:
            if gradient_results[method]:
                best_f = max([f for _, f in gradient_results[method]])
                num_solutions = len(gradient_results[method])
                print_method_summary(name, best_f, f"({num_solutions} soluciones)")
            else:
                print(f"{name:20} | No encontr√≥ soluciones v√°lidas")

        # M√©todos evolutivos
        ga_x, ga_f, _ = ga_result
        de_x, de_f = de_result
        print_method_summary("Algoritmo Gen√©tico", ga_f, "‚úì Robusto")
        print_method_summary("Evoluci√≥n Diferencial", de_f, "‚úì Robusto")

        print(f"\nM√°ximo te√≥rico: {theoretical_max:.6f}")

        # 6. Visualizar
        self.visualize_comparison(gradient_results, ga_result, de_result, landscape_data)

        # 7. Conclusiones
        print("\n" + "=" * 60)
        print("üìù CONCLUSIONES")
        print("=" * 60)
        print("üî¥ M√âTODOS DE GRADIENTE:")
        print("   ‚Ä¢ Se 'atascan' en m√°ximos locales")
        print("   ‚Ä¢ Dependen fuertemente del punto inicial")
        print("   ‚Ä¢ R√°pidos pero no garantizan el √≥ptimo global")
        print("   ‚Ä¢ √ötiles para refinamiento local")

        print("\nüü¢ M√âTODOS EVOLUTIVOS:")
        print("   ‚Ä¢ Exploran todo el espacio de b√∫squeda")
        print("   ‚Ä¢ Menos propensos a m√°ximos locales")
        print("   ‚Ä¢ M√°s lentos pero m√°s robustos")
        print("   ‚Ä¢ Ideales para funciones multimodales")

        print(f"\nüèÜ GANADOR: {'Algoritmo Gen√©tico' if ga_f > de_f else 'Evoluci√≥n Diferencial'}")
        print(f"   Encontr√≥ el {max(ga_f, de_f)/theoretical_max*100:.1f}% del √≥ptimo te√≥rico")

def main():
    """Funci√≥n principal"""
    # Configurar semillas para reproducibilidad
    random.seed(42)
    np.random.seed(42)

    # Crear y ejecutar comparaci√≥n
    comparator = MultimodalOptimizationComparison()
    comparator.run_complete_comparison()

if __name__ == "__main__":
    main()

import numpy as np
import matplotlib.pyplot as plt
import random
from typing import List, Tuple
import math

class GeneticAlgorithm:
    def __init__(self,
                 population_size: int = 100,
                 chromosome_length: int = 20,
                 crossover_rate: float = 0.8,
                 mutation_rate: float = 0.01,
                 elitism_rate: float = 0.1,
                 tournament_size: int = 5):
        self.population_size = population_size
        self.chromosome_length = chromosome_length
        self.crossover_rate = crossover_rate
        self.mutation_rate = mutation_rate
        self.elitism_rate = elitism_rate
        self.tournament_size = tournament_size
        self.elite_size = int(population_size * elitism_rate)
        self.best_fitness_history = []
        self.avg_fitness_history = []
        self.best_individual_history = []

    def objective_function(self, x: float) -> float:
        return x * math.sin(10 * math.pi * x) + 1.0

    def binary_to_decimal(self, binary_chromosome: List[int]) -> float:
        decimal_value = 0
        for i, bit in enumerate(binary_chromosome):
            decimal_value += bit * (2 ** (-(i + 1)))
        return decimal_value

    def decimal_to_binary(self, decimal_value: float) -> List[int]:
        binary = []
        remaining = decimal_value
        for i in range(self.chromosome_length):
            bit_value = 2 ** (-(i + 1))
            if remaining >= bit_value:
                binary.append(1)
                remaining -= bit_value
            else:
                binary.append(0)
        return binary

    def initialize_population(self) -> List[List[int]]:
        population = []
        for _ in range(self.population_size):
            chromosome = [random.randint(0, 1) for _ in range(self.chromosome_length)]
            population.append(chromosome)
        return population

    def evaluate_fitness(self, population: List[List[int]]) -> List[float]:
        fitness_values = []
        for chromosome in population:
            x = self.binary_to_decimal(chromosome)
            fitness = self.objective_function(x)
            fitness_values.append(fitness)
        return fitness_values

    def tournament_selection(self, population: List[List[int]], fitness_values: List[float]) -> List[int]:
        tournament_indices = random.sample(range(len(population)), self.tournament_size)
        tournament_fitness = [fitness_values[i] for i in tournament_indices]
        winner_index = tournament_indices[tournament_fitness.index(max(tournament_fitness))]
        return population[winner_index]

    def roulette_wheel_selection(self, population: List[List[int]], fitness_values: List[float]) -> List[int]:
        min_fitness = min(fitness_values)
        adjusted_fitness = [f - min_fitness + 0.1 for f in fitness_values]
        total_fitness = sum(adjusted_fitness)
        pick = random.uniform(0, total_fitness)
        current = 0
        for i, fitness in enumerate(adjusted_fitness):
            current += fitness
            if current >= pick:
                return population[i]
        return population[-1]

    def single_point_crossover(self, parent1: List[int], parent2: List[int]) -> Tuple[List[int], List[int]]:
        if random.random() > self.crossover_rate:
            return parent1.copy(), parent2.copy()
        crossover_point = random.randint(1, self.chromosome_length - 1)
        offspring1 = parent1[:crossover_point] + parent2[crossover_point:]
        offspring2 = parent2[:crossover_point] + parent1[crossover_point:]
        return offspring1, offspring2

    def uniform_crossover(self, parent1: List[int], parent2: List[int]) -> Tuple[List[int], List[int]]:
        if random.random() > self.crossover_rate:
            return parent1.copy(), parent2.copy()
        offspring1, offspring2 = [], []
        for i in range(self.chromosome_length):
            if random.random() < 0.5:
                offspring1.append(parent1[i])
                offspring2.append(parent2[i])
            else:
                offspring1.append(parent2[i])
                offspring2.append(parent1[i])
        return offspring1, offspring2

    def bit_flip_mutation(self, chromosome: List[int]) -> List[int]:
        mutated = chromosome.copy()
        for i in range(self.chromosome_length):
            if random.random() < self.mutation_rate:
                mutated[i] = 1 - mutated[i]
        return mutated

    def adaptive_mutation(self, chromosome: List[int], generation: int) -> List[int]:
        adaptive_rate = self.mutation_rate * (1 - generation / 1000)
        adaptive_rate = max(adaptive_rate, 0.001)
        mutated = chromosome.copy()
        for i in range(self.chromosome_length):
            if random.random() < adaptive_rate:
                mutated[i] = 1 - mutated[i]
        return mutated

    def elitism_selection(self, population: List[List[int]], fitness_values: List[float]) -> List[List[int]]:
        paired = list(zip(population, fitness_values))
        paired.sort(key=lambda x: x[1], reverse=True)
        elite = [individual for individual, _ in paired[:self.elite_size]]
        return elite

    def optimize(self, generations: int = 500, verbose: bool = True) -> Tuple[float, float]:
        population = self.initialize_population()
        for generation in range(generations):
            fitness_values = self.evaluate_fitness(population)
            best_fitness = max(fitness_values)
            avg_fitness = sum(fitness_values) / len(fitness_values)
            best_idx = fitness_values.index(best_fitness)
            best_x = self.binary_to_decimal(population[best_idx])
            self.best_fitness_history.append(best_fitness)
            self.avg_fitness_history.append(avg_fitness)
            self.best_individual_history.append((best_x, best_fitness))
            if verbose and generation % 50 == 0:
                print(f"Generaci√≥n {generation}: Mejor fitness = {best_fitness:.6f}, x = {best_x:.6f}")
            new_population = []
            elite = self.elitism_selection(population, fitness_values)
            new_population.extend(elite)
            while len(new_population) < self.population_size:
                parent1 = self.tournament_selection(population, fitness_values)
                parent2 = self.tournament_selection(population, fitness_values)
                offspring1, offspring2 = self.single_point_crossover(parent1, parent2)
                offspring1 = self.bit_flip_mutation(offspring1)
                offspring2 = self.bit_flip_mutation(offspring2)
                new_population.extend([offspring1, offspring2])
            population = new_population[:self.population_size]
        final_fitness = self.evaluate_fitness(population)
        best_final_fitness = max(final_fitness)
        best_final_idx = final_fitness.index(best_final_fitness)
        best_final_x = self.binary_to_decimal(population[best_final_idx])
        return best_final_x, best_final_fitness

    def plot_results(self):
        fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2, figsize=(15, 10))
        ax1.plot(self.best_fitness_history, 'r-', label='Mejor fitness', linewidth=2)
        ax1.plot(self.avg_fitness_history, 'b--', label='Fitness promedio', alpha=0.7)
        ax1.set_xlabel('Generaci√≥n')
        ax1.set_ylabel('Fitness')
        ax1.set_title('Evoluci√≥n del Fitness')
        ax1.legend()
        ax1.grid(True, alpha=0.3)
        x_range = np.linspace(0, 1, 1000)
        y_range = [self.objective_function(x) for x in x_range]
        ax2.plot(x_range, y_range, 'b-', linewidth=2, label='f(x) = x¬∑sin(10œÄx) + 1')
        best_x, best_fitness = self.best_individual_history[-1]
        ax2.plot(best_x, best_fitness, 'ro', markersize=10,
                label=f'Mejor soluci√≥n: x={best_x:.4f}, f(x)={best_fitness:.4f}')
        ax2.set_xlabel('x')
        ax2.set_ylabel('f(x)')
        ax2.set_title('Funci√≥n Objetivo y Mejor Soluci√≥n')
        ax2.legend()
        ax2.grid(True, alpha=0.3)
        sample_points = [x for x, _ in self.best_individual_history[::10]]
        sample_fitness = [f for _, f in self.best_individual_history[::10]]
        ax3.scatter(sample_points, sample_fitness, alpha=0.6, s=30)
        ax3.plot(x_range, y_range, 'b-', alpha=0.3)
        ax3.set_xlabel('x')
        ax3.set_ylabel('f(x)')
        ax3.set_title('Exploraci√≥n del Espacio de B√∫squeda')
        ax3.grid(True, alpha=0.3)
        best_x_history = [x for x, _ in self.best_individual_history]
        ax4.plot(best_x_history, 'g-', linewidth=2)
        ax4.set_xlabel('Generaci√≥n')
        ax4.set_ylabel('Mejor x')
        ax4.set_title('Convergencia de la Variable x')
        ax4.grid(True, alpha=0.3)
        plt.tight_layout()
        plt.show()

def main():
    print("=== ALGORITMO GEN√âTICO PARA OPTIMIZACI√ìN ===")
    print("Funci√≥n: f(x) = x‚ãÖsin(10œÄx) + 1.0")
    print("Dominio: x ‚àà [0,1]")
    print("Objetivo: Maximizaci√≥n\n")
    ga = GeneticAlgorithm(
        population_size=150,
        chromosome_length=25,
        crossover_rate=0.85,
        mutation_rate=0.015,
        elitism_rate=0.15,
        tournament_size=7
    )
    print("Iniciando optimizaci√≥n...")
    best_x, best_fitness = ga.optimize(generations=800, verbose=True)
    print("\n" + "="*50)
    print("RESULTADOS FINALES:")
    print(f"Mejor x encontrado: {best_x:.8f}")
    print(f"Mejor fitness: {best_fitness:.8f}")

    # C√°lculo del √≥ptimo te√≥rico real
    x_test = np.linspace(0, 1, 100000)
    f_test = [ga.objective_function(x) for x in x_test]
    max_f = np.max(f_test)
    max_x = x_test[np.argmax(f_test)]
    print(f"Valor te√≥rico m√°ximo ‚âà {max_f:.8f} en x ‚âà {max_x:.8f}")

    final_10_best = ga.best_fitness_history[-10:]
    convergence = max(final_10_best) - min(final_10_best)
    print(f"Convergencia (variaci√≥n √∫ltimas 10 gen): {convergence:.8f}")

    print("\nAn√°lisis de m√°ximos locales encontrados:")
    # Detectar picos locales en funci√≥n objetivo
    local_maxima = []
    for i in range(1, len(f_test)-1):
        if f_test[i] > f_test[i-1] and f_test[i] > f_test[i+1]:
            local_maxima.append((x_test[i], f_test[i]))
    local_maxima.sort(key=lambda x: x[1], reverse=True)
    print("Top 5 m√°ximos locales te√≥ricos:")
    for i, (x, f) in enumerate(local_maxima[:5]):
        print(f"  {i+1}. x = {x:.6f}, f(x) = {f:.6f}")
    ga.plot_results()
    return best_x, best_fitness

if __name__ == "__main__":
    random.seed(42)
    np.random.seed(42)
    best_x, best_fitness = main()

import numpy as np
import matplotlib.pyplot as plt
import random
from typing import List, Tuple
import math

class ImprovedGeneticAlgorithm:
    def __init__(self,
                 population_size: int = 200,
                 chromosome_length: int = 30,
                 crossover_rate: float = 0.9,
                 mutation_rate: float = 0.02,
                 elitism_rate: float = 0.05,
                 tournament_size: int = 3,
                 immigration_rate: float = 0.1,
                 diversity_threshold: float = 0.01):
        self.population_size = population_size
        self.chromosome_length = chromosome_length
        self.crossover_rate = crossover_rate
        self.mutation_rate = mutation_rate
        self.elitism_rate = elitism_rate
        self.tournament_size = tournament_size
        self.immigration_rate = immigration_rate
        self.diversity_threshold = diversity_threshold
        self.elite_size = int(population_size * elitism_rate)
        self.immigrant_size = int(population_size * immigration_rate)
        self.best_fitness_history = []
        self.avg_fitness_history = []
        self.diversity_history = []
        self.best_individual_history = []
        self.stagnation_counter = 0
        self.max_stagnation = 50

    def objective_function(self, x: float) -> float:
        return x * math.sin(10 * math.pi * x) + 1.0

    def binary_to_decimal(self, binary_chromosome: List[int]) -> float:
        decimal_value = 0
        for i, bit in enumerate(binary_chromosome):
            decimal_value += bit * (2 ** (-(i + 1)))
        return decimal_value

    def decimal_to_binary(self, decimal_value: float) -> List[int]:
        binary = []
        remaining = decimal_value
        for i in range(self.chromosome_length):
            bit_value = 2 ** (-(i + 1))
            if remaining >= bit_value:
                binary.append(1)
                remaining -= bit_value
            else:
                binary.append(0)
        return binary

    def initialize_population(self) -> List[List[int]]:
        population = []
        for _ in range(int(self.population_size * 0.7)):
            chromosome = [random.randint(0, 1) for _ in range(self.chromosome_length)]
            population.append(chromosome)
        regions = np.linspace(0, 1, int(self.population_size * 0.3))
        for x_seed in regions:
            chromosome = self.decimal_to_binary(x_seed)
            for i in range(len(chromosome)):
                if random.random() < 0.1:
                    chromosome[i] = 1 - chromosome[i]
            population.append(chromosome)
        return population

    def calculate_diversity(self, population: List[List[int]]) -> float:
        if len(population) < 2:
            return 0.0
        total_distance = 0
        comparisons = 0
        for i in range(len(population)):
            for j in range(i + 1, len(population)):
                distance = sum(1 for a, b in zip(population[i], population[j]) if a != b)
                total_distance += distance
                comparisons += 1
        return total_distance / (comparisons * self.chromosome_length) if comparisons > 0 else 0

    def evaluate_fitness(self, population: List[List[int]]) -> List[float]:
        base_fitness = []
        for chromosome in population:
            x = self.binary_to_decimal(chromosome)
            fitness = self.objective_function(x)
            base_fitness.append(fitness)
        shared_fitness = []
        for i, fitness_i in enumerate(base_fitness):
            sharing_sum = 0
            for j, fitness_j in enumerate(base_fitness):
                if i != j:
                    distance = sum(1 for a, b in zip(population[i], population[j]) if a != b)
                    distance_norm = distance / self.chromosome_length
                    if distance_norm < 0.1:
                        sharing_sum += 1 - (distance_norm / 0.1)
            shared_fitness.append(fitness_i / (1 + sharing_sum))
        return shared_fitness

    def tournament_selection(self, population: List[List[int]], fitness_values: List[float]) -> List[int]:
        tournament_indices = random.sample(range(len(population)), self.tournament_size)
        tournament_fitness = [fitness_values[i] for i in tournament_indices]
        winner_index = tournament_indices[tournament_fitness.index(max(tournament_fitness))]
        return population[winner_index]

    def multi_point_crossover(self, parent1: List[int], parent2: List[int]) -> Tuple[List[int], List[int]]:
        if random.random() > self.crossover_rate:
            return parent1.copy(), parent2.copy()
        num_points = random.randint(2, 3)
        crossover_points = sorted(random.sample(range(1, self.chromosome_length), num_points))
        offspring1, offspring2 = [], []
        current_parent = 0
        last_point = 0
        for point in crossover_points + [self.chromosome_length]:
            if current_parent == 0:
                offspring1.extend(parent1[last_point:point])
                offspring2.extend(parent2[last_point:point])
            else:
                offspring1.extend(parent2[last_point:point])
                offspring2.extend(parent1[last_point:point])
            current_parent = 1 - current_parent
            last_point = point
        return offspring1, offspring2

    def adaptive_mutation(self, chromosome: List[int], generation: int, diversity: float) -> List[int]:
        adaptive_rate = self.mutation_rate
        if diversity < self.diversity_threshold:
            adaptive_rate *= 3
        adaptive_rate *= (1 - generation / 2000)
        adaptive_rate = max(adaptive_rate, 0.005)
        mutated = chromosome.copy()
        for i in range(self.chromosome_length):
            if random.random() < adaptive_rate:
                mutated[i] = 1 - mutated[i]
        if random.random() < 0.05:
            jump_length = random.randint(3, 8)
            start_pos = random.randint(0, self.chromosome_length - jump_length)
            for i in range(start_pos, start_pos + jump_length):
                mutated[i] = random.randint(0, 1)
        return mutated

    def immigration(self, population: List[List[int]]) -> List[List[int]]:
        new_population = population.copy()
        fitness_values = [self.objective_function(self.binary_to_decimal(ind)) for ind in population]
        sorted_indices = sorted(range(len(fitness_values)), key=lambda i: fitness_values[i])
        for i in range(self.immigrant_size):
            worst_idx = sorted_indices[i]
            new_individual = [random.randint(0, 1) for _ in range(self.chromosome_length)]
            new_population[worst_idx] = new_individual
        return new_population

    def restart_population(self, population: List[List[int]], keep_best: int = 5) -> List[List[int]]:
        fitness_values = [self.objective_function(self.binary_to_decimal(ind)) for ind in population]
        best_indices = sorted(range(len(fitness_values)), key=lambda i: fitness_values[i], reverse=True)[:keep_best]
        best_individuals = [population[i] for i in best_indices]
        new_population = self.initialize_population()
        for i, best_ind in enumerate(best_individuals):
            new_population[i] = best_ind
        return new_population

    def optimize(self, generations: int = 1000, verbose: bool = True) -> Tuple[float, float]:
        population = self.initialize_population()
        last_best_fitness = -float('inf')
        for generation in range(generations):
            fitness_values = self.evaluate_fitness(population)
            diversity = self.calculate_diversity(population)
            best_fitness = max(fitness_values)
            avg_fitness = sum(fitness_values) / len(fitness_values)
            best_idx = fitness_values.index(best_fitness)
            best_x = self.binary_to_decimal(population[best_idx])
            self.best_fitness_history.append(best_fitness)
            self.avg_fitness_history.append(avg_fitness)
            self.diversity_history.append(diversity)
            self.best_individual_history.append((best_x, best_fitness))
            if abs(best_fitness - last_best_fitness) < 1e-8:
                self.stagnation_counter += 1
            else:
                self.stagnation_counter = 0
            if verbose and generation % 50 == 0:
                print(f"Gen {generation}: Fitness={best_fitness:.6f}, x={best_x:.6f}, Div={diversity:.4f}, Stag={self.stagnation_counter}")
            if self.stagnation_counter >= self.max_stagnation:
                if verbose:
                    print(f"  >> Reiniciando poblaci√≥n en generaci√≥n {generation}")
                population = self.restart_population(population)
                self.stagnation_counter = 0
                continue
            new_population = []
            elite_indices = sorted(range(len(fitness_values)), key=lambda i: fitness_values[i], reverse=True)[:self.elite_size]
            elite = [population[i] for i in elite_indices]
            new_population.extend(elite)
            while len(new_population) < self.population_size:
                parent1 = self.tournament_selection(population, fitness_values)
                parent2 = self.tournament_selection(population, fitness_values)
                offspring1, offspring2 = self.multi_point_crossover(parent1, parent2)
                offspring1 = self.adaptive_mutation(offspring1, generation, diversity)
                offspring2 = self.adaptive_mutation(offspring2, generation, diversity)
                new_population.extend([offspring1, offspring2])
            population = new_population[:self.population_size]
            if generation % 100 == 0 and generation > 0:
                population = self.immigration(population)
            last_best_fitness = best_fitness
        final_fitness = [self.objective_function(self.binary_to_decimal(ind)) for ind in population]
        best_final_fitness = max(final_fitness)
        best_final_idx = final_fitness.index(best_final_fitness)
        best_final_x = self.binary_to_decimal(population[best_final_idx])
        return best_final_x, best_final_fitness

    def plot_results(self, max_x, max_f):
        fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2, figsize=(16, 12))
        ax1_twin = ax1.twinx()
        line1 = ax1.plot(self.best_fitness_history, 'r-', label='Mejor fitness', linewidth=2)
        line2 = ax1.plot(self.avg_fitness_history, 'b--', label='Fitness promedio', alpha=0.7)
        line3 = ax1_twin.plot(self.diversity_history, 'g:', label='Diversidad', alpha=0.8)
        ax1.set_xlabel('Generaci√≥n')
        ax1.set_ylabel('Fitness', color='black')
        ax1_twin.set_ylabel('Diversidad', color='green')
        ax1.set_title('Evoluci√≥n del Fitness y Diversidad')
        lines = line1 + line2 + line3
        labels = [l.get_label() for l in lines]
        ax1.legend(lines, labels, loc='upper left')
        ax1.grid(True, alpha=0.3)
        x_range = np.linspace(0, 1, 2000)
        y_range = [self.objective_function(x) for x in x_range]
        ax2.plot(x_range, y_range, 'b-', linewidth=2, label='f(x) = x¬∑sin(10œÄx) + 1')
        best_x, best_fitness = self.best_individual_history[-1]
        ax2.plot(best_x, best_fitness, 'ro', markersize=12, label=f'Mejor: x={best_x:.6f}, f(x)={best_fitness:.6f}')
        ax2.plot(max_x, max_f, 'go', markersize=10, label=f'√ìptimo te√≥rico: x‚âà{max_x:.6f}, f(x)‚âà{max_f:.6f}')
        ax2.set_xlabel('x')
        ax2.set_ylabel('f(x)')
        ax2.set_title('Funci√≥n Objetivo y Soluciones')
        ax2.legend()
        ax2.grid(True, alpha=0.3)
        exploration_x = [x for x, _ in self.best_individual_history[::20]]
        exploration_f = [f for _, f in self.best_individual_history[::20]]
        ax3.plot(x_range, y_range, 'b-', alpha=0.3, linewidth=1)
        scatter = ax3.scatter(exploration_x, exploration_f, c=range(len(exploration_x)), cmap='viridis', alpha=0.7, s=50)
        plt.colorbar(scatter, ax=ax3, label='Generaci√≥n')
        ax3.set_xlabel('x')
        ax3.set_ylabel('f(x)')
        ax3.set_title('Exploraci√≥n del Espacio (Evoluci√≥n Temporal)')
        ax3.grid(True, alpha=0.3)
        best_x_history = [x for x, _ in self.best_individual_history]
        ax4.plot(best_x_history, 'purple', linewidth=2)
        ax4.axhline(y=max_x, color='red', linestyle='--', alpha=0.7, label=f'√ìptimo te√≥rico x‚âà{max_x:.6f}')
        ax4.set_xlabel('Generaci√≥n')
        ax4.set_ylabel('Mejor x')
        ax4.set_title('Convergencia de la Variable x')
        ax4.legend()
        ax4.grid(True, alpha=0.3)
        plt.tight_layout()
        plt.show()

def main():
    print("=== ALGORITMO GEN√âTICO MEJORADO PARA OPTIMIZACI√ìN GLOBAL ===")
    print("Funci√≥n: f(x) = x‚ãÖsin(10œÄx) + 1.0")
    print("Dominio: x ‚àà [0,1]")
    print("Objetivo: Encontrar el √ìPTIMO GLOBAL\n")
    best_overall_x = 0
    best_overall_fitness = -float('inf')
    best_ga = None
    num_runs = 5
    print(f"Ejecutando {num_runs} corridas independientes...\n")
    for run in range(num_runs):
        print(f"--- CORRIDA {run + 1} ---")
        ga = ImprovedGeneticAlgorithm(
            population_size=300,
            chromosome_length=35,
            crossover_rate=0.9,
            mutation_rate=0.03,
            elitism_rate=0.05,
            tournament_size=3,
            immigration_rate=0.15,
            diversity_threshold=0.02
        )
        best_x, best_fitness = ga.optimize(generations=1500, verbose=False)
        print(f"Resultado: x = {best_x:.8f}, fitness = {best_fitness:.8f}")
        if best_fitness > best_overall_fitness:
            best_overall_fitness = best_fitness
            best_overall_x = best_x
            best_ga = ga
        print()
    print("="*60)
    print("MEJOR RESULTADO DE TODAS LAS CORRIDAS:")
    print(f"Mejor x: {best_overall_x:.8f}")
    print(f"Mejor fitness: {best_overall_fitness:.8f}")
    # C√°lculo del √≥ptimo te√≥rico real en [0,1]
    x_test = np.linspace(0, 1, 100000)
    f_test = [best_ga.objective_function(x) for x in x_test]
    max_f = np.max(f_test)
    max_x = x_test[np.argmax(f_test)]
    print(f"\n√ìptimo te√≥rico (calculado): x ‚âà {max_x:.8f}, f(x) ‚âà {max_f:.8f}")
    # Visualizar el mejor resultado
    if best_ga:
        best_ga.plot_results(max_x, max_f)
    return best_overall_x, best_overall_fitness

if __name__ == "__main__":
    seeds = [42, 123, 456, 789, 999]
    for seed in seeds:
        random.seed(seed)
        np.random.seed(seed)
        print(f"\n{'='*20} SEMILLA {seed} {'='*20}")
        best_x, best_fitness = main()
        # Si encuentra el √≥ptimo global, parar
        if best_fitness > 1.84:
            print("¬°√ìptimo global encontrado! Deteniendo b√∫squeda.")
            break
        print(f"Resultado con semilla {seed}: {best_fitness:.6f}")

# Importar las funciones necesarias de IPython para mostrar HTML
from IPython.core.display import display, HTML

# Definir el contenido HTML, CSS y JavaScript como un string multil√≠nea
html_content = """
<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Formulaci√≥n Matem√°tica de Algoritmos Gen√©ticos</title>
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet">
  <style>
    /* Definici√≥n de variables CSS para temas */
    :root {
      --bg-color: #f9f9f9;
      --text-color: #333;
      --header-color: #2c3e50;
      --header-dark-color: #ecf0f1;
      --accent-color: #3498db; /* Azul cl√°sico para formalidad */
      --accent-dark-color: #85c1e9; /* Azul m√°s claro para modo oscuro */
      --button-bg: #5dade2; /* Azul un poco m√°s claro para botones */
      --button-hover-bg: #2e86c1; /* Azul m√°s oscuro para hover */
      --button-dark-bg: #af7ac5; /* Morado para modo oscuro */
      --button-dark-hover-bg: #8e44ad; /* Morado oscuro para hover */
      --button-text-color: white;
      --theme-button-bg: #8e44ad;
      --theme-button-dark-bg: #f39c12;
      --content-panel-bg: #eaf2f8;
      --content-panel-dark-bg: #28323a; /* Un gris azulado m√°s oscuro */
      --table-border-color: #bdc3c7;
      --table-header-bg: #d6eaf8;
      --table-header-dark-bg: #3c4f62;
      --formula-bg: #ffffff;
      --formula-dark-bg: #34495e;
      --formula-border: #cccccc;
      --formula-dark-border: #556677;
    }

    body {
      font-family: 'Roboto', Arial, sans-serif;
      line-height: 1.8;
      background-color: var(--bg-color);
      color: var(--text-color);
      transition: background-color 0.3s, color 0.3s;
      padding: 20px;
      margin: 0;
    }
    .container {
      max-width: 900px;
      margin: auto;
      padding: 20px;
      position: relative;
      background-color: var(--bg-color);
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    }
    body.dark-mode .container {
        box-shadow: 0 2px 10px rgba(0,0,0,0.3);
    }
    body.dark-mode {
      --bg-color: #212f3c; /* Fondo m√°s oscuro */
      --text-color: #ecf0f1;
      --header-color: var(--header-dark-color);
      --accent-color: var(--accent-dark-color);
      --button-bg: var(--button-dark-bg);
      --button-hover-bg: var(--button-dark-hover-bg);
      --content-panel-bg: var(--content-panel-dark-bg);
      --table-border-color: #566573;
      --table-header-bg: var(--table-header-dark-bg);
      --formula-bg: var(--formula-dark-bg);
      --formula-border: var(--formula-dark-border);
    }

    h1 {
      font-size: 2.2em; /* Ligeramente m√°s peque√±o para tema formal */
      color: var(--header-color);
      text-align: center;
      margin-bottom: 20px;
    }
    h2 {
      font-size: 1.7em;
      color: var(--accent-color);
      margin-top: 25px;
      margin-bottom: 10px;
      padding-bottom: 5px;
      border-bottom: 2px solid var(--accent-color);
      text-align: left;
    }
    h3 {
      font-size: 1.4em;
      color: var(--header-color);
      margin-top: 20px;
      margin-bottom: 10px;
      text-align: left;
    }

    .content-panel {
      display: none;
      margin-top: 0;
      padding: 20px;
      border-left: 4px solid var(--accent-color);
      background-color: var(--content-panel-bg);
      border-radius: 0 0 5px 5px;
    }
    .content-panel.is-visible {
      display: block;
    }

    .section-toggle-button {
      background-color: var(--button-bg);
      color: var(--button-text-color);
      border: none;
      padding: 12px 18px;
      border-radius: 5px;
      cursor: pointer;
      margin-top: 15px;
      transition: background-color 0.3s, border-radius 0.2s;
      width: 100%;
      text-align: left;
      font-size: 1.2em;
      font-weight: 700;
    }
    .section-toggle-button:hover {
      background-color: var(--button-hover-bg);
    }
    .section-toggle-button.is-expanded {
        border-radius: 5px 5px 0 0;
    }

    .theme-toggle {
      background-color: var(--theme-button-bg);
      color: white;
      border: none;
      padding: 8px 12px;
      border-radius: 5px;
      cursor: pointer;
      position: absolute;
      top: 20px;
      right: 20px;
      font-size: 0.9em;
      transition: background-color 0.3s;
      z-index: 10;
    }
    body.dark-mode .theme-toggle {
       background-color: var(--theme-button-dark-bg);
    }

    button:focus, a:focus {
        outline: 2px solid var(--accent-color);
        outline-offset: 2px;
    }
    body.dark-mode button:focus, body.dark-mode a:focus {
         outline-color: var(--accent-dark-color);
    }
    .content-panel p, .content-panel ul, .content-panel ol, .content-panel .formula-container {
        margin-bottom: 1.2em;
    }
    .content-panel p:last-child, .content-panel ul:last-child, .content-panel ol:last-child, .content-panel .formula-container:last-child {
        margin-bottom: 0;
    }
    ul, ol {
        padding-left: 30px;
    }
    li {
        margin-bottom: 0.6em;
    }
    strong {
        font-weight: 700;
    }
    .initial-intro {
        font-style: italic;
        margin-bottom: 20px;
        padding: 10px;
        background-color: var(--content-panel-bg);
        border-left: 3px solid var(--accent-color);
    }

    /* Estilos para f√≥rmulas */
    .formula-container {
        background-color: var(--formula-bg);
        border: 1px solid var(--formula-border);
        padding: 15px;
        margin: 10px 0;
        border-radius: 4px;
        overflow-x: auto; /* Para f√≥rmulas largas */
        font-family: 'Times New Roman', Times, serif; /* Fuente m√°s matem√°tica */
        font-size: 1.1em;
    }
    .formula-container strong { /* Para etiquetas de f√≥rmula */
        display: block;
        margin-bottom: 8px;
        color: var(--header-color);
        font-family: 'Roboto', Arial, sans-serif; /* Volver a Roboto para etiquetas */
    }
    .formula-container var, .formula-container i { /* Para variables matem√°ticas */
        font-style: italic;
    }
    .formula-container .fraction {
        display: inline-block;
        text-align: center;
        vertical-align: middle;
    }
    .formula-container .numerator {
        border-bottom: 1px solid var(--text-color);
        display: block;
        padding: 0 0.2em;
    }
    .formula-container .denominator {
        display: block;
        padding: 0 0.2em;
    }


    /* Estilos para la tabla de resumen */
    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 20px;
      margin-bottom: 15px;
    }
    th, td {
      border: 1px solid var(--table-border-color);
      padding: 12px; /* M√°s padding */
      text-align: left;
      vertical-align: top;
    }
    th {
      background-color: var(--table-header-bg);
      color: var(--header-color);
      font-weight: 700;
    }
    body.dark-mode th {
        color: var(--header-dark-color);
    }
    td:first-child { /* Primera columna (Enfoque) en negrita */
        font-weight: bold;
    }
    caption {
      caption-side: top;
      font-size: 1.3em;
      font-weight: bold;
      color: var(--header-color);
      margin-bottom: 10px;
      text-align: center;
    }

  </style>
</head>
<body>
  <div class="container">
    <button id="theme-toggle-btn" class="theme-toggle" onclick="toggleTheme()" title="Cambiar tema de color">Modo Oscuro</button>

    <h1>Formulaci√≥n Matem√°tica del Algoritmo Gen√©tico</h1>
    <p class="initial-intro">
      La formulaci√≥n matem√°tica del algoritmo gen√©tico (AG) es particular, ya que no es un algoritmo determinista cl√°sico como el simplex o el gradiente descendente. Es un proceso estoc√°stico, por lo tanto, su formulaci√≥n se basa m√°s en probabilidades, teor√≠a de Markov, teor√≠a de esquemas y teor√≠a de cadenas gen√©ticas. Aqu√≠ se presentan los enfoques esenciales.
    </p>

    <!-- Secci√≥n 1: Modelo de Markov -->
    <button class="section-toggle-button" onclick="toggleSection('fm_markov', this)" aria-expanded="false" aria-controls="fm_markov">
      1. Modelo de Markov (estoc√°stico)
    </button>
    <div id="fm_markov" class="content-panel">
      <p>Los algoritmos gen√©ticos pueden modelarse como cadenas de Markov de primer orden en las que cada estado representa una poblaci√≥n de soluciones, y la probabilidad de transici√≥n depende solo de la poblaci√≥n actual.</p>
      <p>Sea <i>P<sub>t</sub></i> la poblaci√≥n en la generaci√≥n <i>t</i>.</p>
      <p>El algoritmo gen√©tico define una funci√≥n de transici√≥n estoc√°stica <i>T</i> tal que:</p>
      <div class="formula-container">
        P(<i>P<sub>t+1</sub></i> | <i>P<sub>t</sub></i>) = <i>T</i>(<i>P<sub>t</sub></i>)
      </div>
      <p>Bajo ciertas condiciones (p. ej. diversidad suficiente, no cero probabilidades de mutaci√≥n), se puede demostrar que el AG converge en probabilidad a un conjunto de soluciones √≥ptimas (no necesariamente el global).</p>
    </div>

    <!-- Secci√≥n 2: Teorema del Esquema de Holland -->
    <button class="section-toggle-button" onclick="toggleSection('fm_schema', this)" aria-expanded="false" aria-controls="fm_schema">
      2. Teorema del Esquema de Holland (Schema Theorem)
    </button>
    <div id="fm_schema" class="content-panel">
      <p>Uno de los fundamentos te√≥ricos m√°s importantes en AG. Define c√≥mo los esquemas (patrones parciales de cromosomas) evolucionan a lo largo del tiempo.</p>
      <h3>Definici√≥n de esquema:</h3>
      <p>Un esquema <i>H</i> es una plantilla de genes que especifica valores fijos en ciertas posiciones y "comodines" (*) en otras.</p>
      <p>Por ejemplo, para una codificaci√≥n binaria de 6 bits, el esquema:</p>
      <div class="formula-container"><i>H</i> = 1 * 0 * * 1</div>
      <p>representa todos los cromosomas donde:</p>
      <ul>
        <li>el primer bit es 1,</li>
        <li>el tercer bit es 0,</li>
        <li>el sexto bit es 1,</li>
        <li>y los dem√°s pueden tomar cualquier valor.</li>
      </ul>
      <h3>F√≥rmula del Teorema del Esquema:</h3>
      <p>El n√∫mero esperado de individuos en la pr√≥xima generaci√≥n que pertenecen al esquema <i>H</i>, denotado <i>m</i>(<i>H</i>, <i>t</i>+1), es:</p>
      <div class="formula-container">
        <i>m</i>(<i>H</i>, <i>t</i>+1) ‚â• <i>m</i>(<i>H</i>, <i>t</i>) ‚ãÖ
        <span class="fraction"><span class="numerator"><i>f</i>(<i>H</i>)</span><span class="denominator"><i>fÃÑ</i></span></span>
        ‚ãÖ (1 ‚àí <i>p<sub>c</sub></i> ‚ãÖ
        <span class="fraction"><span class="numerator">Œ¥(<i>H</i>)</span><span class="denominator"><i>l</i>‚àí1</span></span>
        ‚àí <i>p<sub>m</sub></i> ‚ãÖ <i>o</i>(<i>H</i>))
      </div>
      <p>Donde:</p>
      <ul>
        <li><i>m</i>(<i>H</i>, <i>t</i>): n√∫mero de individuos en <i>H</i> en la generaci√≥n <i>t</i>.</li>
        <li><i>f</i>(<i>H</i>): aptitud promedio de los individuos que pertenecen a <i>H</i>.</li>
        <li><i>fÃÑ</i>: aptitud promedio de toda la poblaci√≥n.</li>
        <li><i>p<sub>c</sub></i>: probabilidad de cruce.</li>
        <li>Œ¥(<i>H</i>): longitud del esquema (distancia entre los bits m√°s lejanos definidos).</li>
        <li><i>l</i>: longitud del cromosoma.</li>
        <li><i>p<sub>m</sub></i>: probabilidad de mutaci√≥n por bit.</li>
        <li><i>o</i>(<i>H</i>): n√∫mero de bits definidos en el esquema.</li>
      </ul>
      <h3>Interpretaci√≥n:</h3>
      <p>El teorema muestra c√≥mo los esquemas de alta aptitud, cortos y con pocos bits definidos tienden a sobrevivir y multiplicarse ‚Äî "supervivencia del m√°s apto y m√°s compacto".</p>
    </div>

    <!-- Secci√≥n 3: Evoluci√≥n de la distribuci√≥n de probabilidad -->
    <button class="section-toggle-button" onclick="toggleSection('fm_distribucion', this)" aria-expanded="false" aria-controls="fm_distribucion">
      3. Evoluci√≥n de la distribuci√≥n de probabilidad
    </button>
    <div id="fm_distribucion" class="content-panel">
      <p>En lugar de analizar individuos espec√≠ficos, se puede modelar c√≥mo cambia la distribuci√≥n de probabilidad sobre el espacio de soluciones.</p>
      <p>Sea <i>x</i> ‚àà <i>S</i> una soluci√≥n posible, y <i>P<sub>t</sub></i>(<i>x</i>) la probabilidad de que <i>x</i> est√© presente en la poblaci√≥n en la generaci√≥n <i>t</i>.</p>
      <p>El algoritmo gen√©tico define un operador de evoluci√≥n <i>G</i> tal que:</p>
      <div class="formula-container">
        <i>P<sub>t+1</sub></i>(<i>x</i>) = <i>G</i>(<i>P<sub>t</sub></i>(<i>x</i>))
      </div>
      <p>Este enfoque se usa en la teor√≠a de algoritmos evolutivos distribuidos y de estimaci√≥n de distribuci√≥n (Estimation of Distribution Algorithms, EDA), que son variantes m√°s formales y anal√≠ticas.</p>
    </div>

    <!-- Secci√≥n 4: Optimizaci√≥n matem√°tica basada en fitness -->
    <button class="section-toggle-button" onclick="toggleSection('fm_optimizacion', this)" aria-expanded="false" aria-controls="fm_optimizacion">
      4. Optimizaci√≥n matem√°tica basada en fitness
    </button>
    <div id="fm_optimizacion" class="content-panel">
      <p>Aunque los AG no buscan optimizar una funci√≥n directamente como en los m√©todos cl√°sicos, el objetivo final sigue siendo:</p>
      <div class="formula-container">
        max<sub><i>x</i>‚àà<i>S</i></sub> <i>f</i>(<i>x</i>)
      </div>
      <p>El AG act√∫a como un algoritmo de b√∫squeda estoc√°stico que intenta encontrar una <i>x<sup>*</sup></i> ‚àà <i>S</i> tal que:</p>
      <div class="formula-container">
        <i>f</i>(<i>x<sup>*</sup></i>) ‚â• <i>f</i>(<i>x</i>), ‚àÄ<i>x</i> ‚àà <i>S</i>
      </div>
      <p>Dado que no hay garant√≠a de encontrar el √≥ptimo global, se suele hablar de:</p>
      <ul>
        <li>√≥ptimos aproximados</li>
        <li>soluciones suficientemente buenas</li>
        <li>convergencia en probabilidad (bajo ciertas condiciones te√≥ricas)</li>
      </ul>
    </div>

    <!-- Secci√≥n 5: Resumen de la formulaci√≥n matem√°tica -->
    <button class="section-toggle-button" onclick="toggleSection('fm_resumen', this)" aria-expanded="false" aria-controls="fm_resumen">
      Resumen de la Formulaci√≥n Matem√°tica
    </button>
    <div id="fm_resumen" class="content-panel">
      <table>
        <caption>Principales Enfoques de Formulaci√≥n Matem√°tica en AG</caption>
        <thead>
          <tr>
            <th>Enfoque</th>
            <th>Explicaci√≥n</th>
            <th>F√≥rmula / Modelo Clave</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>Cadenas de Markov</td>
            <td>El AG es un proceso estoc√°stico sobre poblaciones.</td>
            <td><i>P</i>(<i>P<sub>t+1</sub></i> | <i>P<sub>t</sub></i>) = <i>T</i>(<i>P<sub>t</sub></i>)</td>
          </tr>
          <tr>
            <td>Teorema del Esquema</td>
            <td>Patrones con buena aptitud tienden a reproducirse.</td>
            <td><i>m</i>(<i>H</i>, <i>t</i>+1) ‚â• <i>m</i>(<i>H</i>,<i>t</i>) ‚ãÖ (<i>f</i>(<i>H</i>)/<i>fÃÑ</i>) ‚ãÖ (1 - p√©rdidas)</td>
          </tr>
          <tr>
            <td>Distribuci√≥n de probabilidad</td>
            <td>Evoluci√≥n de probabilidad sobre el espacio de soluciones.</td>
            <td><i>P<sub>t+1</sub></i>(<i>x</i>) = <i>G</i>(<i>P<sub>t</sub></i>(<i>x</i>))</td>
          </tr>
          <tr>
            <td>Optimizaci√≥n estoc√°stica</td>
            <td>AG busca maximizar <i>f</i>(<i>x</i>) sin derivadas ni convexidad.</td>
            <td>max<sub><i>x</i>‚àà<i>S</i></sub> <i>f</i>(<i>x</i>)</td>
          </tr>
        </tbody>
      </table>
    </div>

  </div> <!-- Fin de .container -->

  <script>
    // Funci√≥n para cambiar entre modo claro y oscuro
    function toggleTheme() {
      document.body.classList.toggle("dark-mode");
      let themeButton = document.getElementById('theme-toggle-btn');
      let isDarkMode = document.body.classList.contains("dark-mode");
      localStorage.setItem("theme", isDarkMode ? "dark" : "light");
      if (themeButton) {
          themeButton.textContent = isDarkMode ? "Modo Claro" : "Modo Oscuro";
      }
    }

    // Funci√≥n para mostrar/ocultar paneles de contenido
    function toggleSection(id, buttonElement) {
      let panel = document.getElementById(id);
      if (panel && buttonElement) {
          panel.classList.toggle('is-visible');
          let isVisible = panel.classList.contains('is-visible');
          buttonElement.setAttribute('aria-expanded', isVisible);
          buttonElement.classList.toggle('is-expanded', isVisible);
      }
    }

    // Funci√≥n que se ejecuta cuando la p√°gina carga
    window.onload = function() {
      let themeButton = document.getElementById('theme-toggle-btn');
      const savedTheme = localStorage.getItem("theme");

      if (savedTheme === "dark") {
        document.body.classList.add("dark-mode");
        if (themeButton) {
            themeButton.textContent = "Modo Claro";
        }
      } else {
        document.body.classList.remove("dark-mode");
        if (themeButton) {
            themeButton.textContent = "Modo Oscuro";
        }
      }

       document.querySelectorAll('.content-panel').forEach(panel => {
         panel.classList.remove('is-visible');
       });
       document.querySelectorAll('.section-toggle-button').forEach(button => {
          button.setAttribute('aria-expanded', 'false');
          button.classList.remove('is-expanded');
       });
    }
  </script>
</body>
</html>
"""

# Mostrar el HTML en la salida de la celda
display(HTML(html_content))

"""ergodicidad  i puede a cualquier punto de la soluci√≥n , no hay ciclos que tres pasos al  vuelvo al inicio  mayor variedad de la poblaci√≥n , mutacion torneos, ruletas  aumenta variabilidad de la poblacion ergocidad en todo el espacio soluci√≥n no solo en una parte   optimos globables"""

import networkx as nx
import matplotlib.pyplot as plt
import numpy as np
import random
import seaborn as sns
import time

# Configuraci√≥n de estilo visual
plt.style.use('default')
sns.set_palette("husl")
plt.rcParams['figure.facecolor'] = 'white'
plt.rcParams['axes.facecolor'] = 'white'
plt.rcParams['savefig.facecolor'] = 'white'

class GeneticHamiltonianSolver:
    def __init__(self, graph, population_size=100, elite_size=20, mutation_rate=0.15,
                 crossover_rate=0.8, max_generations=500, animate=False,
                 stagnation_limit=50, random_seed=None):  # Nuevos par√°metros

        self.random_seed = random_seed
        if self.random_seed is not None:
            random.seed(self.random_seed)
            np.random.seed(self.random_seed)

        self.graph = graph
        self.nodes = list(graph.nodes())

        if not self.nodes:
            raise ValueError("El grafo no puede estar vac√≠o.")

        if len(self.nodes) > 1 and not nx.is_connected(self.graph):
            # Permitir grafos de 1 nodo (trivialmente HC para algunas definiciones)
            # Grafos de 0 nodos ya se manejan arriba.
            raise ValueError("El grafo no es conexo. Un ciclo Hamiltoniano no puede existir.")

        self.n_nodes = len(self.nodes)
        if self.n_nodes < 3 and self.n_nodes > 0:  # Incluye n_nodes == 1, 2
            print(f"Advertencia: El grafo tiene {self.n_nodes} nodos. "
                  "La definici√≥n estricta de ciclo Hamiltoniano es para n >= 3 nodos.")

        self.population_size = population_size
        self.elite_size = elite_size
        self.mutation_rate = mutation_rate
        self.crossover_rate = crossover_rate
        self.max_generations = max_generations
        self.animate = animate
        self.stagnation_limit = stagnation_limit

        self.best_fitness_history = []
        self.avg_fitness_history = []
        self.diversity_history = []
        self.generation_times = []

        self.best_cycle = None
        self.best_fitness = float('-inf')
        self.current_generation = 0
        self.generations_since_last_improvement = 0

        self.pos = nx.spring_layout(
            graph,
            seed=self.random_seed if self.random_seed is not None else 42,
            k=2/np.sqrt(self.n_nodes) if self.n_nodes > 0 else 2,
            iterations=100
        )
        self.fig_dynamic = None
        self.axes_dynamic = None

    def create_individual(self):
        individual = self.nodes.copy()
        random.shuffle(individual)
        return individual

    def create_population(self):
        population = []
        if self.n_nodes == 0:
            return []
        # Asegurar que pop_size / 4 no sea 0 si pop_size es peque√±o
        num_greedy = max(1, self.population_size // 4) if self.population_size >= 4 else 0
        num_random_fill = self.population_size // 2

        for _ in range(num_random_fill):
            population.append(self.create_individual())
        for _ in range(num_greedy):
            if len(population) < self.population_size:  # Evitar exceder
                population.append(self.create_greedy_individual())
        while len(population) < self.population_size:
            population.append(self.create_individual())
        return population

    def create_greedy_individual(self):
        if not self.nodes:
            return []
        unvisited = set(self.nodes)
        start_node = random.choice(self.nodes)
        current = start_node
        path = [current]
        unvisited.remove(current)
        while unvisited:
            neighbors = [n for n in self.graph.neighbors(current) if n in unvisited]
            next_node = random.choice(neighbors) if neighbors else random.choice(list(unvisited))
            path.append(next_node)
            unvisited.remove(next_node)
            current = next_node
        return path

    def fitness(self, individual):
        if not individual or len(individual) != self.n_nodes:
            return float('-inf')
        score = 0
        valid_edges = 0
        total_edges = self.n_nodes

        max_consecutive_valid_edges = 0
        current_consecutive_valid_edges = 0

        for i in range(self.n_nodes):
            current_node, next_node = individual[i], individual[(i + 1) % self.n_nodes]
            if self.graph.has_edge(current_node, next_node):
                valid_edges += 1
                score += 10
                current_consecutive_valid_edges += 1
            else:
                score -= 7  # Penalizaci√≥n un poco mayor por aristas faltantes
                if current_consecutive_valid_edges > max_consecutive_valid_edges:
                    max_consecutive_valid_edges = current_consecutive_valid_edges
                current_consecutive_valid_edges = 0

        if current_consecutive_valid_edges > max_consecutive_valid_edges:
            max_consecutive_valid_edges = current_consecutive_valid_edges

        if total_edges > 0:
            score += (max_consecutive_valid_edges / total_edges) * 20  # Bonificaci√≥n por secuencia m√°s larga

        if valid_edges == total_edges and len(set(individual)) == self.n_nodes:
            score += 100
        completeness_ratio = valid_edges / total_edges if total_edges > 0 else 0
        score += completeness_ratio * 50
        if len(set(individual)) != len(individual):
            score -= 500
        return score

    def is_hamiltonian_cycle(self, individual):
        if not individual or len(individual) != self.n_nodes or len(set(individual)) != self.n_nodes:
            return False
        for i in range(self.n_nodes):
            if not self.graph.has_edge(individual[i], individual[(i + 1) % self.n_nodes]):
                return False
        return True

    def selection(self, population, fitnesses):
        selected = []
        pop_size = len(population)
        if pop_size == 0:
            return []
        for _ in range(pop_size):
            tourn_size = min(5, pop_size)
            tourn_indices = random.sample(range(pop_size), tourn_size)
            winner_idx_in_tourn = np.argmax([fitnesses[i] for i in tourn_indices])
            selected.append(population[tourn_indices[winner_idx_in_tourn]])
        return selected

    def crossover(self, parent1, parent2):
        if random.random() > self.crossover_rate or len(parent1) < 3:
            return parent1.copy(), parent2.copy()
        size = len(parent1)
        child1, child2 = [None] * size, [None] * size
        start, end = sorted(random.sample(range(size), 2))
        child1[start:end+1] = parent1[start:end+1]
        child2[start:end+1] = parent2[start:end+1]
        self._fill_child(child1, parent2, start, end, size)
        self._fill_child(child2, parent1, start, end, size)
        return child1, child2

    def _fill_child(self, child, parent, start, end, size):
        child_segment_set = set(child[start:end+1])
        current_pos = (end + 1) % size
        parent_ptr = (end + 1) % size
        filled_count = 0
        elements_to_fill = size - (end - start + 1)
        # Iterar un m√°ximo de 'size' veces para evitar bucles infinitos si algo va mal con parent_ptr
        for _ in range(size):
            if filled_count >= elements_to_fill:
                break
            if parent[parent_ptr] not in child_segment_set:
                child[current_pos] = parent[parent_ptr]
                current_pos = (current_pos + 1) % size
                filled_count += 1
            parent_ptr = (parent_ptr + 1) % size

        if None in child:
            missing_nodes = list(set(self.nodes) - set(filter(None, child)))
            random.shuffle(missing_nodes)
            j = 0
            for i in range(size):
                if child[i] is None:
                    if j < len(missing_nodes):
                        child[i] = missing_nodes[j]
                        j += 1
                    else:  # Deber√≠a ser imposible si la l√≥gica es correcta, pero como fallback...
                        child[i] = random.choice(list(set(self.nodes) - set(filter(None, child))))

    def mutate(self, individual):
        if random.random() < self.mutation_rate and len(individual) >= 2:
            mutation_type = random.choice(['swap', 'reverse', 'insert'])
            if mutation_type == 'swap':
                idx1, idx2 = random.sample(range(len(individual)), 2)
                individual[idx1], individual[idx2] = individual[idx2], individual[idx1]
            elif mutation_type == 'reverse' and len(individual) > 2:
                start, end = sorted(random.sample(range(len(individual)), 2))
                individual[start:end+1] = individual[start:end+1][::-1]
            elif mutation_type == 'insert' and len(individual) > 1:  # Necesita al menos 2 elementos para mover
                from_idx = random.randrange(len(individual))
                # Asegurar que to_idx sea diferente si es posible y significativo
                possible_to_indices = list(range(len(individual)))
                if len(possible_to_indices) > 1:
                    possible_to_indices.pop(from_idx if from_idx < len(possible_to_indices) else -1)  # Evitar error si from_idx es el ultimo

                to_idx = random.choice(possible_to_indices) if possible_to_indices else from_idx

                element = individual.pop(from_idx)
                individual.insert(to_idx, element)
        return individual

    def calculate_diversity(self, population):
        if len(population) < 2 or not population[0]:
            return 0.0
        num_comparisons, total_distance = 0, 0
        ind_len = len(population[0])
        if ind_len == 0:
            return 0.0
        # Para poblaciones grandes, muestrear pares para estimar diversidad
        sample_size = min(len(population), 50)  # Comparar hasta 50 individuos

        indices_to_compare = random.sample(range(len(population)), sample_size)

        for i_idx in range(len(indices_to_compare)):
            for j_idx in range(i_idx + 1, len(indices_to_compare)):
                idx1 = indices_to_compare[i_idx]
                idx2 = indices_to_compare[j_idx]
                dist = sum(1 for k in range(ind_len) if population[idx1][k] != population[idx2][k])
                total_distance += dist / ind_len
                num_comparisons += 1
        return total_distance / num_comparisons if num_comparisons > 0 else 0.0

    def setup_dynamic_visualization(self):
        if not self.animate:
            return
        plt.ion()
        self.fig_dynamic, self.axes_dynamic = plt.subplots(2, 3, figsize=(22, 13))
        self.fig_dynamic.patch.set_facecolor('white')
        self.fig_dynamic.suptitle('Evoluci√≥n del Algoritmo Gen√©tico en Tiempo Real', fontsize=20, fontweight='bold')
        titles = [
            'Grafo Original', 'Mejor Soluci√≥n Actual', 'Evoluci√≥n del Fitness',
            'Top 5 Individuos', 'Diversidad Poblacional', 'Estad√≠sticas Generaci√≥n Actual'
        ]
        for i, ax in enumerate(self.axes_dynamic.flat):
            ax.set_title(titles[i], fontsize=14, fontweight='bold')
        plt.tight_layout(rect=[0, 0, 1, 0.96])
        plt.show(block=False)

    def update_dynamic_visualization(self, population, fitnesses):
        if not self.animate or self.axes_dynamic is None or not plt.fignum_exists(self.fig_dynamic.number):
            return
        for ax in self.axes_dynamic.flat:
            ax.clear()
        titles = [
            'Grafo Original', 'Mejor Soluci√≥n Actual', 'Evoluci√≥n del Fitness',
            'Top 5 Individuos', 'Diversidad Poblacional', 'Estad√≠sticas Generaci√≥n Actual'
        ]
        for i, ax in enumerate(self.axes_dynamic.flat):
            ax.set_title(titles[i], fontsize=14, fontweight='bold')

        # Panel 1: Grafo base
        ax = self.axes_dynamic[0, 0]
        edge_collection_dyn_base = nx.draw_networkx_edges(
            self.graph, self.pos,
            edge_color='#666666', width=1.8, alpha=0.85, ax=ax
        )
        if edge_collection_dyn_base:
            for ec_item in edge_collection_dyn_base if isinstance(edge_collection_dyn_base, list) else [edge_collection_dyn_base]:
                ec_item.set_zorder(1)
        node_collection_dyn_base = nx.draw_networkx_nodes(
            self.graph, self.pos,
            node_color='#87CEEB', node_size=300,
            edgecolors='#333333', linewidths=1.5, ax=ax
        )
        if node_collection_dyn_base:
            node_collection_dyn_base.set_zorder(2)
        labels_drawn_dyn_base = nx.draw_networkx_labels(self.graph, self.pos, font_size=9, font_weight='bold', ax=ax)
        if labels_drawn_dyn_base:
            for label_artist in labels_drawn_dyn_base.values():
                label_artist.set_zorder(3)
        ax.axis('off')

        # Panel 2: Mejor soluci√≥n actual
        ax = self.axes_dynamic[0, 1]
        if self.best_cycle:
            is_hc = self.is_hamiltonian_cycle(self.best_cycle)
            title_suffix = " (Hamiltoniano)" if is_hc else ""
            self._draw_solution_on_axis(
                ax, self.best_cycle,
                f'Gen {self.current_generation} - Fitness: {self.best_fitness:.1f}{title_suffix}'
            )
        else:
            ax.text(0.5, 0.5, 'Sin soluci√≥n a√∫n', ha='center', va='center', transform=ax.transAxes, fontsize=12)
            nx.draw_networkx_nodes(self.graph, self.pos, node_color='#DDDDDD', node_size=300, ax=ax)
            nx.draw_networkx_edges(self.graph, self.pos, edge_color='#EEEEEE', width=1.5, alpha=0.5, ax=ax)
            ax.axis('off')

        # Panel 3: Evoluci√≥n del fitness
        ax = self.axes_dynamic[0, 2]
        if len(self.best_fitness_history) > 1:
            gens = range(len(self.best_fitness_history))
            ax.plot(gens, self.best_fitness_history, 'g-', linewidth=2.5, label='Mejor Fitness')
            ax.plot(gens, self.avg_fitness_history, 'b--', linewidth=2, label='Fitness Promedio')
            ax.set_xlabel('Generaci√≥n', fontsize=10)
            ax.set_ylabel('Fitness', fontsize=10)
            ax.legend(fontsize=9)
            ax.grid(True, linestyle=':', alpha=0.5)
        else:
            ax.text(0.5, 0.5, 'Calculando fitness...', ha='center', va='center', transform=ax.transAxes, fontsize=12)

        # Panel 4: Top 5 individuos
        ax = self.axes_dynamic[1, 0]
        if fitnesses and population:
            sorted_indices = np.argsort(fitnesses)[::-1]
            top_n = min(5, len(population))
            top_fits = [fitnesses[i] for i in sorted_indices[:top_n]]
            colors = sns.color_palette("viridis", n_colors=top_n)
            bars = ax.bar(range(top_n), top_fits, color=colors)
            ax.set_xlabel('Top Individuos', fontsize=10)
            ax.set_ylabel('Fitness', fontsize=10)
            ax.set_xticks(range(top_n))
            ax.set_xticklabels([f'#{i+1}' for i in range(top_n)], fontsize=9)
            for bar_idx, bar in enumerate(bars):
                ax.text(
                    bar.get_x() + bar.get_width()/2.,
                    bar.get_height(),
                    f'{top_fits[bar_idx]:.1f}',
                    ha='center', va='bottom', fontsize=8, fontweight='bold'
                )
        else:
            ax.text(0.5, 0.5, 'Esperando poblaci√≥n...', ha='center', va='center', transform=ax.transAxes, fontsize=12)

        # Panel 5: Diversidad poblacional
        ax = self.axes_dynamic[1, 1]
        if len(self.diversity_history) > 1:
            ax.plot(range(len(self.diversity_history)), self.diversity_history, 'r-', linewidth=2.5)
            ax.set_xlabel('Generaci√≥n', fontsize=10)
            ax.set_ylabel('Diversidad (Hamming prom.)', fontsize=10)
            ax.grid(True, linestyle=':', alpha=0.5)
            ax.set_ylim(0, 1)
        else:
            ax.text(0.5, 0.5, 'Calculando diversidad...', ha='center', va='center', transform=ax.transAxes, fontsize=12)

        # Panel 6: Estad√≠sticas de generaci√≥n actual
        ax = self.axes_dynamic[1, 2]
        if fitnesses:
            is_hc_found = (self.best_cycle and self.is_hamiltonian_cycle(self.best_cycle))
            hc_status = 'S√ç' if is_hc_found else 'NO'
            time_gen_str = f"Tiempo Gen.: {self.generation_times[-1]:.3f}s" if self.generation_times else "Tiempo Gen.: N/A"
            stagnation_str = f"Estanc.: {self.generations_since_last_improvement}/{self.stagnation_limit}"
            stats_text = (
                f"Generaci√≥n: {self.current_generation}/{self.max_generations} ({stagnation_str})\n"
                f"Poblaci√≥n: {len(population)}\nMejor Fitness: {max(fitnesses):.2f}\n"
                f"Fitness Prom.: {np.mean(fitnesses):.2f}\n"
                f"Diversidad: {self.diversity_history[-1] if self.diversity_history else 0:.3f}\n"
                f"Hamiltoniano?: {hc_status}\n{time_gen_str}"
            )
        else:
            stats_text = "Calculando estad√≠sticas..."
        ax.text(
            0.05, 0.95, stats_text,
            transform=ax.transAxes, fontsize=10, va='top', fontfamily='monospace',
            bbox=dict(boxstyle="round,pad=0.4", facecolor="#e0f2f7", alpha=0.9)
        )
        ax.axis('off')

        plt.tight_layout(rect=[0, 0, 1, 0.96])
        try:
            self.fig_dynamic.canvas.flush_events()
            plt.pause(0.05)
        except Exception:
            self.animate = False  # Desactivar si hay problemas con UI

    def _draw_solution_on_axis(self, ax, solution, title):
        edge_collection_bg = nx.draw_networkx_edges(
            self.graph, self.pos,
            edge_color='#BBBBBB', width=1.5, alpha=0.75, ax=ax
        )
        if edge_collection_bg:
            for ec_item in edge_collection_bg if isinstance(edge_collection_bg, list) else [edge_collection_bg]:
                ec_item.set_zorder(1)

        cycle_edges = []
        if solution and len(solution) == self.n_nodes:
            for i in range(self.n_nodes):
                cycle_edges.append((solution[i], solution[(i + 1) % self.n_nodes]))

        valid_cycle_edges = [edge for edge in cycle_edges if self.graph.has_edge(*edge)]
        invalid_cycle_edges = [edge for edge in cycle_edges if not self.graph.has_edge(*edge)]

        if valid_cycle_edges:
            edge_collection_valid_sol = nx.draw_networkx_edges(
                self.graph, self.pos,
                edgelist=valid_cycle_edges,
                edge_color='#228B22', width=3, alpha=0.9, ax=ax
            )
            if edge_collection_valid_sol:
                for ec_item in edge_collection_valid_sol if isinstance(edge_collection_valid_sol, list) else [edge_collection_valid_sol]:
                    ec_item.set_zorder(2)
        if invalid_cycle_edges:
            for u, v in invalid_cycle_edges:
                if u in self.pos and v in self.pos:
                    ax.plot(
                        [self.pos[u][0], self.pos[v][0]],
                        [self.pos[u][1], self.pos[v][1]],
                        'r--', linewidth=2.5, alpha=0.8, zorder=2
                    )

        node_colors_list = ['#DDDDDD'] * len(self.nodes)
        if solution:
            cmap_colors = plt.cm.Set3.colors
            num_cmap_colors = len(cmap_colors)
            node_color_map = {
                node_in_solution: cmap_colors[i % num_cmap_colors]
                for i, node_in_solution in enumerate(solution)
            }
            node_colors_list = [node_color_map.get(node, '#DDDDDD') for node in self.graph.nodes()]

        node_collection_sol = nx.draw_networkx_nodes(
            self.graph, self.pos,
            node_color=node_colors_list,
            node_size=300,
            edgecolors='#333333',
            linewidths=1.5,
            ax=ax
        )
        if node_collection_sol:
            node_collection_sol.set_zorder(3)
        labels_drawn_sol = nx.draw_networkx_labels(self.graph, self.pos, font_size=9, font_weight='bold', ax=ax)
        if labels_drawn_sol:
            for label_artist in labels_drawn_sol.values():
                label_artist.set_zorder(4)
        ax.set_title(title, fontsize=12, fontweight='bold')
        ax.axis('off')

    def evolve(self, verbose=True):
        if self.n_nodes == 0:
            return None, float('-inf')
        if self.n_nodes < 3:  # Casos triviales
            is_trivial_hc = False
            if self.n_nodes == 1:
                self.best_cycle = self.nodes.copy()
                is_trivial_hc = True
            elif self.n_nodes == 2 and self.graph.has_edge(self.nodes[0], self.nodes[1]):
                self.best_cycle = self.nodes.copy()
                is_trivial_hc = True  # Path [0,1], ciclo es (0,1) y (1,0)

            if is_trivial_hc:
                self.best_fitness = self.fitness(self.best_cycle)
                self.best_fitness_history.append(self.best_fitness)
                self.avg_fitness_history.append(self.best_fitness)
                self.diversity_history.append(0)
                self.generation_times.append(0)
                if verbose:
                    print(f"Ciclo Hamiltoniano (trivial) encontrado para {self.n_nodes} nodos.")
                if self.animate:
                    self.setup_dynamic_visualization()
                    self.update_dynamic_visualization([self.best_cycle], [self.best_fitness])
                    if self.fig_dynamic:
                        self.fig_dynamic.suptitle(
                            'CICLO HAMILTONIANO (TRIVIAL) ENCONTRADO!',
                            fontsize=24, color='green'
                        )
                        plt.pause(2)
                        plt.ioff()
                return self.best_cycle, self.best_fitness

        self.generations_since_last_improvement = 0  # Resetear al inicio de la evoluci√≥n
        if self.animate:
            self.setup_dynamic_visualization()
        population = self.create_population()
        if not population:
            if self.animate:
                plt.ioff()
            return None, float('-inf')

        hamiltonian_found = False  # Flag para estado final

        for generation in range(self.max_generations):
            self.current_generation = generation
            start_time = time.time()
            fitnesses = [self.fitness(ind) for ind in population]

            max_fit_idx = np.argmax(fitnesses)
            if fitnesses[max_fit_idx] > self.best_fitness:
                self.best_fitness = fitnesses[max_fit_idx]
                self.best_cycle = population[max_fit_idx].copy()
                self.generations_since_last_improvement = 0
            else:
                self.generations_since_last_improvement += 1

            avg_fitness = np.mean(fitnesses)
            diversity = self.calculate_diversity(population)
            self.best_fitness_history.append(self.best_fitness)
            self.avg_fitness_history.append(avg_fitness)
            self.diversity_history.append(diversity)
            self.generation_times.append(time.time() - start_time)

            if self.animate and (generation % 1 == 0 or generation == self.max_generations - 1):
                self.update_dynamic_visualization(population, fitnesses)

            hamiltonian_found = self.best_cycle and self.is_hamiltonian_cycle(self.best_cycle)
            if hamiltonian_found:
                if verbose:
                    print(f"Ciclo Hamiltoniano encontrado en generaci√≥n {generation}!")
                if self.animate and self.fig_dynamic:
                    self.update_dynamic_visualization(population, fitnesses)  # √öltima actualizaci√≥n
                    self.fig_dynamic.suptitle(
                        'CICLO HAMILTONIANO ENCONTRADO!',
                        fontsize=24, color='green'
                    )
                    plt.pause(3)
                break

            if self.generations_since_last_improvement >= self.stagnation_limit:
                if verbose:
                    print(
                        f"Terminado por estancamiento: No hubo mejora en el mejor fitness "
                        f"during {self.stagnation_limit} generaciones (Gen {generation})."
                    )
                if self.animate and self.fig_dynamic:
                    self.update_dynamic_visualization(population, fitnesses)
                    self.fig_dynamic.suptitle(
                        f'TERMINADO POR ESTANCAMIENTO (Gen {generation})',
                        fontsize=20, color='red'
                    )
                    plt.pause(3)
                break

            selected = self.selection(population, fitnesses)
            elite_indices = np.argsort(fitnesses)[-self.elite_size:]
            new_population = [population[i] for i in elite_indices]

            while len(new_population) < self.population_size:
                if len(selected) >= 2:
                    p1, p2 = random.sample(selected, 2)
                elif selected:
                    p1, p2 = selected[0], selected[0]
                else:
                    p1, p2 = self.create_individual(), self.create_individual()
                c1, c2 = self.crossover(p1, p2)
                new_population.append(self.mutate(c1))
                if len(new_population) < self.population_size:
                    new_population.append(self.mutate(c2))
            population = new_population[:self.population_size]

            if verbose and (generation % 25 == 0 or generation == self.max_generations - 1):
                status = "Encontrado!" if hamiltonian_found else "Buscando..."
                stagn_str = f"Stagn: {self.generations_since_last_improvement}"
                print(
                    f"Gen {generation:4d}/{self.max_generations} ({stagn_str}): "
                    f"BestFit={self.best_fitness:7.1f}, AvgFit={avg_fitness:7.1f}, "
                    f"Div={diversity:.3f}, Time={self.generation_times[-1]:.3f}s - {status}"
                )

        if verbose and not hamiltonian_found and self.generations_since_last_improvement < self.stagnation_limit:
            print(
                f"Algoritmo finalizado por alcanzar max_generations. "
                f"No se encontr√≥ ciclo Hamiltoniano tras {self.max_generations} generaciones."
            )
            if self.best_cycle:
                print(f"Mejor soluci√≥n (no HC) fitness {self.best_fitness:.1f}: {self.best_cycle}")

        if self.animate:
            if self.fig_dynamic and plt.fignum_exists(self.fig_dynamic.number):
                if not hamiltonian_found and self.generations_since_last_improvement < self.stagnation_limit:
                    self.fig_dynamic.suptitle(
                        f'ALGORITMO FINALIZADO (MAX GENS: {self.current_generation + 1})',
                        fontsize=20, color='orange'
                    )
                    plt.pause(3)  # Mostrar un poco m√°s si no fue por estancamiento o √©xito
                plt.ioff()
                plt.close(self.fig_dynamic)
            self.fig_dynamic = None
            self.axes_dynamic = None
        return self.best_cycle, self.best_fitness

def create_enhanced_graph(n=20, p_additional_edge=0.15, ensure_hamiltonian=True, seed=None):
    if seed is not None:
        random.seed(seed)  # Para gnp_random_graph y elecciones aleatorias

    if n == 0:
        return nx.Graph()
    if n == 1:
        G = nx.Graph()
        G.add_node(0)
        return G
    if ensure_hamiltonian:
        G = nx.cycle_graph(n)
        nodes = list(G.nodes())
        for i in range(n):
            for j in range(i + 2, n):  # Evitar aristas adyacentes del ciclo y la que lo cierra
                if not (i == 0 and j == n - 1) and random.random() < p_additional_edge:
                    G.add_edge(nodes[i], nodes[j])
    else:
        # seed en gnp_random_graph asegura reproducibilidad del grafo base aleatorio
        G = nx.gnp_random_graph(n, p_additional_edge, seed=seed)
        if n > 0 and not nx.is_connected(G):  # Intentar conectar si no lo est√°
            components = list(nx.connected_components(G))
            if len(components) > 1:
                for i_comp in range(len(components) - 1):
                    G.add_edge(
                        random.choice(list(components[i_comp])),
                        random.choice(list(components[i_comp + 1]))
                    )
    return G

def visualize_graph_and_solution(G, solution=None, pos=None, title="Grafo y Soluci√≥n", ax=None):
    standalone_plot = ax is None
    if standalone_plot:
        fig, ax_new = plt.subplots(figsize=(14, 10))
        ax_new.set_facecolor('white')
        fig.patch.set_facecolor('white')
        ax = ax_new

    if pos is None:
        # Si no se pasa pos, generarlo (usar semilla si est√° disponible)
        seed_for_layout = 42
        k_val = 2 / np.sqrt(len(G.nodes())) if len(G.nodes()) > 0 else 2
        pos = nx.spring_layout(G, seed=seed_for_layout, k=k_val, iterations=80)

    base_edge_color = '#BBBBBB' if solution else '#666666'
    base_edge_width = 1.5 if solution else 1.8
    base_edge_alpha = 0.75 if solution else 0.9

    edge_collection_base = nx.draw_networkx_edges(
        G, pos,
        edge_color=base_edge_color,
        width=base_edge_width,
        alpha=base_edge_alpha,
        ax=ax
    )
    if edge_collection_base:
        for ec_item in edge_collection_base if isinstance(edge_collection_base, list) else [edge_collection_base]:
            ec_item.set_zorder(1)

    cycle_edges_list_for_legend = []
    if solution and len(solution) == len(G.nodes()):
        cycle_edges_list_for_legend = [
            (solution[i], solution[(i + 1) % len(solution)])
            for i in range(len(solution))
        ]
        valid_cycle_edges = [edge for edge in cycle_edges_list_for_legend if G.has_edge(*edge)]
        invalid_cycle_edges = [edge for edge in cycle_edges_list_for_legend if not G.has_edge(*edge)]

        if valid_cycle_edges:
            edge_collection_valid = nx.draw_networkx_edges(
                G, pos,
                edgelist=valid_cycle_edges,
                edge_color='#228B22',
                width=3.5,
                alpha=0.9,
                ax=ax
            )
            if edge_collection_valid:
                for ec_item in edge_collection_valid if isinstance(edge_collection_valid, list) else [edge_collection_valid]:
                    ec_item.set_zorder(2)
        if invalid_cycle_edges:
            for u, v in invalid_cycle_edges:
                if u in pos and v in pos:
                    ax.plot(
                        [pos[u][0], pos[v][0]],
                        [pos[u][1], pos[v][1]],
                        'r--',
                        linewidth=3,
                        alpha=0.8,
                        marker='x',
                        markersize=8,
                        markeredgecolor='red',
                        markerfacecolor='red',
                        zorder=2
                    )

    node_size = max(200, 800 - len(G.nodes()) * 10)
    node_colors_list = ['#87CEEB'] * len(G.nodes())
    if solution:
        cmap_colors = plt.cm.Set3.colors
        num_cmap_colors = len(cmap_colors)
        node_color_map = {
            node_in_sol: cmap_colors[i % num_cmap_colors]
            for i, node_in_sol in enumerate(solution)
        }
        node_colors_list = [node_color_map.get(node, '#E6E6FA') for node in G.nodes()]

    node_collection = nx.draw_networkx_nodes(
        G, pos,
        node_color=node_colors_list,
        node_size=node_size,
        edgecolors=['#333333'] * len(G.nodes()),
        linewidths=2,
        ax=ax
    )
    if node_collection:
        node_collection.set_zorder(3)

    labels_drawn = nx.draw_networkx_labels(G, pos, font_size=max(6, 12 - len(G.nodes()) // 6), font_weight='bold', ax=ax)
    if labels_drawn:
        for label_artist in labels_drawn.values():
            label_artist.set_zorder(4)
    ax.set_title(title, fontsize=18, fontweight='bold', pad=15)
    ax.axis('off')

    if solution:
        legend_elements = []
        if any(G.has_edge(*edge) for edge in cycle_edges_list_for_legend):
            legend_elements.append(
                plt.Line2D([0], [0], color='#228B22', lw=4, label='Aristas v√°lidas del ciclo')
            )
        if any(not G.has_edge(*edge) for edge in cycle_edges_list_for_legend):
            legend_elements.append(
                plt.Line2D([0], [0], color='red', lw=3, ls='--', label='Aristas faltantes propuestas')
            )
        legend_elements.append(
            plt.Line2D([0], [0], color=base_edge_color, lw=base_edge_width, label='Otras aristas del grafo')
        )
        if legend_elements:
            ax.legend(handles=legend_elements, loc='best', frameon=True, fancybox=True, shadow=True, fontsize=10)

    if standalone_plot:
        plt.tight_layout()
        plt.show()
    return pos

def plot_evolution_statistics(solver, graph_n_nodes):
    if not solver.best_fitness_history:
        print("No hay historial de fitness.")
        return
    fig, axes = plt.subplots(2, 2, figsize=(16, 11))
    fig.patch.set_facecolor('white')
    fig.suptitle(
        f'Estad√≠sticas del AG (Grafo de {graph_n_nodes} nodos, Seed: {solver.random_seed})',
        fontsize=18, fontweight='bold'
    )
    gens = range(len(solver.best_fitness_history))

    axes[0, 0].plot(gens, solver.best_fitness_history, 'g-', lw=2.5, label='Mejor Fitness')
    axes[0, 0].plot(gens, solver.avg_fitness_history, 'b--', lw=2, label='Fitness Promedio')
    axes[0, 0].set_xlabel('Generaci√≥n', fontsize=12)
    axes[0, 0].set_ylabel('Fitness', fontsize=12)
    axes[0, 0].set_title('Evoluci√≥n del Fitness', fontsize=14, fontweight='bold')
    axes[0, 0].legend(fontsize=11)
    axes[0, 0].grid(True, ls=':', alpha=0.5)

    axes[0, 1].plot(gens, solver.diversity_history, 'r-', lw=2.5)
    axes[0, 1].set_xlabel('Generaci√≥n', fontsize=12)
    axes[0, 1].set_ylabel('Diversidad (Hamming prom.)', fontsize=12)
    axes[0, 1].set_title('Diversidad de la Poblaci√≥n', fontsize=14, fontweight='bold')
    axes[0, 1].grid(True, ls=':', alpha=0.5)
    axes[0, 1].set_ylim(0, 1)

    if solver.generation_times:
        axes[1, 0].hist(
            solver.generation_times,
            bins=max(10, len(gens) // 10 if gens else 10),
            alpha=0.75,
            color='darkorange',
            edgecolor='black'
        )
        axes[1, 0].set_xlabel('Tiempo por Generaci√≥n (s)', fontsize=12)
        axes[1, 0].set_ylabel('Frecuencia', fontsize=12)
        axes[1, 0].set_title('Distribuci√≥n de Tiempos de Generaci√≥n', fontsize=14, fontweight='bold')
        axes[1, 0].grid(True, ls=':', alpha=0.3)
    else:
        axes[1, 0].text(0.5, 0.5, "No hay datos de tiempo", ha='center', va='center', transform=axes[1, 0].transAxes)

    improvements_x, improvements_y, current_best = [], [], float('-inf')
    for i, fit_val in enumerate(solver.best_fitness_history):
        if fit_val > current_best:
            improvements_x.append(i)
            improvements_y.append(fit_val)
            current_best = fit_val
    if improvements_x:
        axes[1, 1].plot(gens, solver.best_fitness_history, 'g-', lw=1, alpha=0.3)  # L√≠nea base
        axes[1, 1].scatter(improvements_x, improvements_y, color='purple', s=40, alpha=0.9, label='Mejoras encontradas', zorder=5)
        axes[1, 1].set_xlabel('Generaci√≥n', fontsize=12)
        axes[1, 1].set_ylabel('Fitness de la Mejora', fontsize=12)
        axes[1, 1].set_title('Puntos de Mejora del Mejor Fitness', fontsize=14, fontweight='bold')
        axes[1, 1].legend(fontsize=11)
        axes[1, 1].grid(True, ls=':', alpha=0.5)
    else:
        axes[1, 1].text(0.5, 0.5, "No hubo mejoras (o solo al inicio)", ha='center', va='center', transform=axes[1, 1].transAxes)

    plt.tight_layout(rect=[0, 0.03, 1, 0.95])
    plt.show()

# ---------------------------------------------------------------------------
# AN√ÅLISIS DEL C√ìDIGO Y POSIBLES MEJORAS FUTURAS (Actualizado para reflejar cambios)
# ---------------------------------------------------------------------------
"""
An√°lisis del C√≥digo (Versi√≥n con Mejoras Implementadas):

El c√≥digo implementa un algoritmo gen√©tico para intentar encontrar un ciclo hamiltoniano.
Incorpora: gesti√≥n de semillas aleatorias, verificaci√≥n de conexidad del grafo, criterio de
terminaci√≥n por estancamiento, y una funci√≥n de fitness que bonifica secuencias v√°lidas.

Aspectos Positivos (Resaltando Novedades):
1.  **Robustez Mejorada:**
    *   **Gesti√≥n de Semillas:** Permite ejecuciones reproducibles.
    *   **Verificaci√≥n de Conexidad:** Previene la ejecuci√≥n en grafos donde un HC es imposible.
2.  **Eficiencia de B√∫squeda:**
    *   **Terminaci√≥n por Estancamiento:** Evita c√≥mputo innecesario si el AG deja de progresar.
3.  **Funci√≥n de Fitness Refinada:** La bonificaci√≥n por secuencias de aristas v√°lidas intenta
    guiar mejor la b√∫squeda hacia caminos m√°s largos y coherentes.
4.  (Se mantienen los dem√°s aspectos positivos de la versi√≥n anterior: estructura, visualizaciones,
    configurabilidad, operadores gen√©ticos variados, etc.)

Posibles √Åreas de Refinamiento y Expansi√≥n Futura (Algunas ya abordadas parcialmente):
1.  **Funci√≥n de Fitness Avanzada:** Explorar penalizaciones por desconexiones tempranas en
    el ciclo propuesto o heur√≠sticas m√°s complejas de TSP adaptadas.
2.  **Operadores Gen√©ticos Adicionales:**
    *   Cruce: PMX, CX, ERC.
    *   Mutaci√≥n: Operadores de mejora local como 2-opt (m√°s complejo).
    *   Mutaci√≥n Adaptativa: Ajustar tasa de mutaci√≥n din√°micamente.
3.  **Eficiencia y Escalabilidad:**
    *   C√°lculo de Diversidad: La versi√≥n actual muestrea para poblaciones grandes, lo cual es una
        buena optimizaci√≥n. Se podr√≠a investigar m√°s a fondo.
    *   Paralelizaci√≥n para evaluaci√≥n de fitness.
4.  **An√°lisis de Resultados M√°s Profundo:** An√°lisis estad√≠stico sobre m√∫ltiples ejecuciones
    con diferentes semillas.
5.  **Interfaz de Usuario o Configuraci√≥n Externa:** Cargar par√°metros desde archivos.
"""

if __name__ == "__main__":
    NUM_NODES = 15
    SEED = 42  # Semilla para reproducibilidad del grafo y del AG

    # Crear grafo usando la semilla
    G = create_enhanced_graph(n=NUM_NODES, p_additional_edge=0.20, ensure_hamiltonian=False, seed=SEED)
    # G = nx.petersen_graph() # Famoso por NO ser Hamiltoniano
    # NUM_NODES = G.number_of_nodes() # Actualizar si se usa grafo predefinido

    print(f"Grafo con {G.number_of_nodes()} nodos y {G.number_of_edges()} aristas. (Seed Grafo: {SEED})")
    if G.number_of_nodes() == 0:
        exit("Grafo vac√≠o.")
    # La verificaci√≥n de conexidad ahora est√° en el constructor del Solver

    POP_SIZE = 150
    ELITE_S = int(0.1 * POP_SIZE)
    MUT_RATE = 0.18  # Ligeramente ajustado
    CROSS_RATE = 0.88  # Ligeramente ajustado
    MAX_GENS = 400
    ANIMATE = True  # True para visualizaci√≥n din√°mica
    STAGNATION_CYCLES = 75  # Generaciones sin mejora antes de parar

    # Visualizar grafo inicial
    initial_pos = visualize_graph_and_solution(
        G,
        title=f"Grafo Inicial ({G.number_of_nodes()} Nodos, Seed: {SEED})"
    )
    if ANIMATE:
        # Para evitar que la ventana de animaci√≥n se cierre inmediatamente si hay un error antes del bucle de evolve
        try:
            plt.show(block=False)
            plt.pause(1)
        except Exception as e:
            print(f"Error al mostrar grafo inicial con animaci√≥n: {e}")

    try:
        solver = GeneticHamiltonianSolver(
            G,
            population_size=POP_SIZE,
            elite_size=ELITE_S,
            mutation_rate=MUT_RATE,
            crossover_rate=CROSS_RATE,
            max_generations=MAX_GENS,
            animate=ANIMATE,
            stagnation_limit=STAGNATION_CYCLES,
            random_seed=SEED
        )

        print(f"\nIniciando Algoritmo Gen√©tico (Seed AG: {SEED})...\n")
        start_time = time.time()
        best_sol, best_fit = solver.evolve(verbose=True)
        total_time = time.time() - start_time

        if solver.best_cycle and solver.is_hamiltonian_cycle(solver.best_cycle):
            reason_for_termination = (
                f"Ciclo Hamiltoniano encontrado en generaci√≥n {solver.current_generation}."
            )
        elif solver.generations_since_last_improvement >= solver.stagnation_limit:
            reason_for_termination = (
                f"Terminado por estancamiento tras {solver.current_generation + 1} generaciones."
            )
        else:
            reason_for_termination = (
                f"Terminado por alcanzar max_generations ({solver.current_generation + 1})."
            )

        print(f"\nTiempo total: {total_time:.2f} segundos. {reason_for_termination}")

        if best_sol:
            is_hc = solver.is_hamiltonian_cycle(best_sol)
            print(f"\nMejor soluci√≥n (Fitness: {best_fit:.2f}):")
            print(f"   Camino: {' -> '.join(map(str, best_sol))} -> {best_sol[0]}")
            print(f"   ¬øHamiltoniano?: {'S√ç' if is_hc else 'NO'}")
            if not is_hc:
                valid_e = sum(
                    1 for i in range(len(best_sol))
                    if G.has_edge(best_sol[i], best_sol[(i + 1) % len(best_sol)])
                )
                print(f"   Aristas v√°lidas en ciclo propuesto: {valid_e} de {len(best_sol)}")

            solution_title = (
                f"Mejor Soluci√≥n (Fitness: {best_fit:.2f})"
                + (" - Ciclo Hamiltoniano!" if is_hc else "")
            )

            # Reutilizar la posici√≥n del grafo inicial para la visualizaci√≥n de la soluci√≥n
            visualize_graph_and_solution(G, best_sol, pos=solver.pos, title=solution_title)
        else:
            print("\nNo se encontr√≥ ninguna soluci√≥n v√°lida.")

        if solver.best_fitness_history:
            plot_evolution_statistics(solver, G.number_of_nodes())

    except ValueError as e:  # Capturar error de grafo no conexo
        print(f"\nError de configuraci√≥n: {e}")
    except Exception as e:
        print(f"\nOcurri√≥ un error inesperado durante la ejecuci√≥n: {e}")
        import traceback
        traceback.print_exc()

    # Asegurar que todas las ventanas se muestren al final si no hubo animaci√≥n activa
    # o si la ventana de animaci√≥n se cerr√≥ prematuramente.
    if not ANIMATE or (solver.fig_dynamic and not plt.fignum_exists(solver.fig_dynamic.number if solver.fig_dynamic else -1)):
        plt.show()  # Muestra todas las figuras pendientes

# Importar las funciones necesarias de IPython para mostrar HTML
from IPython.core.display import display, HTML

# Definir el contenido HTML, CSS y JavaScript como un string multil√≠nea
html_content = """
<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>AG y el Problema del Viajante (TSP)</title>
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet">
  <style>
    /* Definici√≥n de variables CSS para temas */
    :root {
      --bg-color: #f9f9f9;
      --text-color: #333;
      --header-color: #2c3e50;
      --header-dark-color: #ecf0f1;
      --accent-color: #c0392b; /* Rojo para TSP, un color "cl√°sico" de problemas dif√≠ciles */
      --accent-dark-color: #e74c3c; /* Rojo m√°s claro para modo oscuro */
      --button-bg: #e74c3c; /* Rojo m√°s claro para botones */
      --button-hover-bg: #c0392b; /* Rojo para hover */
      --button-dark-bg: #5499c7; /* Azul para modo oscuro */
      --button-dark-hover-bg: #2980b9; /* Azul oscuro para hover */
      --button-text-color: white;
      --theme-button-bg: #8e44ad;
      --theme-button-dark-bg: #f39c12;
      --content-panel-bg: #fdedec; /* Un rojo muy p√°lido */
      --content-panel-dark-bg: #4a2320; /* Un rojo oscuro para fondo de panel */
    }

    body {
      font-family: 'Roboto', Arial, sans-serif;
      line-height: 1.8;
      background-color: var(--bg-color);
      color: var(--text-color);
      transition: background-color 0.3s, color 0.3s;
      padding: 20px;
      margin: 0;
    }
    .container {
      max-width: 900px;
      margin: auto;
      padding: 20px;
      position: relative;
      background-color: var(--bg-color);
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    }
    body.dark-mode .container {
        box-shadow: 0 2px 10px rgba(0,0,0,0.3);
    }
    body.dark-mode {
      --bg-color: #2c3e50; /* Fondo general oscuro */
      --text-color: #ecf0f1;
      --header-color: var(--header-dark-color);
      --accent-color: var(--accent-dark-color);
      --button-bg: var(--button-dark-bg);
      --button-hover-bg: var(--button-dark-hover-bg);
      --content-panel-bg: var(--content-panel-dark-bg);
    }

    h1 { /* T√≠tulo principal de la p√°gina */
      font-size: 2.2em;
      color: var(--header-color);
      text-align: center;
      margin-bottom: 10px;
    }
    h2 { /* T√≠tulo de las secciones principales colapsables */
      font-size: 1.8em; /* Ligeramente m√°s peque√±o que h1 */
      color: var(--button-text-color); /* Para que coincida con el texto del bot√≥n */
      margin: 0; /* Quitar margen para que encaje bien en el bot√≥n */
      padding: 0;
      font-weight: 700; /* Mantenerlo en negrita */
      text-align: left; /* Para el texto del bot√≥n */
    }
     h3 { /* Para subt√≠tulos dentro de los paneles de contenido */
      font-size: 1.5em;
      color: var(--accent-color);
      margin-top: 20px;
      margin-bottom: 10px;
      padding-bottom: 3px;
      border-bottom: 1px solid var(--accent-color);
      text-align: left;
    }


    .content-panel {
      display: none;
      margin-top: 0;
      padding: 20px;
      border-left: 4px solid var(--accent-color);
      background-color: var(--content-panel-bg);
      border-radius: 0 0 5px 5px;
    }
    .content-panel.is-visible {
      display: block;
    }

    .section-toggle-button {
      background-color: var(--button-bg);
      border: none;
      padding: 12px 18px;
      border-radius: 5px;
      cursor: pointer;
      margin-top: 15px;
      transition: background-color 0.3s, border-radius 0.2s;
      width: 100%;
      display: flex; /* Para alinear el h2 dentro */
      align-items: center;
    }
    .section-toggle-button:hover {
      background-color: var(--button-hover-bg);
    }
    .section-toggle-button.is-expanded {
        border-radius: 5px 5px 0 0;
    }

    .theme-toggle {
      background-color: var(--theme-button-bg);
      color: white;
      border: none;
      padding: 8px 12px;
      border-radius: 5px;
      cursor: pointer;
      position: absolute;
      top: 20px;
      right: 20px;
      font-size: 0.9em;
      transition: background-color 0.3s;
      z-index: 10;
    }
    body.dark-mode .theme-toggle {
       background-color: var(--theme-button-dark-bg);
    }

    button:focus, a:focus {
        outline: 2px solid var(--accent-color);
        outline-offset: 2px;
    }
    body.dark-mode button:focus, body.dark-mode a:focus {
         outline-color: var(--accent-dark-color);
    }
    .content-panel p, .content-panel ul {
        margin-bottom: 1.1em;
    }
    .content-panel p:last-child, .content-panel ul:last-child {
        margin-bottom: 0;
    }
    ul {
        padding-left: 30px;
    }
    li {
        margin-bottom: 0.6em;
    }
    strong {
        font-weight: 700;
    }
    .initial-intro-tsp {
      font-size: 1.1em;
      line-height: 1.7;
      margin-bottom: 20px;
      padding: 15px;
      background-color: var(--content-panel-bg);
      border-left: 4px solid var(--accent-color);
      border-radius: 4px;
    }
    .question-style { /* Para el t√≠tulo principal de la pregunta */
        font-size: 1.5em;
        color: var(--header-color);
        margin-bottom: 15px;
        text-align: center;
        font-weight: bold;
    }


  </style>
</head>
<body>
  <div class="container">
    <button id="theme-toggle-btn" class="theme-toggle" onclick="toggleTheme()" title="Cambiar tema de color">Modo Oscuro</button>

    <h1>Aplicabilidad de Algoritmos Gen√©ticos al Problema del Viajante (TSP)</h1>

    <p class="question-style">¬øPor qu√© se puede aplicar un Algoritmo Gen√©tico al Problema del Viajante (TSP)?</p>

    <div class="initial-intro-tsp">
      <p>El <strong>Problema del Viajante de Comercio (TSP)</strong> es uno de los problemas cl√°sicos m√°s estudiados en la teor√≠a de la computaci√≥n y optimizaci√≥n combinatoria. Consiste en encontrar el camino m√°s corto que recorra un conjunto de ciudades exactamente una vez y regrese a la ciudad de origen. Es un problema <strong>NP-hard</strong>, es decir, <strong>no se conoce un algoritmo exacto que lo resuelva eficientemente para un gran n√∫mero de ciudades</strong>.</p>
      <p>Dado el car√°cter combinatorial y la complejidad exponencial del TSP, los m√©todos exactos se vuelven ineficientes para instancias grandes. En este contexto, los <strong>algoritmos gen√©ticos (AG)</strong> ofrecen una poderosa alternativa heur√≠stica para encontrar soluciones <strong>aproximadas</strong> de alta calidad.</p>
    </div>

    <!-- Secci√≥n: Justificaci√≥n de la Aplicabilidad -->
    <button class="section-toggle-button" onclick="toggleSection('tsp_justificacion', this)" aria-expanded="false" aria-controls="tsp_justificacion">
      <h2>Justificaci√≥n de la Aplicabilidad de AG al TSP</h2>
    </button>
    <div id="tsp_justificacion" class="content-panel">
      <h3>1. Estructura del problema adecuada para codificaci√≥n gen√©tica</h3>
      <p>En el TSP, cada soluci√≥n se representa naturalmente como una <strong>permutaci√≥n</strong> de nodos (ciudades), lo cual se ajusta perfectamente al esquema de representaci√≥n de un individuo en un AG.</p>
      <ul>
        <li><strong>Genotipo:</strong> una permutaci√≥n de nodos.</li>
        <li><strong>Fenotipo:</strong> la ruta resultante que conecta las ciudades.</li>
        <li><strong>Fitness:</strong> distancia total del recorrido (a minimizar).</li>
      </ul>

      <h3>2. Los operadores gen√©ticos pueden preservar caracter√≠sticas √∫tiles</h3>
      <p>Operadores como:</p>
      <ul>
        <li>Crossover de orden (Order Crossover, OX)</li>
        <li>Crossover de ciclo (Cycle Crossover, CX)</li>
        <li>Mutaci√≥n por inserci√≥n, intercambio o inversi√≥n</li>
      </ul>
      <p>‚Ä¶pueden dise√±arse para <strong>preservar subrutas eficientes</strong>, mejorar gradualmente la calidad de las soluciones y <strong>evitar soluciones inv√°lidas</strong> (como rutas con ciudades repetidas o faltantes).</p>

      <h3>3. El espacio de b√∫squeda es inmenso y no estructurado</h3>
      <p>Con <i>n</i> ciudades, el n√∫mero de rutas posibles es (<i>n</i>-1)!/2, lo que hace <strong>inviable</strong> la b√∫squeda exhaustiva. Los AG, al ser t√©cnicas de b√∫squeda estoc√°stica guiadas por fitness, son capaces de <strong>explorar eficazmente grandes espacios de b√∫squeda</strong> sin requerir derivadas ni continuidad.</p>

      <h3>4. Robustez ante √≥ptimos locales</h3>
      <p>Los AG no dependen de gradientes ni estructuras de convexidad. Al incorporar <strong>variaci√≥n gen√©tica (mutaci√≥n)</strong> y <strong>diversidad poblacional</strong>, tienen mayor capacidad de <strong>escapar de √≥ptimos locales</strong> en comparaci√≥n con m√©todos deterministas.</p>

      <h3>5. Adaptabilidad y flexibilidad</h3>
      <p>Los AG pueden adaptarse f√°cilmente a variantes del TSP:</p>
      <ul>
        <li>TSP asim√©trico (distancias diferentes en cada direcci√≥n).</li>
        <li>TSP con ventanas de tiempo.</li>
        <li>Multi-TSP o TSP con restricciones de capacidad (como en el VRP).</li>
        <li>TSP con criterios m√∫ltiples (multiobjetivo: distancia, riesgo, costo).</li>
      </ul>
      <p>Esto hace que el AG sea <strong>una herramienta muy vers√°til para problemas reales de ruteo y log√≠stica</strong>.</p>
    </div>

    <!-- Secci√≥n: Resultados Esperables -->
    <button class="section-toggle-button" onclick="toggleSection('tsp_resultados', this)" aria-expanded="false" aria-controls="tsp_resultados">
      <h2>Resultados Esperables</h2>
    </button>
    <div id="tsp_resultados" class="content-panel">
      <p>Aunque un algoritmo gen√©tico <strong>no garantiza encontrar la soluci√≥n √≥ptima</strong>, es com√∫n obtener <strong>soluciones de alta calidad en tiempos razonables</strong>, especialmente si se:</p>
      <ul>
        <li>Ajustan bien los par√°metros (mutaci√≥n, poblaci√≥n, generaciones).</li>
        <li>Se integran mejoras locales (como el algoritmo 2-opt).</li>
        <li>Se mantiene una buena diversidad gen√©tica.</li>
      </ul>
    </div>

    <!-- Secci√≥n: Conclusi√≥n -->
    <button class="section-toggle-button" onclick="toggleSection('tsp_conclusion', this)" aria-expanded="false" aria-controls="tsp_conclusion">
      <h2>Conclusi√≥n</h2>
    </button>
    <div id="tsp_conclusion" class="content-panel">
      <p>El <strong>algoritmo gen√©tico es aplicable y eficaz para resolver el TSP</strong> debido a:</p>
      <ul>
        <li>La compatibilidad entre la estructura del problema y el marco evolutivo.</li>
        <li>La capacidad de explorar grandes espacios de soluciones.</li>
        <li>La facilidad de adaptar operadores gen√©ticos espec√≠ficos al TSP.</li>
        <li>Su robustez y adaptabilidad a distintas variantes del problema.</li>
      </ul>
      <p>Por estas razones, el uso de algoritmos gen√©ticos para el TSP es ampliamente respaldado tanto en la literatura cient√≠fica como en aplicaciones industriales de optimizaci√≥n de rutas, log√≠stica y planificaci√≥n de recorridos.</p>
    </div>


  </div> <!-- Fin de .container -->

  <script>
    // Funci√≥n para cambiar entre modo claro y oscuro
    function toggleTheme() {
      document.body.classList.toggle("dark-mode");
      let themeButton = document.getElementById('theme-toggle-btn');
      let isDarkMode = document.body.classList.contains("dark-mode");
      localStorage.setItem("theme", isDarkMode ? "dark" : "light");
      if (themeButton) {
          themeButton.textContent = isDarkMode ? "Modo Claro" : "Modo Oscuro";
      }
    }

    // Funci√≥n para mostrar/ocultar paneles de contenido
    function toggleSection(id, buttonElement) {
      let panel = document.getElementById(id);
      if (panel && buttonElement) {
          panel.classList.toggle('is-visible');
          let isVisible = panel.classList.contains('is-visible');
          buttonElement.setAttribute('aria-expanded', isVisible);
          buttonElement.classList.toggle('is-expanded', isVisible);
      }
    }

    // Funci√≥n que se ejecuta cuando la p√°gina carga
    window.onload = function() {
      let themeButton = document.getElementById('theme-toggle-btn');
      const savedTheme = localStorage.getItem("theme");

      if (savedTheme === "dark") {
        document.body.classList.add("dark-mode");
        if (themeButton) {
            themeButton.textContent = "Modo Claro";
        }
      } else {
        document.body.classList.remove("dark-mode");
        if (themeButton) {
            themeButton.textContent = "Modo Oscuro";
        }
      }

       document.querySelectorAll('.content-panel').forEach(panel => {
         panel.classList.remove('is-visible');
       });
       document.querySelectorAll('.section-toggle-button').forEach(button => {
          button.setAttribute('aria-expanded', 'false');
          button.classList.remove('is-expanded');
       });
    }
  </script>
</body>
</html>
"""

# Mostrar el HTML en la salida de la celda
display(HTML(html_content))

import networkx as nx
import matplotlib.pyplot as plt
import numpy as np
import random
import seaborn as sns
import time
import math
from IPython.display import display, clear_output

# --- Par√°metros Globales para Mejoras (Ejemplos) ---
ADAPTIVE_MUT_LOW_DIVERSITY_THRESHOLD = 0.15
MIN_MUTATION_RATE = 0.02
MAX_MUTATION_RATE = 0.60
MUTATION_ADAPT_FACTOR_INCREASE = 1.1
MUTATION_ADAPT_FACTOR_DECREASE = 0.98

STAGNATION_FOR_RESET = 30
RESET_FRACTION = 0.3

APPLY_2OPT_EVERY_N_GENS_IN_EVOLVE = 25
PROB_APPLY_2OPT_TO_ELITE_IN_EVOLVE = 0.3

plt.style.use('default')
plt.rcParams['figure.facecolor'] = 'white'
plt.rcParams['axes.facecolor'] = 'white'
plt.rcParams['savefig.facecolor'] = 'white'
plt.rcParams['font.sans-serif'] = ['DejaVu Sans', 'Verdana', 'Geneva', 'sans-serif']
sns.set_palette("husl")


class GeneticTSPSolver:
    def __init__(self, graph, population_size=100, elite_size=20,
                 initial_mutation_rate=0.15,
                 crossover_rate=0.8, max_generations=500, animate=False,
                 stagnation_limit=50, random_seed=None,
                 use_adaptive_mutation=True,
                 use_population_reset=True,
                 use_simple_local_search_during_evolution=True, # Nombre corregido
                 apply_full_2opt_at_end=True): # Nombre corregido

        self.random_seed = random_seed
        if self.random_seed is not None:
            random.seed(self.random_seed)
            np.random.seed(self.random_seed)

        self.graph = graph
        self.nodes = list(graph.nodes())

        if not self.nodes: raise ValueError("El grafo no puede estar vac√≠o.")
        self.n_nodes = len(self.nodes)
        if self.n_nodes < 2: raise ValueError("TSP requiere al menos 2 nodos.")

        self.pos = nx.get_node_attributes(graph, 'pos')
        if not self.pos:
            k_val = 2 / np.sqrt(self.n_nodes) if self.n_nodes > 0 else 2
            self.pos = nx.spring_layout(graph, seed=self.random_seed if self.random_seed is not None else 42, k=k_val, iterations=100)
            for node_id, p_val in self.pos.items():
                if node_id in self.graph.nodes: self.graph.nodes[node_id]['pos'] = p_val

        if not self._is_graph_complete_and_weighted():
            self._complete_graph_with_weights()

        self.population_size = population_size
        self.elite_size = elite_size
        self.mutation_rate = initial_mutation_rate
        self.initial_mutation_rate = initial_mutation_rate
        self.crossover_rate = crossover_rate
        self.max_generations = max_generations
        self.animate = animate
        self.stagnation_limit = stagnation_limit

        self.use_adaptive_mutation = use_adaptive_mutation
        self.use_population_reset = use_population_reset
        self.use_simple_local_search_during_evolution = use_simple_local_search_during_evolution
        self.apply_full_2opt_at_end = apply_full_2opt_at_end

        self.best_fitness_history = []
        self.avg_fitness_history = []
        self.diversity_history = []
        self.mutation_rate_history = []
        self.generation_times = []

        self.best_tour = None
        self.best_distance = float('inf')
        self.current_generation = 0
        self.generations_since_last_improvement = 0
        self.generations_since_last_reset = 0

        self.fig_dynamic = None
        self.axes_dynamic = None

    def _is_graph_complete_and_weighted(self):
        if self.n_nodes < 2: return True
        expected_edges = self.n_nodes * (self.n_nodes - 1) / 2
        if self.graph.number_of_edges() < expected_edges: return False
        for u, v, data in self.graph.edges(data=True):
            if 'weight' not in data: return False
        return True

    def _complete_graph_with_weights(self):
        nodes_list = list(self.graph.nodes())
        for i in range(len(nodes_list)):
            for j in range(i + 1, len(nodes_list)):
                u, v = nodes_list[i], nodes_list[j]
                if not self.graph.has_edge(u, v) or 'weight' not in self.graph[u][v]:
                    if u in self.pos and v in self.pos:
                        x1, y1 = self.pos[u]; x2, y2 = self.pos[v]
                        distance = math.sqrt((x1 - x2)**2 + (y1 - y2)**2)
                    else: distance = 1.0
                    if self.graph.has_edge(u,v): self.graph[u][v]['weight'] = distance
                    else: self.graph.add_edge(u, v, weight=distance)

    def create_individual(self):
        individual = self.nodes.copy()
        random.shuffle(individual)
        return individual

    def create_population(self):
        population = []
        if self.n_nodes == 0: return []
        num_random = self.population_size // 2
        num_greedy = max(1, self.population_size // 4) if self.population_size >= 4 else 0
        num_nearest_neighbor = self.population_size - num_random - num_greedy
        for _ in range(num_random): population.append(self.create_individual())
        for i in range(min(num_greedy, self.n_nodes)):
            if len(population) < self.population_size:
                population.append(self.create_nearest_neighbor_tour(start_node=self.nodes[i % self.n_nodes]))
        for _ in range(num_nearest_neighbor):
            if len(population) < self.population_size:
                population.append(self.create_nearest_neighbor_tour(randomize_start=True))
        while len(population) < self.population_size: population.append(self.create_individual())
        return population

    def create_nearest_neighbor_tour(self, start_node=None, randomize_start=False):
        if not self.nodes: return []
        unvisited = set(self.nodes)
        if randomize_start: current = random.choice(self.nodes)
        elif start_node is not None: current = start_node
        else: current = self.nodes[0]
        tour = [current]
        unvisited.remove(current)
        while unvisited:
            nearest = min(unvisited, key=lambda node: self.graph[current][node]['weight'])
            tour.append(nearest); unvisited.remove(nearest); current = nearest
        return tour

    def fitness(self, individual):
        if not self.is_valid_tour(individual): return float('-inf')
        total_distance = 0
        for i in range(self.n_nodes):
            total_distance += self.graph[individual[i]][individual[(i + 1) % self.n_nodes]]['weight']
        return -total_distance

    def get_tour_distance(self, individual):
        if not individual: return float('inf')
        return -self.fitness(individual)

    def is_valid_tour(self, individual):
        return (isinstance(individual, list) and len(individual) == self.n_nodes and
                len(set(individual)) == self.n_nodes and all(node in self.nodes for node in individual))

    def selection(self, population, fitnesses):
        selected, pop_size = [], len(population)
        if pop_size == 0: return []
        for _ in range(pop_size):
            actual_tournament_size = min(5, pop_size)
            if actual_tournament_size == 0: continue
            tournament_indices = random.sample(range(pop_size), actual_tournament_size)
            winner_idx = max(tournament_indices, key=lambda i: fitnesses[i])
            selected.append(population[winner_idx])
        return selected

    def crossover(self, parent1, parent2):
        if random.random() > self.crossover_rate or len(parent1) < 3:
            return parent1.copy(), parent2.copy()
        size = len(parent1)
        def order_crossover_op(p1, p2):
            child = [None] * size; start, end = sorted(random.sample(range(size), 2))
            child[start:end+1] = p1[start:end+1]
            child_set = set(child[start:end+1])
            current_child_idx, current_parent2_idx, filled_count = (end + 1) % size, (end + 1) % size, len(child_set)
            while filled_count < size:
                candidate_node = p2[current_parent2_idx]
                if candidate_node not in child_set:
                    child[current_child_idx] = candidate_node; child_set.add(candidate_node)
                    current_child_idx = (current_child_idx + 1) % size; filled_count +=1
                current_parent2_idx = (current_parent2_idx + 1) % size
            return child
        return order_crossover_op(parent1, parent2), order_crossover_op(parent2, parent1)

    def mutate(self, individual):
        if random.random() < self.mutation_rate and len(individual) >= 2:
            mutation_type = random.choice(['swap', 'reverse', 'insert', '2opt_mutate'])
            if mutation_type == 'swap':
                idx1, idx2 = random.sample(range(len(individual)), 2)
                individual[idx1], individual[idx2] = individual[idx2], individual[idx1]
            elif mutation_type == 'reverse' and len(individual) > 2:
                start, end = sorted(random.sample(range(len(individual)), 2))
                if end > start: individual[start:end+1] = individual[start:end+1][::-1]
            elif mutation_type == 'insert' and len(individual) > 1:
                from_idx, to_idx = random.randrange(len(individual)), random.randrange(len(individual))
                if from_idx != to_idx: individual.insert(to_idx, individual.pop(from_idx))
            elif mutation_type == '2opt_mutate' and len(individual) > 3:
                i, j = sorted(random.sample(range(len(individual)), 2))
                if j - i > 1: individual[i:j+1] = individual[i:j+1][::-1]
        return individual

    def calculate_diversity(self, population):
        if not population or len(population) < 2 or not population[0]: return 0.0
        num_comparisons, total_distance, ind_len = 0, 0, len(population[0])
        if ind_len == 0: return 0.0
        sample_size = min(len(population), 50)
        indices_to_compare = random.sample(range(len(population)), sample_size)
        for i in range(len(indices_to_compare)):
            for j in range(i + 1, len(indices_to_compare)):
                idx1, idx2 = indices_to_compare[i], indices_to_compare[j]
                if not self.is_valid_tour(population[idx1]) or not self.is_valid_tour(population[idx2]) or \
                   len(population[idx1]) != ind_len or len(population[idx2]) != ind_len: continue
                dist = sum(1 for k in range(ind_len) if population[idx1][k] != population[idx2][k])
                total_distance += dist / ind_len; num_comparisons += 1
        return total_distance / num_comparisons if num_comparisons > 0 else 0.0

    def simple_2opt_local_search(self, tour):
        current_tour = tour.copy()
        current_distance = self.get_tour_distance(current_tour)
        for _ in range(self.n_nodes):
            i, j = sorted(random.sample(range(self.n_nodes), 2))
            if j - i < 2 : continue
            segment = current_tour[i+1 : j+1]
            new_tour = current_tour[:i+1] + segment[::-1] + current_tour[j+1:]
            new_distance = self.get_tour_distance(new_tour)
            if new_distance < current_distance:
                current_tour = new_tour; current_distance = new_distance
        return current_tour

    def full_2opt_local_search(self, initial_tour):
        best_tour = initial_tour.copy()
        current_best_distance = self.get_tour_distance(best_tour)
        improved = True
        while improved:
            improved = False
            for i in range(self.n_nodes - 1):
                for j in range(i + 2, self.n_nodes):
                    segment_to_reverse = best_tour[i+1 : j+1]
                    new_candidate_tour = best_tour[:i+1] + segment_to_reverse[::-1] + best_tour[j+1:]
                    new_candidate_distance = self.get_tour_distance(new_candidate_tour)
                    if new_candidate_distance < current_best_distance:
                        best_tour = new_candidate_tour[:]
                        current_best_distance = new_candidate_distance
                        improved = True
                        break
                if improved:
                    break
        return best_tour

    def setup_dynamic_visualization(self):
        if not self.animate: return
        if self.fig_dynamic is not None and plt.fignum_exists(self.fig_dynamic.number):
            plt.close(self.fig_dynamic)
        self.fig_dynamic, self.axes_dynamic = plt.subplots(2, 3, figsize=(22, 13))
        self.fig_dynamic.patch.set_facecolor('white')
        titles = ['Mapa Ciudades', 'Mejor Tour', 'Evoluci√≥n Dist.',
                  'Top 5 Tours', 'Diversidad Pob.', 'Estad√≠sticas']
        for i, ax in enumerate(self.axes_dynamic.flat):
            ax.set_title(titles[i], fontsize=14, fontweight='bold'); ax.set_facecolor('#f0f0f0')
        plt.tight_layout(rect=[0, 0, 1, 0.96])

    def update_dynamic_visualization(self, population, fitnesses):
        if not self.animate or self.axes_dynamic is None or self.fig_dynamic is None: return
        clear_output(wait=True)
        main_title_prefix = "TSP Evolution"
        main_title = f'{main_title_prefix} (Gen {self.current_generation}) - Mejor Dist: {self.best_distance:.2f}'
        if self.generations_since_last_improvement >= self.stagnation_limit:
             main_title = f'ESTANCAMIENTO (Gen {self.current_generation}) - Mejor Dist: {self.best_distance:.2f}'
        self.fig_dynamic.suptitle(main_title, fontsize=16, fontweight='bold')
        for ax_idx, ax in enumerate(self.axes_dynamic.flat):
            ax.clear()
            titles = ['Mapa Ciudades', 'Mejor Tour', 'Evoluci√≥n Dist.', 'Top 5 Tours', 'Diversidad Pob.', 'Estad√≠sticas']
            if ax_idx < len(titles):
                ax.set_title(titles[ax_idx], fontsize=14, fontweight='bold'); ax.set_facecolor('#f0f0f0')
        self._draw_cities_map(self.axes_dynamic[0, 0])
        if self.best_tour: self._draw_tour_on_axis(self.axes_dynamic[0, 1], self.best_tour, f'Gen {self.current_generation} - Dist: {self.get_tour_distance(self.best_tour):.2f}')
        else: self.axes_dynamic[0, 1].text(0.5, 0.5, 'Calculando...', ha='center', va='center', transform=self.axes_dynamic[0, 1].transAxes)
        if len(self.best_fitness_history) > 1:
            ax_dist = self.axes_dynamic[0, 2]; gens = range(len(self.best_fitness_history))
            ax_dist.plot(gens, [-f for f in self.best_fitness_history], 'g-', lw=2.5, label='Mejor Dist')
            ax_dist.plot(gens, [-f for f in self.avg_fitness_history], 'b--', lw=2, label='Dist Prom')
            ax_dist.set_xlabel('Generaci√≥n'); ax_dist.set_ylabel('Distancia'); ax_dist.legend(); ax_dist.grid(True, ls=':', alpha=0.7)
        if fitnesses and population:
            ax_top = self.axes_dynamic[1, 0]; sorted_indices = np.argsort(fitnesses)[::-1]; top_n = min(5, len(population))
            top_distances = [-fitnesses[i] for i in sorted_indices[:top_n]]
            bars = ax_top.bar(range(top_n), top_distances, color=sns.color_palette("viridis_r", n_colors=top_n))
            ax_top.set_xticks(range(top_n)); ax_top.set_xticklabels([f'#{i+1}' for i in range(top_n)])
            ax_top.set_xlabel('Ranking'); ax_top.set_ylabel('Distancia'); ax_top.grid(axis='y', ls=':', alpha=0.7)
            for bar_idx, bar in enumerate(bars): ax_top.text(bar.get_x() + bar.get_width()/2., bar.get_height() + 0.01 * max(top_distances, default=1), f'{top_distances[bar_idx]:.1f}', ha='center', va='bottom', fontsize=8, fontweight='bold')
        if len(self.diversity_history) > 1:
            ax_div = self.axes_dynamic[1, 1]
            ax_div.plot(range(len(self.diversity_history)), self.diversity_history, 'r-', lw=2.5, label='Diversidad')
            ax_div.set_xlabel('Generaci√≥n'); ax_div.set_ylabel('Diversidad'); ax_div.grid(True, ls=':', alpha=0.7); ax_div.set_ylim(0, 1)
        ax_stats = self.axes_dynamic[1, 2]; ax_stats.axis('off')
        if fitnesses and self.best_tour:
            best_dist_val = self.get_tour_distance(self.best_tour); valid_fitnesses = [f for f in fitnesses if f != float('-inf')]; avg_dist_val = -np.mean(valid_fitnesses) if valid_fitnesses else float('inf')
            time_gen_str = f"T/Gen: {self.generation_times[-1]:.3f}s" if self.generation_times else "N/A"; stag_str = f"Estanc: {self.generations_since_last_improvement}/{self.stagnation_limit}"
            current_diversity_val = self.diversity_history[-1] if self.diversity_history else "N/A"
            div_display_str = f"{current_diversity_val:.3f}" if isinstance(current_diversity_val, float) else current_diversity_val
            mut_rate_str = f"MutR: {self.mutation_rate:.3f}" if self.use_adaptive_mutation else ""
            stats_text = (f"Gen: {self.current_generation}/{self.max_generations} ({stag_str})\nPob: {len(population)}\nMejor D: {best_dist_val:.2f}\nProm D: {avg_dist_val:.2f}\nDiv: {div_display_str} {mut_rate_str}\n{time_gen_str}")
        else: stats_text = "Calculando..."
        ax_stats.text(0.05, 0.95, stats_text, transform=ax_stats.transAxes, fontsize=9, va='top', fontfamily='monospace', bbox=dict(boxstyle="round,pad=0.4", fc="#e0f2f7", alpha=0.9))
        plt.tight_layout(rect=[0, 0, 1, 0.96]); display(self.fig_dynamic)

    def _draw_cities_map(self, ax, alpha=1.0):
        if not self.graph.nodes() or not self.pos: ax.text(0.5, 0.5, "Error: Grafo o pos vac√≠as", color='red', ha='center', va='center', transform=ax.transAxes); ax.axis('off'); return
        valid_pos_for_graph = {k: v for k, v in self.pos.items() if k in self.graph}; nodes_to_draw = list(self.graph.nodes())
        if not valid_pos_for_graph or not nodes_to_draw: ax.axis('off'); return
        if self.n_nodes <= 30: nx.draw_networkx_edges(self.graph, valid_pos_for_graph, edge_color='#DDDDDD', width=0.5, alpha=alpha*0.3, ax=ax)
        base_node_color_val = sns.color_palette("Blues", n_colors=max(10, self.n_nodes))[6]
        nx.draw_networkx_nodes(self.graph, valid_pos_for_graph, nodelist=nodes_to_draw, node_color=base_node_color_val, node_size=300, edgecolors='#333333', linewidths=1.5, alpha=alpha, ax=ax)
        nx.draw_networkx_labels(self.graph, valid_pos_for_graph, font_size=9, font_weight='bold', ax=ax); ax.axis('off')

    def _draw_tour_on_axis(self, ax, tour, title):
        self._draw_cities_map(ax, alpha=0.2)
        if tour and self.is_valid_tour(tour):
            valid_pos_for_graph = {k: v for k, v in self.pos.items() if k in self.graph}; missing_pos_in_tour = [node_id for node_id in tour if node_id not in valid_pos_for_graph]
            if missing_pos_in_tour: ax.set_title(f"{title} (Error: pos faltante)", fontsize=10, color='red'); ax.axis('off'); return
            tour_edges = [(tour[i], tour[(i + 1) % len(tour)]) for i in range(len(tour))]; tour_node_colors_list = sns.color_palette("husl", n_colors=len(tour))
            nx.draw_networkx_edges(self.graph, valid_pos_for_graph, edgelist=tour_edges, edge_color='#FF4500', width=2.5, alpha=0.9, ax=ax)
            nx.draw_networkx_nodes(self.graph, valid_pos_for_graph, nodelist=tour, node_color=tour_node_colors_list, node_size=350, edgecolors='black', linewidths=1.5, ax=ax)
            for i, city_node in enumerate(tour):
                if city_node in valid_pos_for_graph: x, y = valid_pos_for_graph[city_node]; ax.text(x, y, str(i+1), ha='center', va='center', fontsize=8, fontweight='bold', color='white', bbox=dict(boxstyle="circle,pad=0.1", fc=tour_node_colors_list[i], ec="none", alpha=0.8))
        ax.set_title(title, fontsize=12, fontweight='bold'); ax.axis('off')

    def evolve(self, verbose=True):
        if self.n_nodes < 2:
            if verbose: print(f"Nodos insuficientes ({self.n_nodes}).")
            if self.n_nodes == 1: return self.nodes.copy(), 0
            return None, float('inf')

        if self.animate: self.setup_dynamic_visualization()

        self.mutation_rate = self.initial_mutation_rate
        population = self.create_population()
        if not population:
            if verbose: print("No se pudo crear poblaci√≥n.")
            return None, float('inf')

        fitnesses = [self.fitness(ind) for ind in population]
        initial_max_fit_idx = np.argmax(fitnesses)
        self.best_distance = self.get_tour_distance(population[initial_max_fit_idx])
        self.best_tour = population[initial_max_fit_idx].copy()

        self.best_fitness_history.append(fitnesses[initial_max_fit_idx])
        self.avg_fitness_history.append(np.mean([f for f in fitnesses if f != float('-inf')]))
        self.diversity_history.append(self.calculate_diversity(population))
        if self.use_adaptive_mutation: self.mutation_rate_history.append(self.mutation_rate)
        if verbose: print(f"Poblaci√≥n inicial. Mejor dist: {self.best_distance:.2f}. MutRate: {self.mutation_rate:.3f}")

        if self.animate: self.update_dynamic_visualization(population, fitnesses); time.sleep(0.1)

        for generation in range(self.max_generations):
            self.current_generation = generation; start_time_gen = time.time()
            self.generations_since_last_reset += 1

            parents_selected = self.selection(population, fitnesses)
            elite_indices = np.argsort(fitnesses)[-self.elite_size:]
            new_population = [population[i].copy() for i in elite_indices]

            if self.use_simple_local_search_during_evolution and \
               (generation % APPLY_2OPT_EVERY_N_GENS_IN_EVOLVE == 0 or \
                (self.generations_since_last_improvement > self.stagnation_limit // 2 and random.random() < PROB_APPLY_2OPT_TO_ELITE_IN_EVOLVE)):
                if verbose and generation > 0: print(f"  LS: Aplicando 2-opt simple a √©lite en gen {generation}")
                for i_elite in range(len(new_population)):
                    new_population[i_elite] = self.simple_2opt_local_search(new_population[i_elite])

            children_needed = self.population_size - len(new_population)
            children_created, idx_pair_attempts = 0,0
            max_idx_pair_attempts = len(parents_selected) * 2 if parents_selected else 0
            while children_created < children_needed and idx_pair_attempts < max_idx_pair_attempts :
                if len(parents_selected) >= 2: p1, p2 = random.sample(parents_selected, 2)
                elif len(parents_selected) == 1: p1 = p2 = parents_selected[0]
                else: new_population.append(self.create_individual()); children_created += 1; continue
                c1, c2 = self.crossover(p1, p2)
                new_population.append(self.mutate(c1.copy())); children_created += 1
                if children_created < children_needed: new_population.append(self.mutate(c2.copy())); children_created += 1
                idx_pair_attempts +=1
            while len(new_population) < self.population_size: new_population.append(self.create_individual())
            population = new_population[:self.population_size]
            fitnesses = [self.fitness(ind) for ind in population]

            current_gen_max_fit_idx = np.argmax(fitnesses)
            current_gen_best_distance = self.get_tour_distance(population[current_gen_max_fit_idx])
            if current_gen_best_distance < self.best_distance:
                self.best_distance = current_gen_best_distance; self.best_tour = population[current_gen_max_fit_idx].copy()
                self.generations_since_last_improvement = 0
                if verbose and generation > 0: print(f"‚ú® Nueva mejor dist gen {generation}: {self.best_distance:.2f}")
            else: self.generations_since_last_improvement += 1

            current_diversity = self.calculate_diversity(population)
            self.diversity_history.append(current_diversity)

            if self.use_adaptive_mutation:
                if current_diversity < ADAPTIVE_MUT_LOW_DIVERSITY_THRESHOLD and self.mutation_rate < MAX_MUTATION_RATE:
                    self.mutation_rate = min(MAX_MUTATION_RATE, self.mutation_rate * MUTATION_ADAPT_FACTOR_INCREASE)
                    if verbose and generation > 0: print(f"  MUT_ADAPT: Div baja ({current_diversity:.3f}), ‚Üë MutRate a {self.mutation_rate:.3f}")
                elif self.mutation_rate > self.initial_mutation_rate and self.generations_since_last_improvement < 10 :
                    self.mutation_rate = max(self.initial_mutation_rate, self.mutation_rate * MUTATION_ADAPT_FACTOR_DECREASE)
                self.mutation_rate_history.append(self.mutation_rate)

            valid_fitnesses_for_avg = [f for f in fitnesses if f != float('-inf')]; avg_fitness_val = np.mean(valid_fitnesses_for_avg) if valid_fitnesses_for_avg else float('-inf')
            self.best_fitness_history.append(max(fitnesses) if valid_fitnesses_for_avg else float('-inf')); self.avg_fitness_history.append(avg_fitness_val)
            self.generation_times.append(time.time() - start_time_gen)

            if self.use_population_reset and self.generations_since_last_improvement > STAGNATION_FOR_RESET and self.generations_since_last_reset > STAGNATION_FOR_RESET :
                if verbose: print(f"  RESET: Reseteo parcial de poblaci√≥n en gen {generation}.")
                num_to_reset = int(self.population_size * RESET_FRACTION); current_elite_indices = np.argsort(fitnesses)[-self.elite_size:]
                preserved_population = [population[i].copy() for i in current_elite_indices]
                for _ in range(num_to_reset):
                    if len(preserved_population) < self.population_size: preserved_population.append(self.create_individual())
                remaining_indices_sorted = [i for i in np.argsort(fitnesses)[::-1] if i not in current_elite_indices]; fill_count = 0
                while len(preserved_population) < self.population_size and fill_count < len(remaining_indices_sorted): preserved_population.append(population[remaining_indices_sorted[fill_count]].copy()); fill_count +=1
                while len(preserved_population) < self.population_size: preserved_population.append(self.create_individual())
                population = preserved_population[:self.population_size]; fitnesses = [self.fitness(ind) for ind in population]
                self.generations_since_last_reset = 0
                self.diversity_history[-1] = self.calculate_diversity(population)
                if self.use_adaptive_mutation: self.mutation_rate = self.initial_mutation_rate; self.mutation_rate_history[-1] = self.mutation_rate

            if self.animate and (generation % 5 == 0 or generation == self.max_generations - 1 or self.generations_since_last_improvement >= self.stagnation_limit-1):
                self.update_dynamic_visualization(population, fitnesses)
            if self.generations_since_last_improvement >= self.stagnation_limit:
                if verbose: print(f"Estancamiento gen {generation}. Sin mejora {self.stagnation_limit} gens.")
                if self.animate and self.fig_dynamic: self.fig_dynamic.suptitle(f'ESTANCAMIENTO (Gen {generation}) - Mejor Dist: {self.best_distance:.2f}', fontsize=16, color='red', fontweight='bold'); display(self.fig_dynamic)
                break
            if verbose and (generation % 25 == 0 or generation == self.max_generations - 1):
                 current_diversity_val = self.diversity_history[-1] if self.diversity_history else "N/A"; div_display_str = f"{current_diversity_val:.3f}" if isinstance(current_diversity_val, float) else current_diversity_val
                 mut_rate_str = f"MutR: {self.mutation_rate:.3f}" if self.use_adaptive_mutation else ""
                 print(f"Gen {generation:4d}/{self.max_generations} (Estanc: {self.generations_since_last_improvement}) | Mejor D: {self.best_distance:7.2f} | Prom D: {-avg_fitness_val:7.2f} | Div: {div_display_str} {mut_rate_str} | T: {self.generation_times[-1]:.3f}s")

        if verbose: print(f"üèÜ Mejor tour ANTES de 2-opt final: {self.best_tour}\nüìè Distancia: {self.best_distance:.2f}")
        if self.apply_full_2opt_at_end and self.best_tour is not None:
            if verbose: print("  LS_FINAL: Aplicando 2-opt completo al mejor tour final...")
            final_improved_tour = self.full_2opt_local_search(self.best_tour)
            final_improved_distance = self.get_tour_distance(final_improved_tour)
            if final_improved_distance < self.best_distance:
                if verbose: print(f"‚ú® 2-opt final mejor√≥ la distancia de {self.best_distance:.2f} a {final_improved_distance:.2f}")
                self.best_tour = final_improved_tour; self.best_distance = final_improved_distance
            elif verbose: print(f"  LS_FINAL: 2-opt final no encontr√≥ m√°s mejoras. Distancia se mantiene: {self.best_distance:.2f}")

        if verbose and self.generations_since_last_improvement < self.stagnation_limit:
            print(f"Max generaciones ({self.max_generations}) alcanzado.")
            if self.animate and self.fig_dynamic: self.fig_dynamic.suptitle(f'FINALIZADO (Max Gens: {self.max_generations}) - Mejor Dist: {self.best_distance:.2f}', fontsize=16, color='green', fontweight='bold'); display(self.fig_dynamic)
        if verbose: print(f"üèÜ Mejor tour DESPU√âS de 2-opt final: {self.best_tour}\nüìè Distancia: {self.best_distance:.2f}")
        return self.best_tour, self.best_distance

def create_complete_weighted_graph(n_nodes, coord_bounds=(0, 100), seed=None, distance_type='euclidean'):
    if seed is not None: random.seed(seed); np.random.seed(seed)
    G = nx.Graph(); positions = {}
    for i in range(n_nodes):
        x, y = random.uniform(*coord_bounds), random.uniform(*coord_bounds)
        positions[i] = (x, y); G.add_node(i, pos=(x, y))
    node_list = list(G.nodes())
    for i in range(n_nodes):
        for j in range(i + 1, n_nodes):
            u, v = node_list[i], node_list[j]; x1, y1 = positions[u]; x2, y2 = positions[v]
            if distance_type == 'euclidean': dist = math.sqrt((x1 - x2)**2 + (y1 - y2)**2)
            elif distance_type == 'manhattan': dist = abs(x1 - x2) + abs(y1 - y2)
            elif distance_type == 'random': dist = random.uniform(1, coord_bounds[1])
            else: dist = math.sqrt((x1 - x2)**2 + (y1 - y2)**2)
            G.add_edge(u, v, weight=dist)
    return G

def run_single_experiment(num_cities, seed_val, animate_run, params_ga):
    print(f"\n--- Ejecutando experimento con semilla {seed_val} ---")
    graph = create_complete_weighted_graph(num_cities, coord_bounds=(0, 100), seed=42)

    solver = GeneticTSPSolver(graph,
                              population_size=params_ga.get('pop_size', 80),
                              elite_size=params_ga.get('elite_size', 8),
                              initial_mutation_rate=params_ga.get('mut_rate', 0.20),
                              crossover_rate=params_ga.get('cross_rate', 0.85),
                              max_generations=params_ga.get('max_gens', 100),
                              animate=animate_run,
                              stagnation_limit=params_ga.get('stagn_limit', 30),
                              random_seed=seed_val,
                              use_adaptive_mutation=params_ga.get('use_adaptive_mut', True),
                              use_population_reset=params_ga.get('use_pop_reset', True),
                              use_simple_local_search_during_evolution=params_ga.get('use_simple_local_search', True), # CORREGIDO
                              apply_full_2opt_at_end=params_ga.get('apply_full_2opt_final', True) # CORREGIDO
                              )
    print(f"Par√°metros AG: Pop={solver.population_size}, Elite={solver.elite_size}, MutIni={solver.initial_mutation_rate}, "
          f"AdaptMut={solver.use_adaptive_mutation}, PopReset={solver.use_population_reset}, SimpleLS={solver.use_simple_local_search_during_evolution}, FullLS_End={solver.apply_full_2opt_at_end}")

    start_time = time.time()
    best_tour, best_distance = solver.evolve(verbose=True)
    exec_time = time.time() - start_time

    print(f"--- Fin experimento semilla {seed_val}: Dist={best_distance:.2f}, Tiempo={exec_time:.2f}s ---")

    if best_tour and animate_run == False:
        fig_final, ax_final = plt.subplots(figsize=(10, 8))
        fig_final.suptitle(f'Mejor Tour TSP ({num_cities} ciudades) - Semilla {seed_val}', fontsize=16, fontweight='bold')
        solver._draw_tour_on_axis(ax_final, best_tour, f'Dist: {best_distance:.2f} - T: {exec_time:.1f}s')
        plt.tight_layout(rect=[0, 0, 1, 0.95]); plt.show()

    return best_distance, exec_time

# --- Configuraci√≥n de la Ejecuci√≥n ---
NUM_CITIES_MAIN = 15
RANDOM_SEED_MAIN = 42

ga_parameters = {
    'pop_size': 80,
    'elite_size': 10,
    'mut_rate': 0.10,
    'cross_rate': 0.90,
    'max_gens': 150,
    'stagn_limit': 40,
    'use_adaptive_mut': True,
    'use_pop_reset': True,
    'use_simple_local_search': True,
    'apply_full_2opt_final': True,
    'animate_first_run': True
}

DO_SINGLE_RUN_WITH_ANIMATION = True
# DO_MULTI_RUN = False

if DO_SINGLE_RUN_WITH_ANIMATION:
    print("--- Ejecutando una sola vez con animaci√≥n (si est√° activada en par√°metros) ---")
    run_single_experiment(NUM_CITIES_MAIN, RANDOM_SEED_MAIN, ga_parameters.get('animate_first_run', True), ga_parameters)

# if DO_MULTI_RUN:
# ... (c√≥digo para multi-run sin cambios)

print("\nPrograma finalizado.")

# Importar las funciones necesarias de IPython para mostrar HTML
from IPython.core.display import display, HTML

# Definir el contenido HTML, CSS y JavaScript como un string multil√≠nea
html_content = """
<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>AG para Navegaci√≥n en Laberintos: Teor√≠a y Aplicaci√≥n</title>
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet">
  <style>
    /* Definici√≥n de variables CSS para temas */
    :root {
      --bg-color: #f4f6f8; /* Un gris azulado muy claro */
      --text-color: #2c3e50; /* Azul oscuro/gris para texto */
      --header-color: #2980b9; /* Azul medio */
      --header-dark-color: #a9cce3; /* Azul claro para modo oscuro */
      --accent-color: #27ae60; /* Verde esmeralda */
      --accent-dark-color: #7dcea0; /* Verde m√°s claro para modo oscuro */
      --button-bg: #3498db; /* Azul brillante */
      --button-hover-bg: #2980b9; /* Azul medio */
      --button-dark-bg: #e67e22; /* Naranja zanahoria */
      --button-dark-hover-bg: #d35400; /* Naranja quemado */
      --button-text-color: white;
      --theme-button-bg: #8e44ad; /* Amatista */
      --theme-button-dark-bg: #f1c40f; /* Girasol */
      --content-panel-bg: #eaf2f8; /* Azul cielo p√°lido */
      --content-panel-dark-bg: #34495e; /* Azul pizarra oscuro */
      --code-block-bg: #ecf0f1; /* Nubes (gris muy claro) */
      --code-block-dark-bg: #566573; /* Gris pizarra */
    }

    body {
      font-family: 'Roboto', Arial, sans-serif;
      line-height: 1.8;
      background-color: var(--bg-color);
      color: var(--text-color);
      transition: background-color 0.3s, color 0.3s;
      padding: 20px;
      margin: 0;
    }
    .container {
      max-width: 950px;
      margin: auto;
      padding: 25px;
      position: relative;
      background-color: var(--bg-color);
      border-radius: 10px;
      box-shadow: 0 5px 15px rgba(0,0,0,0.07);
    }
    body.dark-mode .container {
        box-shadow: 0 5px 15px rgba(0,0,0,0.2);
    }
    body.dark-mode {
      --bg-color: #2c3e50;
      --text-color: #ecf0f1;
      --header-color: var(--header-dark-color);
      --accent-color: var(--accent-dark-color);
      --button-bg: var(--button-dark-bg);
      --button-hover-bg: var(--button-dark-hover-bg);
      --content-panel-bg: var(--content-panel-dark-bg);
      --code-block-bg: var(--code-block-dark-bg);
    }

    h1 { /* T√≠tulo principal del documento */
      font-size: 2.4em;
      color: var(--header-color);
      text-align: center;
      margin-bottom: 20px;
      padding-bottom: 15px;
      border-bottom: 2px solid var(--header-color);
    }
    /* T√≠tulo de las secciones principales colapsables */
    .section-toggle-button h2 {
      font-size: 1.6em;
      color: var(--button-text-color);
      margin: 0;
      padding: 0;
      font-weight: 700;
      text-align: left;
    }
     /* Para subt√≠tulos dentro de los paneles de contenido */
     .content-panel h3 {
      font-size: 1.4em;
      color: var(--accent-color);
      margin-top: 20px;
      margin-bottom: 12px;
      padding-bottom: 4px;
      border-bottom: 1px solid var(--accent-color);
      text-align: left;
    }
    .content-panel h4 { /* Para sub-subt√≠tulos como a, b, c */
        font-size: 1.2em;
        color: var(--header-color);
        margin-top: 18px;
        margin-bottom: 8px;
    }

    .content-panel {
      display: none;
      margin-top: 0;
      padding: 22px;
      border-left: 4px solid var(--accent-color);
      background-color: var(--content-panel-bg);
      border-radius: 0 0 8px 8px;
    }
    .content-panel.is-visible {
      display: block;
    }

    .section-toggle-button {
      background-color: var(--button-bg);
      border: none;
      padding: 13px 18px;
      border-radius: 8px;
      cursor: pointer;
      margin-top: 16px;
      transition: background-color 0.3s, border-radius 0.2s;
      width: 100%;
      display: flex;
      align-items: center;
    }
    .section-toggle-button:hover {
      background-color: var(--button-hover-bg);
    }
    .section-toggle-button.is-expanded {
        border-radius: 8px 8px 0 0;
    }

    .theme-toggle {
      background-color: var(--theme-button-bg);
      color: white;
      border: none;
      padding: 9px 14px;
      border-radius: 6px;
      cursor: pointer;
      position: absolute;
      top: 25px;
      right: 25px;
      font-size: 0.9em;
      transition: background-color 0.3s;
      z-index: 10;
    }
    body.dark-mode .theme-toggle {
       background-color: var(--theme-button-dark-bg);
       color: var(--text-color);
    }

    button:focus, a:focus {
        outline: 2px solid var(--accent-color);
        outline-offset: 3px;
    }
    body.dark-mode button:focus, body.dark-mode a:focus {
         outline-color: var(--accent-dark-color);
    }
    .content-panel p, .content-panel ul {
        margin-bottom: 1.1em;
        font-size: 1.03em;
    }
    .content-panel p:last-child, .content-panel ul:last-child {
        margin-bottom: 0;
    }
    ul {
        padding-left: 30px;
    }
    li {
        margin-bottom: 0.6em;
    }
    strong {
        font-weight: 700;
    }
    .code-example {
        background-color: var(--code-block-bg);
        padding: 10px 15px;
        border-radius: 5px;
        font-family: 'Courier New', Courier, monospace;
        margin: 10px 0;
        white-space: pre-wrap; /* Para que respete saltos de l√≠nea y espacios */
        font-size: 0.95em;
    }
    hr {
        border: 0;
        height: 1px;
        background-image: linear-gradient(to right, rgba(0, 0, 0, 0), var(--accent-color), rgba(0, 0, 0, 0));
        margin: 25px 0;
    }
  </style>
</head>
<body>
  <div class="container">
    <button id="theme-toggle-btn" class="theme-toggle" onclick="toggleTheme()" title="Cambiar tema de color">Modo Oscuro</button>

    <h1>Algoritmos Gen√©ticos para Navegaci√≥n en Laberintos: Teor√≠a y Aplicaci√≥n Pr√°ctica</h1>

    <!-- Secci√≥n 1: Introducci√≥n -->
    <button class="section-toggle-button" onclick="toggleSection('lab_intro', this)" aria-expanded="false" aria-controls="lab_intro">
      <h2>1. Introducci√≥n</h2>
    </button>
    <div id="lab_intro" class="content-panel">
      <p>La navegaci√≥n en laberintos es un problema emblem√°tico en el campo de la inteligencia artificial. El desaf√≠o consiste en que un agente encuentre una ruta √≥ptima desde un punto de inicio hasta una meta, sorteando obst√°culos y, a menudo, minimizando la longitud del camino o el tiempo empleado. Este tipo de problema se vuelve particularmente complejo en entornos de gran escala, con m√∫ltiples caminos sin salida o con una topolog√≠a intrincada.</p>
      <p>Los <strong>algoritmos gen√©ticos (AG)</strong>, inspirados directamente en los mecanismos de la evoluci√≥n biol√≥gica como la selecci√≥n natural, la herencia y la mutaci√≥n, ofrecen un enfoque robusto y adaptable para abordar estos desaf√≠os. Permiten explorar un vasto espacio de posibles soluciones (caminos) de manera paralela y heur√≠stica.</p>
      <p>Este documento se adentra en la teor√≠a subyacente de los AG y detalla su aplicaci√≥n espec√≠fica a la resoluci√≥n de laberintos, utilizando como referencia una implementaci√≥n pr√°ctica avanzada desarrollada en Python que incorpora t√©cnicas modernas para mejorar la eficiencia y la calidad de las soluciones encontradas.</p>
    </div>
    <hr>

    <!-- Secci√≥n 2: Representaci√≥n del Laberinto y de los Individuos -->
    <button class="section-toggle-button" onclick="toggleSection('lab_representacion', this)" aria-expanded="false" aria-controls="lab_representacion">
      <h2>2. Representaci√≥n del Laberinto y de los Individuos</h2>
    </button>
    <div id="lab_representacion" class="content-panel">
      <h4>a. Laberinto como Entorno</h4>
      <p>El entorno del laberinto se modela com√∫nmente como una <strong>matriz o cuadr√≠cula bidimensional</strong>. En esta representaci√≥n, cada celda de la matriz tiene un valor que indica su naturaleza:</p>
      <ul>
        <li><strong style="color:var(--accent-color);"><code>0</code> (o un valor similar):</strong> Representa una celda transitable, es decir, un pasillo o camino por donde el agente puede moverse.</li>
        <li><strong style="color:var(--header-color);"><code>1</code> (o un valor diferente):</strong> Representa un obst√°culo, como una pared, que el agente no puede atravesar.</li>
      </ul>
      <p>Dentro de esta matriz, se definen claramente una posici√≥n de <strong>inicio (start)</strong> y una posici√≥n <strong>objetivo (end)</strong>. La navegaci√≥n v√°lida se restringe, por lo general, a movimientos en las cuatro direcciones cardinales: arriba, abajo, izquierda y derecha, desde una celda transitable a otra adyacente y tambi√©n transitable.</p>

      <h4>b. Codificaci√≥n Gen√©tica del Individuo (Camino)</h4>
      <p>En el contexto de los AG, cada <strong>individuo</strong> representa una soluci√≥n candidata al problema. Para la navegaci√≥n en laberintos, un individuo es un <strong>camino potencial</strong> desde el inicio hasta (idealmente) el final.</p>
      <p>Una codificaci√≥n efectiva y natural para este problema es representar al individuo como una <strong>secuencia ordenada de posiciones (coordenadas <code>(fila, columna)</code>)</strong> en el laberinto. Por ejemplo:</p>
      <div class="code-example">
Individuo A: [(0,0), (0,1), (1,1), (1,2), (2,2)]  // Un camino potencial
      </div>
      <p>Esta representaci√≥n es preferible a una secuencia de movimientos (ej. [derecha, abajo, derecha]), ya que facilita la aplicaci√≥n de operadores gen√©ticos directamente sobre los nodos visitados y simplifica la verificaci√≥n de la validez del camino. Cada individuo siempre comienza en la posici√≥n <code>start</code> y su estructura gen√©tica evoluciona en un intento por alcanzar la posici√≥n <code>end</code>.</p>
    </div>
    <hr>

    <!-- Secci√≥n 3: Funci√≥n de Evaluaci√≥n (Fitness) -->
    <button class="section-toggle-button" onclick="toggleSection('lab_fitness', this)" aria-expanded="false" aria-controls="lab_fitness">
      <h2>3. Funci√≥n de Evaluaci√≥n (Fitness)</h2>
    </button>
    <div id="lab_fitness" class="content-panel">
      <p>La <strong>funci√≥n de fitness</strong> es el componente cr√≠tico que gu√≠a el proceso evolutivo. Cuantifica la "calidad" o "aptitud" de cada individuo (camino) en la poblaci√≥n. Una funci√≥n de fitness bien dise√±ada es crucial para dirigir la b√∫squeda hacia soluciones deseables.</p>
      <p>Para el problema de laberintos, una funci√≥n de fitness robusta podr√≠a incorporar varios criterios, ponderados adecuadamente:</p>
      <ul>
        <li><strong>Alcance del Objetivo:</strong> Se otorga una recompensa significativamente alta (o una penalizaci√≥n muy baja) a los individuos que logran alcanzar la celda objetivo <code>(end)</code>. Este es, usualmente, el componente m√°s importante.</li>
        <li><strong>Longitud del Camino:</strong> Se penaliza la longitud excesiva del camino. Caminos m√°s cortos, si alcanzan el objetivo, son preferibles. Esto se puede implementar como una penalizaci√≥n proporcional al n√∫mero de pasos.</li>
        <li><strong>Penalizaci√≥n por Bucles o Redundancia:</strong> Visitar repetidamente las mismas celdas o segmentos del laberinto es ineficiente. Se pueden introducir penalizaciones si un individuo contiene bucles o revisita celdas innecesariamente.</li>
        <li><strong>Distancia al Objetivo (si no se alcanza):</strong> Para los individuos que no llegan al final, se puede usar una heur√≠stica como la distancia de Manhattan o Euclidiana desde la √∫ltima celda alcanzada por el individuo hasta la celda objetivo. Una menor distancia resulta en una menor penalizaci√≥n (o mayor fitness relativo).</li>
        <li><strong>Validez del Camino:</strong> Impl√≠citamente, los caminos deben ser v√°lidos (no atravesar paredes). Si se permiten caminos inv√°lidos durante la evoluci√≥n (para luego repararlos), deben ser fuertemente penalizados.</li>
      </ul>
      <p>El objetivo de esta funci√≥n multifac√©tica es guiar a la poblaci√≥n no solo a encontrar *un* camino, sino a encontrar caminos que sean directos, eficientes y que efectivamente resuelvan el laberinto.</p>
    </div>
    <hr>

    <!-- Secci√≥n 4: Operadores Gen√©ticos -->
    <button class="section-toggle-button" onclick="toggleSection('lab_operadores', this)" aria-expanded="false" aria-controls="lab_operadores">
      <h2>4. Operadores Gen√©ticos Fundamentales</h2>
    </button>
    <div id="lab_operadores" class="content-panel">
      <p>Los operadores gen√©ticos son los mecanismos que introducen variaci√≥n y combinan caracter√≠sticas de los individuos para generar nuevas soluciones (descendencia).</p>
      <h4>a. Selecci√≥n de Progenitores</h4>
      <p>El proceso de selecci√≥n determina qu√© individuos de la poblaci√≥n actual ser√°n elegidos para reproducirse. Un m√©todo com√∫nmente utilizado y efectivo es la <strong>selecci√≥n por torneo estoc√°stico</strong>:</p>
      <ol>
        <li>Se eligen aleatoriamente <i>k</i> individuos de la poblaci√≥n (donde <i>k</i> es el tama√±o del torneo, t√≠picamente un valor peque√±o como 2 o 3).</li>
        <li>De estos <i>k</i> individuos, el que tenga el mejor fitness es seleccionado como progenitor.</li>
        <li>Este proceso se repite hasta obtener el n√∫mero deseado de progenitores.</li>
      </ol>
      <p>Este m√©todo equilibra la presi√≥n selectiva (favoreciendo a los mejores) con el mantenimiento de la diversidad gen√©tica (dando oportunidad a individuos no tan buenos de ser seleccionados ocasionalmente).</p>

      <h4>b. Cruzamiento (Crossover)</h4>
      <p>El cruzamiento combina la informaci√≥n gen√©tica de dos individuos progenitores para crear uno o dos descendientes. Para caminos representados como secuencias de posiciones:</p>
      <ul>
        <li><strong>Crossover por Punto de Corte √önico/M√∫ltiple:</strong> Se elige uno o m√°s puntos de corte aleatorios en los caminos de los padres. Los segmentos resultantes se intercambian para formar los caminos de los hijos.</li>
        <li><strong>Reparaci√≥n del Camino:</strong> Despu√©s del cruzamiento, es muy probable que el camino resultante sea topol√≥gicamente inv√°lido (las celdas consecutivas podr√≠an no ser adyacentes en el laberinto). Por lo tanto, es crucial aplicar un **mecanismo de reparaci√≥n**. Esto podr√≠a implicar:
            <ul>
                <li>Eliminar nodos inv√°lidos.</li>
                <li>Insertar nodos intermedios para conectar segmentos desconectados (usando, por ejemplo, una b√∫squeda A* o BFS corta entre los puntos de ruptura).</li>
                <li>Descartar al descendiente si la reparaci√≥n es demasiado compleja o inviable.</li>
            </ul>
        </li>
      </ul>
      <p>El objetivo es que los descendientes hereden sub-caminos "buenos" de ambos padres.</p>

      <h4>c. Mutaci√≥n</h4>
      <p>La mutaci√≥n introduce peque√±os cambios aleatorios en un individuo, fomentando la exploraci√≥n de nuevas √°reas del espacio de soluciones y evitando la convergencia prematura a √≥ptimos locales. Para la navegaci√≥n en laberintos, se pueden implementar diversos tipos de mutaci√≥n:</p>
      <ul>
        <li><strong>A√±adir/Eliminar Paso:</strong> Insertar una nueva celda v√°lida en una posici√≥n aleatoria del camino, o eliminar una celda existente (siempre que el camino resultante pueda ser reparado para mantener la conectividad).</li>
        <li><strong>Reemplazar Segmento:</strong> Seleccionar un segmento aleatorio del camino y reemplazarlo por un nuevo segmento generado aleatoriamente (pero v√°lido) entre los puntos de inicio y fin del segmento original.</li>
        <li><strong>Mutaci√≥n Guiada por Obst√°culos:</strong> Si un camino est√° cerca de una pared, intentar una mutaci√≥n que lo aleje o lo redirija.</li>
        <li><strong>Optimizaci√≥n Local de un Tramo:</strong> Seleccionar un peque√±o segmento del camino y aplicar una b√∫squeda local simple (como una BFS de pocos pasos o un algoritmo de acortamiento) para encontrar una ruta mejor dentro de ese tramo.</li>
      </ul>
      <p>La diversidad de operadores de mutaci√≥n enriquece la capacidad del AG para adaptarse din√°micamente a la estructura espec√≠fica del laberinto.</p>
    </div>
    <hr>

    <!-- Secci√≥n 5: Mecanismos Avanzados -->
    <button class="section-toggle-button" onclick="toggleSection('lab_avanzados', this)" aria-expanded="false" aria-controls="lab_avanzados">
      <h2>5. Mecanismos Avanzados en la Implementaci√≥n</h2>
    </button>
    <div id="lab_avanzados" class="content-panel">
      <p>Una implementaci√≥n robusta de AG para laberintos a menudo incluye t√©cnicas m√°s sofisticadas que van m√°s all√° de los operadores b√°sicos, mejorando significativamente el rendimiento y la capacidad de encontrar soluciones √≥ptimas.</p>
      <h4>a. Mutaci√≥n Adaptativa</h4>
      <p>La tasa de mutaci√≥n (la probabilidad de que un individuo mute) es un par√°metro cr√≠tico. Una tasa fija puede no ser √≥ptima durante todo el proceso evolutivo. La <strong>mutaci√≥n adaptativa</strong> ajusta esta tasa din√°micamente:</p>
      <ul>
        <li>Si la <strong>diversidad de la poblaci√≥n</strong> (medida, por ejemplo, por la distancia promedio entre individuos o la varianza del fitness) cae por debajo de un umbral, la tasa de mutaci√≥n se incrementa. Esto ayuda a introducir nueva variabilidad gen√©tica y a escapar de posibles estancamientos.</li>
        <li>Si la poblaci√≥n est√° mostrando una mejora constante y buena diversidad, la tasa de mutaci√≥n puede reducirse para permitir una explotaci√≥n m√°s fina de las regiones prometedoras del espacio de soluciones (convergencia).</li>
      </ul>
      <p>Este mecanismo ayuda a balancear la exploraci√≥n y la explotaci√≥n de manera m√°s inteligente.</p>

      <h4>b. Reseteo Parcial de Poblaci√≥n (o Mecanismos de Diversificaci√≥n)</h4>
      <p>Cuando el algoritmo se estanca (es decir, no hay mejoras significativas en el mejor fitness durante un n√∫mero considerable de generaciones), puede ser una se√±al de que la poblaci√≥n ha convergido prematuramente a un √≥ptimo local. Para contrarrestar esto:</p>
      <ul>
        <li>Se puede realizar un <strong>reseteo parcial de la poblaci√≥n</strong>: una porci√≥n de la poblaci√≥n (excluyendo quiz√°s a los mejores individuos, la "√©lite") se reemplaza por nuevos individuos generados aleatoriamente.</li>
        <li>Alternativamente, se pueden aplicar operadores de mutaci√≥n m√°s agresivos o introducir individuos de "nichos" diferentes.</li>
      </ul>
      <p>El objetivo es reintroducir diversidad para permitir al algoritmo explorar otras regiones del espacio de b√∫squeda.</p>

      <h4>c. B√∫squeda Local H√≠brida (Mem√©tica)</h4>
      <p>Los algoritmos gen√©ticos son buenos explorando globalmente el espacio de soluciones, pero pueden no ser tan eficientes en la explotaci√≥n fina (encontrar el √≥ptimo exacto dentro de una regi√≥n prometedora). La hibridaci√≥n con t√©cnicas de b√∫squeda local puede ser muy efectiva (a esto se le conoce como <strong>algoritmos mem√©ticos</strong>):</p>
      <ul>
        <li>Peri√≥dicamente (cada cierto n√∫mero de generaciones) o cuando se detecta estancamiento.</li>
        <li>Sobre los individuos m√°s prometedores de la poblaci√≥n (la √©lite).</li>
        <li>Se aplica un algoritmo de <strong>b√∫squeda local</strong> sobre estos individuos. Para laberintos, esto podr√≠a implicar:
            <ul>
                <li>Algoritmos de acortamiento de caminos (ej. eliminar nodos redundantes si se puede trazar una l√≠nea recta entre dos nodos no consecutivos del camino).</li>
                <li>Intentar reemplazar peque√±os segmentos del camino por rutas alternativas m√°s cortas encontradas mediante una BFS o A* limitada.</li>
                <li>Eliminaci√≥n de bucles evidentes.</li>
            </ul>
        </li>
      </ul>
      <p>Esta t√©cnica permite que cada individuo "aprenda" o se "refine" durante su vida, combinando la exploraci√≥n global del AG con la explotaci√≥n local.</p>
    </div>
    <hr>

    <!-- Secci√≥n 6: Visualizaci√≥n Din√°mica -->
    <button class="section-toggle-button" onclick="toggleSection('lab_visualizacion', this)" aria-expanded="false" aria-controls="lab_visualizacion">
      <h2>6. Visualizaci√≥n Din√°mica del Proceso Evolutivo</h2>
    </button>
    <div id="lab_visualizacion" class="content-panel">
      <p>La visualizaci√≥n es una herramienta invaluable para entender el comportamiento de un algoritmo gen√©tico y para depurar su implementaci√≥n. Una buena visualizaci√≥n din√°mica puede mostrar en tiempo real (o por generaci√≥n):</p>
      <ul>
        <li><strong>Evoluci√≥n del Fitness:</strong> Gr√°ficos que muestren el mejor fitness y el fitness promedio de la poblaci√≥n a lo largo de las generaciones. Esto indica si el algoritmo est√° convergiendo y mejorando.</li>
        <li><strong>Diversidad Gen√©tica:</strong> M√©tricas de diversidad, como la distancia promedio de Jaccard entre los caminos de los individuos, o la entrop√≠a de la poblaci√≥n. Una ca√≠da dr√°stica en la diversidad puede se√±alar convergencia prematura.</li>
        <li><strong>Estad√≠sticas Clave:</strong> Informaci√≥n como la tasa de mutaci√≥n actual (si es adaptativa), el n√∫mero de veces que se ha activado el reseteo de poblaci√≥n, la longitud promedio de los caminos, etc.</li>
        <li><strong>Visualizaci√≥n del Laberinto y el Mejor Camino:</strong> Una representaci√≥n gr√°fica del laberinto mostrando el camino encontrado por el mejor individuo de la generaci√≥n actual. Esto permite observar visualmente c√≥mo evolucionan las estrategias de navegaci√≥n.</li>
        <li><strong>Histograma de Fitness:</strong> Para ver la distribuci√≥n de la calidad de las soluciones en la poblaci√≥n actual.</li>
      </ul>
      <p>Estas visualizaciones no solo son √∫tiles para el an√°lisis post-ejecuci√≥n, sino que tambi√©n pueden ayudar a ajustar los par√°metros del AG durante el desarrollo para optimizar su rendimiento.</p>
    </div>
    <hr>

    <!-- Secci√≥n 7: Resultados Esperados -->
    <button class="section-toggle-button" onclick="toggleSection('lab_resultados', this)" aria-expanded="false" aria-controls="lab_resultados">
      <h2>7. Resultados Esperados y Comportamiento T√≠pico</h2>
    </button>
    <div id="lab_resultados" class="content-panel">
      <p>Al aplicar un algoritmo gen√©tico bien configurado, como el descrito, a un problema de laberinto, se espera observar un patr√≥n evolutivo caracter√≠stico:</p>
      <ul>
        <li><strong>Fase Inicial (Exploraci√≥n):</strong> En las primeras generaciones, los individuos suelen ser caminos aleatorios y de baja calidad. El fitness promedio es bajo, y el mejor individuo podr√≠a estar lejos del objetivo. La diversidad es generalmente alta.</li>
        <li><strong>Fase de Convergencia R√°pida:</strong> A medida que la selecci√≥n y los operadores gen√©ticos comienzan a actuar, emergen individuos que se acercan progresivamente al objetivo. El mejor fitness y el fitness promedio suelen mejorar r√°pidamente. Pueden aparecer los primeros caminos que alcanzan la meta, aunque no sean √≥ptimos.</li>
        <li><strong>Fase de Refinamiento (Explotaci√≥n):</strong> Una vez que muchos individuos alcanzan el objetivo, la presi√≥n selectiva se enfoca en optimizar otros criterios, como la longitud del camino. Los operadores de mutaci√≥n m√°s finos y la b√∫squeda local (si est√° presente) juegan un papel importante aqu√≠. La mejora del fitness puede volverse m√°s lenta y gradual.</li>
        <li><strong>Convergencia o Estabilizaci√≥n:</strong> Eventualmente, el algoritmo puede converger a una soluci√≥n de alta calidad (posiblemente la √≥ptima o cercana a ella) o estabilizarse si no se encuentran mejoras significativas. En este punto, la diversidad de la poblaci√≥n puede ser baja si no se maneja adecuadamente.</li>
      </ul>
      <p>Se espera la aparici√≥n de caminos que no solo sean v√°lidos (sin atravesar paredes y conectando inicio y fin), sino tambi√©n optimizados en t√©rminos de longitud y sin ciclos o movimientos redundantes.</p>
    </div>
    <hr>

    <!-- Secci√≥n 8: Conclusi√≥n -->
    <button class="section-toggle-button" onclick="toggleSection('lab_conclusion', this)" aria-expanded="false" aria-controls="lab_conclusion">
      <h2>8. Conclusi√≥n e Implicaciones Futuras</h2>
    </button>
    <div id="lab_conclusion" class="content-panel">
      <p>La aplicaci√≥n de algoritmos gen√©ticos para la resoluci√≥n de laberintos demuestra ser un enfoque <strong>robusto, adaptativo y inherentemente exploratorio</strong>. Se adapta de forma natural a la naturaleza discreta de los entornos de cuadr√≠cula y a la presencia de m√∫ltiples obst√°culos y caminos posibles.</p>
      <p>La implementaci√≥n avanzada descrita, que combina los mecanismos evolutivos cl√°sicos con t√©cnicas modernas como la b√∫squeda local h√≠brida y la mutaci√≥n adaptativa, constituye un <strong>sistema h√≠brido y eficiente</strong>. Este tipo de sistema no solo es capaz de resolver eficazmente laberintos est√°ticos, sino que tambi√©n sienta las bases para abordar problemas m√°s complejos:</p>
      <ul>
        <li>Navegaci√≥n en entornos din√°micos (con obst√°culos m√≥viles).</li>
        <li>Laberintos con m√∫ltiples agentes.</li>
        <li>Mapas con caracter√≠sticas especiales como portales, llaves, o diferentes costos de terreno.</li>
        <li>Optimizaci√≥n multiobjetivo (ej. minimizar distancia y exposici√≥n a riesgos).</li>
      </ul>
      <p>Adem√°s, este enfoque abre el camino hacia la integraci√≥n con paradigmas de aprendizaje m√°s sofisticados. La combinaci√≥n de la exploraci√≥n evolutiva con pol√≠ticas de decisi√≥n aprendidas mediante <strong>aprendizaje por refuerzo (RL)</strong>, como se propone en trabajos como <em>AlphaEvolve</em>, promete la creaci√≥n de algoritmos de navegaci√≥n y resoluci√≥n de problemas a√∫n m√°s inteligentes y aut√≥nomos, capaces de aprender estrategias complejas y adaptarse a una variedad a√∫n mayor de desaf√≠os.</p>
    </div>

  </div> <!-- Fin de .container -->

  <script>
    // Funci√≥n para cambiar entre modo claro y oscuro
    function toggleTheme() {
      document.body.classList.toggle("dark-mode");
      let themeButton = document.getElementById('theme-toggle-btn');
      let isDarkMode = document.body.classList.contains("dark-mode");
      localStorage.setItem("theme", isDarkMode ? "dark" : "light");
      if (themeButton) {
          themeButton.textContent = isDarkMode ? "Modo Claro" : "Modo Oscuro";
      }
    }

    // Funci√≥n para mostrar/ocultar paneles de contenido
    function toggleSection(id, buttonElement) {
      let panel = document.getElementById(id);
      if (panel && buttonElement) {
          panel.classList.toggle('is-visible');
          let isVisible = panel.classList.contains('is-visible');
          buttonElement.setAttribute('aria-expanded', isVisible);
          buttonElement.classList.toggle('is-expanded', isVisible);
      }
    }

    // Funci√≥n que se ejecuta cuando la p√°gina carga
    window.onload = function() {
      let themeButton = document.getElementById('theme-toggle-btn');
      const savedTheme = localStorage.getItem("theme");

      if (savedTheme === "dark") {
        document.body.classList.add("dark-mode");
        if (themeButton) {
            themeButton.textContent = "Modo Claro";
        }
      } else {
        document.body.classList.remove("dark-mode");
        if (themeButton) {
            themeButton.textContent = "Modo Oscuro";
        }
      }

       document.querySelectorAll('.content-panel').forEach(panel => {
         panel.classList.remove('is-visible');
       });
       document.querySelectorAll('.section-toggle-button').forEach(button => {
          button.setAttribute('aria-expanded', 'false');
          button.classList.remove('is-expanded');
       });
    }
  </script>
</body>
</html>
"""

# Mostrar el HTML en la salida de la celda
display(HTML(html_content))

"""1,2   3,5   distancia manhatan  3-1= 2  5-2=3 cinco  , distancia euclidia 2-1=2 4  5-2=3 9 4+9 13 raiz"""

import numpy as np
import matplotlib.pyplot as plt
import matplotlib.patches as patches # Para dibujar el laberinto
import random
import seaborn as sns
import time
import math
from collections import deque
from IPython.display import display, clear_output

# --- Par√°metros Globales para Mejoras (Ajusta seg√∫n necesidad) ---
ADAPTIVE_MUT_LOW_DIVERSITY_THRESHOLD = 0.20 # Si la diversidad baja de esto
MIN_MUTATION_RATE = 0.05
MAX_MUTATION_RATE = 0.50
MUTATION_ADAPT_FACTOR_INCREASE = 1.1
MUTATION_ADAPT_FACTOR_DECREASE = 0.98

STAGNATION_FOR_RESET = 25
RESET_FRACTION = 0.3

APPLY_LOCAL_SEARCH_EVERY_N_GENS = 10
PROB_APPLY_LOCAL_SEARCH_TO_ELITE = 0.5

# Configuraci√≥n visual
plt.style.use('default')
plt.rcParams['figure.facecolor'] = 'white'
plt.rcParams['axes.facecolor'] = 'white'
plt.rcParams['savefig.facecolor'] = 'white'
plt.rcParams['font.sans-serif'] = ['DejaVu Sans', 'Verdana', 'Geneva', 'sans-serif']
sns.set_palette("husl")

class MazeEnvironment:
    """Representa el entorno del laberinto"""

    def __init__(self, maze_matrix, start_pos, end_pos):
        self.maze = np.array(maze_matrix)
        self.height, self.width = self.maze.shape
        self.start_pos = tuple(start_pos)
        self.end_pos = tuple(end_pos)

        if not (0 <= self.start_pos[0] < self.height and 0 <= self.start_pos[1] < self.width):
            raise ValueError(f"Posici√≥n de inicio {self.start_pos} fuera de los l√≠mites del laberinto {self.maze.shape}")
        if not (0 <= self.end_pos[0] < self.height and 0 <= self.end_pos[1] < self.width):
            raise ValueError(f"Posici√≥n de fin {self.end_pos} fuera de los l√≠mites del laberinto {self.maze.shape}")

        if self.maze[self.start_pos] == 1 or self.maze[self.end_pos] == 1:
            raise ValueError("Las posiciones de inicio o fin est√°n en paredes")

    def is_valid_position(self, pos):
        row, col = pos
        return (0 <= row < self.height and
                0 <= col < self.width and
                self.maze[row, col] == 0) # 0 es camino

    def get_neighbors(self, pos):
        row, col = pos; neighbors = []
        for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]: # Arriba, Abajo, Izquierda, Derecha
            new_pos = (row + dr, col + dc)
            # No es necesario chequear is_valid_position aqu√≠, se har√° donde se use
            if 0 <= new_pos[0] < self.height and 0 <= new_pos[1] < self.width:
                 neighbors.append(new_pos)
        return neighbors # Devuelve vecinos dentro de los l√≠mites, pueden ser pared o camino

    def manhattan_distance(self, pos1, pos2):
        return abs(pos1[0] - pos2[0]) + abs(pos1[1] - pos2[1])

    def euclidean_distance(self, pos1, pos2):
        return math.sqrt((pos1[0] - pos2[0])**2 + (pos1[1] - pos2[1])**2)

class GeneticMazeSolver:
    def __init__(self, maze_env, population_size=100, elite_size=20,
                 initial_mutation_rate=0.15, crossover_rate=0.8,
                 max_generations=500, animate=False, stagnation_limit=50,
                 random_seed=None, use_adaptive_mutation=True,
                 use_population_reset=True, use_local_search=True,
                 max_path_len_factor=1.5): # Factor para max_path_length

        self.random_seed = random_seed
        if self.random_seed is not None:
            random.seed(self.random_seed)
            np.random.seed(self.random_seed)

        self.maze_env = maze_env
        self.population_size = population_size
        self.elite_size = elite_size
        self.mutation_rate = initial_mutation_rate
        self.initial_mutation_rate = initial_mutation_rate
        self.crossover_rate = crossover_rate
        self.max_generations = max_generations
        self.animate = animate
        self.stagnation_limit = stagnation_limit

        self.use_adaptive_mutation = use_adaptive_mutation
        self.use_population_reset = use_population_reset
        self.use_local_search = use_local_search

        # Longitud m√°xima heur√≠stica para un camino
        self.max_path_length = int(maze_env.width * maze_env.height * max_path_len_factor)

        self.best_fitness_history = []
        self.avg_fitness_history = []
        self.diversity_history = []
        self.mutation_rate_history = []
        self.generation_times = []

        self.best_path = None
        self.best_fitness = float('-inf') # Maximizar fitness
        self.current_generation = 0
        self.generations_since_last_improvement = 0
        self.generations_since_last_reset = 0

        self.fig_dynamic = None
        self.axes_dynamic = None

    def create_individual(self):
        """Crea un individuo (camino) aleatorio, intentando ir hacia el objetivo."""
        path = [self.maze_env.start_pos]
        current_pos = self.maze_env.start_pos
        # No permitir visitar la misma celda consecutivamente en la creaci√≥n inicial
        # (excepto si es la √∫nica opci√≥n para no quedarse atascado)
        # Un set de visitados simple para la creaci√≥n del individuo actual
        current_path_visited_for_creation = {current_pos}

        for _ in range(self.max_path_length -1): # -1 porque start_pos ya est√°
            if current_pos == self.maze_env.end_pos:
                break

            potential_next_moves = []
            for neighbor_pos in self.maze_env.get_neighbors(current_pos):
                if self.maze_env.maze[neighbor_pos] == 0: # Si es camino
                    if neighbor_pos not in current_path_visited_for_creation or neighbor_pos == self.maze_env.end_pos :
                        potential_next_moves.append(neighbor_pos)

            if not potential_next_moves:
                 # Intentar retroceder si est√° atascado (simplificado)
                if len(path) > 1 and path[-2] not in current_path_visited_for_creation : # Evitar oscilaciones simples
                    next_pos = path[-2] # Retroceder un paso
                else: # No hay a d√≥nde ir o se quedar√≠a oscilando
                    break # Terminar camino
            else:
                # Selecci√≥n de siguiente movimiento con sesgo
                if random.random() < 0.8 and self.maze_env.end_pos not in potential_next_moves : # 80% heur√≠stica
                    distances = [self.maze_env.manhattan_distance(pos, self.maze_env.end_pos) for pos in potential_next_moves]
                    min_dist = min(distances)
                    best_options = [pos for i, pos in enumerate(potential_next_moves) if distances[i] == min_dist]
                    next_pos = random.choice(best_options)
                else: # 20% aleatorio
                    next_pos = random.choice(potential_next_moves)

            path.append(next_pos)
            current_path_visited_for_creation.add(next_pos) # A√±adir al set de visitados de este camino
            current_pos = next_pos
            if len(path) >= self.max_path_length: break
        return path

    def create_population(self):
        population = [self.create_individual() for _ in range(self.population_size)]
        # A√±adir una porci√≥n de individuos creados con A* o BFS si es muy dif√≠cil
        # num_heuristic = self.population_size // 10
        # for _ in range(num_heuristic):
        #     population[random.randint(0, self.population_size-1)] = self.create_a_star_individual() # Necesitar√≠as implementar esto
        return population

    def is_valid_path(self, path):
        if not path or path[0] != self.maze_env.start_pos: return False
        for i in range(len(path)):
            if self.maze_env.maze[path[i]] == 1: return False # Est√° en una pared
            if i > 0:
                if self.maze_env.manhattan_distance(path[i-1], path[i]) != 1:
                    return False # No son adyacentes
        return True

    def fitness(self, path):
        if not path or len(path) == 0 or not self.is_valid_path(path):
            return -100000 # Penalizaci√≥n muy alta para inv√°lidos

        path_len = len(path)
        unique_cells = len(set(path))

        # Penalizaci√≥n por longitud excesiva
        length_penalty = 0
        if path_len > self.max_path_length:
             length_penalty = (path_len - self.max_path_length) * 50

        # Penalizaci√≥n por bucles (visitar la misma celda muchas veces)
        loop_penalty = (path_len - unique_cells) * 20

        # Distancia al objetivo desde el √∫ltimo punto del camino
        last_pos = path[-1]
        dist_to_goal = self.maze_env.manhattan_distance(last_pos, self.maze_env.end_pos)

        # Fitness base
        # Queremos maximizar, as√≠ que valores m√°s altos son mejores.
        # Damos una gran recompensa por alcanzar el objetivo.
        # Penalizamos la distancia al objetivo y la longitud del camino.

        fitness_score = 10000.0 # Base alta

        if last_pos == self.maze_env.end_pos:
            fitness_score += 50000 # Gran recompensa por llegar
            # Si llega, la longitud del camino es el factor principal de desempate (menor es mejor)
            fitness_score -= path_len * 10 # Penalizar caminos m√°s largos
        else:
            # Si no llega, penalizar fuertemente la distancia al objetivo
            fitness_score -= dist_to_goal * 100
            fitness_score -= path_len # Penalizar tambi√©n la longitud

        fitness_score -= loop_penalty
        fitness_score -= length_penalty

        # Evitar que el fitness sea demasiado negativo si las penalizaciones son enormes
        return max(fitness_score, -90000)


    def selection(self, population, fitnesses): # Torneo
        selected = []
        pop_size = len(population)
        for _ in range(pop_size):
            tournament_size = min(5, pop_size)
            if tournament_size == 0: continue
            tournament_indices = random.sample(range(pop_size), tournament_size)
            winner_idx = max(tournament_indices, key=lambda i: fitnesses[i])
            selected.append(population[winner_idx][:]) # Copia del camino
        return selected

    def crossover(self, parent1, parent2):
        """Crossover de un punto para caminos, intentando mantener la validez."""
        if random.random() > self.crossover_rate or min(len(parent1), len(parent2)) < 2:
            return parent1[:], parent2[:]

        # Intentar encontrar un punto de cruce com√∫n si es posible
        # Esto es m√°s complejo para caminos que para permutaciones
        # Por simplicidad, usaremos un cruce de un punto y luego reparamos.

        len1, len2 = len(parent1), len(parent2)

        # Punto de cruce aleatorio en el padre m√°s corto
        cx_point1 = random.randint(1, len1 -1) if len1 > 1 else 0
        cx_point2 = random.randint(1, len2 -1) if len2 > 1 else 0

        child1 = parent1[:cx_point1] + parent2[cx_point2:]
        child2 = parent2[:cx_point2] + parent1[cx_point1:]

        child1 = self.repair_path_simple(child1)
        child2 = self.repair_path_simple(child2)

        return child1, child2

    def repair_path_simple(self, path):
        """Reparaci√≥n simple: asegurar que empieza bien y eliminar pasos inv√°lidos."""
        if not path or path[0] != self.maze_env.start_pos:
            return self.create_individual() # Si es muy malo, generar uno nuevo

        repaired_path = [self.maze_env.start_pos]
        for i in range(1, len(path)):
            if len(repaired_path) >= self.max_path_length: break

            current_node = path[i]
            prev_node = repaired_path[-1]

            if self.maze_env.maze[current_node] == 0 and \
               self.maze_env.manhattan_distance(prev_node, current_node) == 1:
                repaired_path.append(current_node)
            else:
                # Si el paso es inv√°lido, intentar conectar desde el √∫ltimo v√°lido
                # al siguiente v√°lido del camino original, o simplemente terminar
                # Para esta reparaci√≥n simple, podemos simplemente truncar o intentar
                # encontrar un vecino v√°lido del √∫ltimo punto v√°lido.
                # Por ahora, si es inv√°lido, no lo a√±adimos.
                # Si el camino se vuelve demasiado corto, create_individual lo arreglar√°.
                pass

        # Si el camino resultante es demasiado corto o no v√°lido, generar uno nuevo
        if len(repaired_path) < 2 or not self.is_valid_path(repaired_path):
            return self.create_individual()

        return repaired_path


    def mutate(self, path): # Mutaci√≥n adaptada para caminos
        if random.random() > self.mutation_rate or len(path) < 2:
            return path[:]

        mutated_path = path[:]
        mutation_type = random.choice(['add_step', 'remove_step', 'change_segment', 'optimize_segment_simple'])

        if mutation_type == 'add_step' and len(mutated_path) < self.max_path_length:
            # A√±adir un paso aleatorio en un punto aleatorio
            if len(mutated_path) > 1:
                idx = random.randint(0, len(mutated_path) - 2) # Punto antes del cual insertar
                node_before = mutated_path[idx]
                potential_next_steps = [n for n in self.maze_env.get_neighbors(node_before) if self.maze_env.maze[n] == 0]
                if potential_next_steps:
                    new_step = random.choice(potential_next_steps)
                    # Verificar si el nuevo paso conecta con el siguiente
                    node_after = mutated_path[idx+1]
                    if self.maze_env.manhattan_distance(new_step, node_after) == 1:
                         mutated_path.insert(idx + 1, new_step)

        elif mutation_type == 'remove_step' and len(mutated_path) > 2:
            # Eliminar un paso aleatorio (que no sea inicio o fin si ya lleg√≥)
            idx_to_remove = random.randint(1, len(mutated_path) - 2)
            node_before = mutated_path[idx_to_remove-1]
            node_after = mutated_path[idx_to_remove+1]
            # Si al quitar el nodo, el anterior y el siguiente son adyacentes, se puede quitar
            if self.maze_env.manhattan_distance(node_before, node_after) == 1:
                mutated_path.pop(idx_to_remove)

        elif mutation_type == 'change_segment' and len(mutated_path) > 3:
            # Reemplazar un peque√±o segmento por uno nuevo aleatorio
            start_idx = random.randint(1, len(mutated_path) - 3)
            end_idx = min(start_idx + random.randint(1,3), len(mutated_path) -1)

            segment_start_node = mutated_path[start_idx-1]
            segment_end_node = mutated_path[end_idx]

            # Generar un nuevo segmento corto
            temp_current = segment_start_node
            new_segment_part = []
            visited_in_segment = {temp_current}
            for _ in range(random.randint(1,5)): # Longitud del nuevo segmento
                if temp_current == segment_end_node: break
                potential_next = [n for n in self.maze_env.get_neighbors(temp_current) if self.maze_env.maze[n]==0 and n not in visited_in_segment]
                if not potential_next: break
                next_node = random.choice(potential_next)
                new_segment_part.append(next_node)
                visited_in_segment.add(next_node)
                temp_current = next_node

            # Solo reemplazar si el nuevo segmento conecta con el final del segmento original
            if new_segment_part and new_segment_part[-1] == segment_end_node:
                 mutated_path = mutated_path[:start_idx] + new_segment_part + mutated_path[end_idx+1:]
            elif new_segment_part and self.maze_env.manhattan_distance(new_segment_part[-1], segment_end_node) == 1:
                 mutated_path = mutated_path[:start_idx] + new_segment_part + [segment_end_node] + mutated_path[end_idx+1:]


        elif mutation_type == 'optimize_segment_simple' and len(mutated_path) > 3:
            # Intenta acortar un segmento si es posible (BFS simple)
             idx1 = random.randint(0, len(mutated_path) - 3)
             idx2 = random.randint(idx1 + 2, len(mutated_path) -1)
             node1, node2 = mutated_path[idx1], mutated_path[idx2]

             q = deque([(node1, [node1])])
             visited_bfs = {node1}
             shortest_subpath = None

             while q:
                 curr, p = q.popleft()
                 if len(p) > (idx2 - idx1) + 2 : continue # No buscar caminos mucho m√°s largos
                 if curr == node2:
                     if shortest_subpath is None or len(p) < len(shortest_subpath):
                         shortest_subpath = p
                     # No break, buscar todos los caminos de esta longitud

                 for neighbor in self.maze_env.get_neighbors(curr):
                     if self.maze_env.maze[neighbor] == 0 and neighbor not in visited_bfs:
                         visited_bfs.add(neighbor)
                         q.append((neighbor, p + [neighbor]))

             if shortest_subpath and len(shortest_subpath) < (idx2 - idx1 + 1):
                 mutated_path = mutated_path[:idx1] + shortest_subpath + mutated_path[idx2+1:]

        return self.repair_path_simple(mutated_path)


    def local_search(self, path): # B√∫squeda local simple
        """Intenta peque√±as mejoras en el camino."""
        # Esta es una versi√≥n muy simplificada. Podr√≠as usar A* o BFS para optimizar segmentos.
        # Por ahora, intentaremos eliminar redundancias.
        if not path: return path

        # Eliminar loops simples
        new_path = [path[0]]
        visited_in_ls = {path[0]}
        for i in range(1, len(path)):
            node = path[i]
            # Si el nodo ya fue visitado Y no es el paso anterior (evitar quitar zig-zags v√°lidos)
            # Y si al quitarlo el anterior y el siguiente siguen conectados
            if node in visited_in_ls and node != new_path[-1]:
                # Intentar encontrar un camino m√°s corto si se forma un loop
                # Esto es complejo. Por ahora, solo evitar a√±adir si crea un loop inmediato.
                # O si el √∫ltimo nodo es el mismo que el actual, estamos en un loop de 2.
                # Simplificaci√≥n: si el nodo ya est√° y no es el anterior, es un loop.
                # No, esto es muy agresivo.
                # Vamos a buscar si A -> B -> C -> B -> D se puede convertir en A -> B -> D

                # La forma m√°s simple de quitar loops es iterar y si path[i] == path[j] con i < j,
                # quitar path[i+1...j]. Haremos esto en una funci√≥n separada.
                pass # Placeholder, remove_redundant_segments lo har√° mejor

            if self.maze_env.manhattan_distance(new_path[-1], node) == 1 and self.maze_env.maze[node]==0 :
                 new_path.append(node)
                 visited_in_ls.add(node)
            # Si no, el camino se rompe. No hacer nada aqu√≠, repair se encargar√°.

        return self.remove_redundant_segments_robust(new_path)


    def remove_redundant_segments_robust(self, path):
        if len(path) < 3: return path

        made_change = True
        while made_change:
            made_change = False
            i = 0
            temp_path = path[:] # Trabajar sobre una copia en cada iteraci√≥n del while

            while i < len(temp_path) -1:
                current_node_scan = temp_path[i]
                # Buscar si current_node_scan aparece m√°s adelante
                try:
                    # find a j > i such that temp_path[j] == current_node_scan
                    future_occurrence_idx = temp_path.index(current_node_scan, i + 1)
                    # Si se encuentra, tenemos un loop: temp_path[i...future_occurrence_idx]
                    # El segmento a eliminar es temp_path[i+1...future_occurrence_idx]
                    temp_path = temp_path[:i+1] + temp_path[future_occurrence_idx+1:]
                    made_change = True
                    # No incrementar i, ya que el path ha cambiado, re-escanear desde este punto
                    # o mejor, romper y reiniciar el while externo si hubo cambio.
                    break # Romper el bucle while i < ...
                except ValueError:
                    # No se encontr√≥ m√°s adelante, avanzar i
                    i += 1

            path = temp_path # Actualizar el path principal
            if made_change: # Si hubo un cambio, el bucle while externo se repetir√°
                continue

        return path


    def calculate_diversity(self, population): # Mantenemos tu Jaccard, es buena idea
        if not population or len(population) < 2: return 0.0
        sample_size = min(len(population), 30)
        sample_indices = random.sample(range(len(population)), sample_size)
        total_distance, num_comparisons = 0, 0
        for i in range(len(sample_indices)):
            for j in range(i + 1, len(sample_indices)):
                s1, s2 = set(population[sample_indices[i]]), set(population[sample_indices[j]])
                intersection, union = len(s1.intersection(s2)), len(s1.union(s2))
                total_distance += (1.0 - (intersection / union)) if union > 0 else 0.0
                num_comparisons += 1
        return total_distance / num_comparisons if num_comparisons > 0 else 0.0

    def draw_maze(self, ax):
        ax.imshow(self.maze_env.maze, cmap='binary', origin='lower', interpolation='nearest')
        # Dibujar inicio y fin
        start_patch = patches.Rectangle((self.maze_env.start_pos[1]-0.5, self.maze_env.start_pos[0]-0.5), 1, 1, linewidth=2, edgecolor='g', facecolor='lightgreen', alpha=0.7)
        end_patch = patches.Rectangle((self.maze_env.end_pos[1]-0.5, self.maze_env.end_pos[0]-0.5), 1, 1, linewidth=2, edgecolor='r', facecolor='salmon', alpha=0.7)
        ax.add_patch(start_patch)
        ax.add_patch(end_patch)
        ax.set_xticks(np.arange(-.5, self.maze_env.width, 1), minor=True)
        ax.set_yticks(np.arange(-.5, self.maze_env.height, 1), minor=True)
        ax.grid(which="minor", color="grey", linestyle='-', linewidth=0.5, alpha=0.3)
        ax.tick_params(which="minor", size=0)
        ax.set_xticks([])
        ax.set_yticks([])

    def draw_path(self, ax, path, color='blue', lw=2, alpha=0.8):
        self.draw_maze(ax) # Dibujar el laberinto base
        if not path: return

        path_y = [p[0] for p in path] # Filas son Y
        path_x = [p[1] for p in path] # Columnas son X
        ax.plot(path_x, path_y, color=color, linewidth=lw, alpha=alpha, marker='o', markersize=lw*2)
        # Marcar el inicio y fin del camino dibujado
        if path:
            ax.plot(path_x[0], path_y[0], 'go', markersize=lw*3, label='Path Start') # Verde para inicio del camino
            ax.plot(path_x[-1], path_y[-1], 'ro', markersize=lw*3, label='Path End') # Rojo para fin del camino

    def setup_dynamic_visualization(self): # Tu implementaci√≥n es buena
        if not self.animate: return
        if self.fig_dynamic is not None and plt.fignum_exists(self.fig_dynamic.number): plt.close(self.fig_dynamic)
        self.fig_dynamic, self.axes_dynamic = plt.subplots(2, 3, figsize=(20, 12)) # Ajustado
        self.fig_dynamic.patch.set_facecolor('white')
        titles = ['Laberinto Base', 'Mejor Camino Actual', 'Evoluci√≥n Fitness', 'Top 5 Fitness', 'Diversidad', 'Estad√≠sticas']
        for i, ax in enumerate(self.axes_dynamic.flat):
            ax.set_title(titles[i], fontsize=12, fontweight='bold'); ax.set_facecolor('#f8f8f8')
        plt.tight_layout(rect=[0, 0, 1, 0.95])

    def update_dynamic_visualization(self, population, fitnesses): # COMPLETADO
        if not self.animate or self.axes_dynamic is None or self.fig_dynamic is None: return
        clear_output(wait=True)

        title_suffix = ""
        if self.best_path and self.best_path[-1] == self.maze_env.end_pos:
            title_suffix = f" - SOLUCIONADO! (Len: {len(self.best_path)})"
        main_title = f'Maze Solver (Gen {self.current_generation}{title_suffix})'
        self.fig_dynamic.suptitle(main_title, fontsize=14, fontweight='bold')

        for ax_idx, ax in enumerate(self.axes_dynamic.flat):
            ax.clear()
            titles = ['Laberinto Base', 'Mejor Camino Actual', 'Evoluci√≥n Fitness', 'Top 5 Fitness', 'Diversidad', 'Estad√≠sticas']
            if ax_idx < len(titles): ax.set_title(titles[ax_idx], fontsize=12, fontweight='bold'); ax.set_facecolor('#f8f8f8')

        self.draw_maze(self.axes_dynamic[0,0]) # Laberinto base
        if self.best_path: self.draw_path(self.axes_dynamic[0,1], self.best_path, color='dodgerblue', lw=2.5) # Mejor camino
        else: self.draw_maze(self.axes_dynamic[0,1]); self.axes_dynamic[0,1].text(0.5,0.5,"Buscando...", ha='center', va='center', transform=self.axes_dynamic[0,1].transAxes)

        if len(self.best_fitness_history) > 1: # Evoluci√≥n Fitness
            ax_fit = self.axes_dynamic[0,2]; gens = range(len(self.best_fitness_history))
            ax_fit.plot(gens, self.best_fitness_history, 'g-', lw=2, label='Mejor Fitness')
            ax_fit.plot(gens, self.avg_fitness_history, 'b--', lw=1.5, label='Fitness Prom.')
            ax_fit.set_xlabel('Generaci√≥n'); ax_fit.set_ylabel('Fitness'); ax_fit.legend(); ax_fit.grid(True, ls=':', alpha=0.7)

        if fitnesses and population: # Top 5 Fitness
            ax_top = self.axes_dynamic[1,0]; sorted_indices = np.argsort(fitnesses)[::-1]; top_n = min(5, len(population))
            top_fits = [fitnesses[i] for i in sorted_indices[:top_n]]
            paths_lens = [len(population[i]) for i in sorted_indices[:top_n]]
            bar_labels = [f'#{i+1}\n(L:{paths_lens[i]})' for i in range(top_n)]
            bars = ax_top.bar(range(top_n), top_fits, color=sns.color_palette("coolwarm", n_colors=top_n))
            ax_top.set_xticks(range(top_n)); ax_top.set_xticklabels(bar_labels, fontsize=8)
            ax_top.set_xlabel('Ranking (Longitud)'); ax_top.set_ylabel('Fitness'); ax_top.grid(axis='y', ls=':', alpha=0.7)
            for bar_idx, bar in enumerate(bars): ax_top.text(bar.get_x() + bar.get_width()/2., bar.get_height(), f'{top_fits[bar_idx]:.0f}', ha='center', va='bottom', fontsize=8)

        if len(self.diversity_history) > 1: # Diversidad
            ax_div = self.axes_dynamic[1,1]; ax_div.plot(range(len(self.diversity_history)), self.diversity_history, 'r-', lw=2, label='Diversidad')
            ax_div.set_xlabel('Generaci√≥n'); ax_div.set_ylabel('Diversidad (Jaccard)'); ax_div.grid(True, ls=':', alpha=0.7); ax_div.set_ylim(0, 1)
            if self.use_adaptive_mutation and len(self.mutation_rate_history) > 1:
                ax_mut = ax_div.twinx(); ax_mut.plot(range(len(self.mutation_rate_history)), self.mutation_rate_history, 'm:', lw=1.5, label='Tasa Mut.')
                ax_mut.set_ylabel('Tasa Mutaci√≥n', color='m'); ax_mut.tick_params(axis='y', labelcolor='m')
                lines, labels = ax_div.get_legend_handles_labels(); lines2, labels2 = ax_mut.get_legend_handles_labels()
                ax_div.legend(lines + lines2, labels + labels2, loc='best', fontsize='small')

        ax_stats = self.axes_dynamic[1,2]; ax_stats.axis('off') # Estad√≠sticas
        if fitnesses and population:
            time_gen_str = f"T/Gen: {self.generation_times[-1]:.3f}s" if self.generation_times else "N/A"; stag_str = f"Estanc: {self.generations_since_last_improvement}/{self.stagnation_limit}"
            current_diversity_val = self.diversity_history[-1] if self.diversity_history else "N/A"; div_display_str = f"{current_diversity_val:.3f}" if isinstance(current_diversity_val, float) else current_diversity_val
            mut_rate_str = f"MutR: {self.mutation_rate:.3f}" if self.use_adaptive_mutation else ""
            best_path_len_str = f"Mejor L: {len(self.best_path)}" if self.best_path else "N/A"
            stats_text = (f"Gen: {self.current_generation}/{self.max_generations} ({stag_str})\nPob: {len(population)}\nMejor Fit: {self.best_fitness:.0f}\n{best_path_len_str}\nDiv: {div_display_str} {mut_rate_str}\n{time_gen_str}")
        else: stats_text = "Calculando..."
        ax_stats.text(0.05, 0.95, stats_text, transform=ax_stats.transAxes, fontsize=9, va='top', fontfamily='monospace', bbox=dict(boxstyle="round,pad=0.3", fc="#eef", alpha=0.8))

        plt.tight_layout(rect=[0, 0, 1, 0.95]); display(self.fig_dynamic)

    def evolve(self, verbose=True): # M√âTODO EVOLVE PRINCIPAL
        if self.animate: self.setup_dynamic_visualization()

        self.mutation_rate = self.initial_mutation_rate
        population = self.create_population()
        fitnesses = [self.fitness(ind) for ind in population]

        best_idx_current_gen = np.argmax(fitnesses)
        self.best_fitness = fitnesses[best_idx_current_gen]
        self.best_path = population[best_idx_current_gen][:]

        self.best_fitness_history.append(self.best_fitness)
        self.avg_fitness_history.append(np.mean([f for f in fitnesses if f > -100000])) # Evitar inv√°lidos en promedio
        self.diversity_history.append(self.calculate_diversity(population))
        if self.use_adaptive_mutation: self.mutation_rate_history.append(self.mutation_rate)
        if verbose: print(f"Gen 0: MejorFit={self.best_fitness:.0f}, Len={len(self.best_path)}, MutR={self.mutation_rate:.3f}")

        if self.animate: self.update_dynamic_visualization(population, fitnesses); time.sleep(0.1)

        for generation in range(1, self.max_generations + 1):
            self.current_generation = generation; start_time_gen = time.time()
            self.generations_since_last_reset += 1

            parents = self.selection(population, fitnesses)

            elite_indices = np.argsort(fitnesses)[-self.elite_size:]
            next_population = [population[i][:] for i in elite_indices]

            if self.use_local_search and \
               (generation % APPLY_LOCAL_SEARCH_EVERY_N_GENS == 0 or \
                (self.generations_since_last_improvement > self.stagnation_limit // 2 and \
                 random.random() < PROB_APPLY_LOCAL_SEARCH_TO_ELITE)):
                if verbose and generation > 0: print(f"  LS: Aplicando b√∫squeda local a √©lite gen {generation}")
                for i in range(len(next_population)):
                    next_population[i] = self.local_search(next_population[i]) # Usar local_search

            children_needed = self.population_size - len(next_population)
            children_created = 0
            while children_created < children_needed :
                p1, p2 = random.sample(parents, 2)
                c1, c2 = self.crossover(p1, p2)
                next_population.append(self.mutate(c1)); children_created +=1
                if children_created < children_needed:
                    next_population.append(self.mutate(c2)); children_created +=1

            population = next_population[:self.population_size]
            fitnesses = [self.fitness(ind) for ind in population]

            best_idx_current_gen = np.argmax(fitnesses)
            current_gen_best_fitness = fitnesses[best_idx_current_gen]

            if current_gen_best_fitness > self.best_fitness:
                self.best_fitness = current_gen_best_fitness
                self.best_path = population[best_idx_current_gen][:]
                self.generations_since_last_improvement = 0
                if verbose: print(f"‚ú® Gen {generation}: MejorFit={self.best_fitness:.0f}, Len={len(self.best_path)}")
                if self.best_path[-1] == self.maze_env.end_pos: # Soluci√≥n encontrada
                    if verbose: print(f"üéâ SOLUCI√ìN ENCONTRADA en gen {generation}!")
                    if self.animate: self.update_dynamic_visualization(population, fitnesses)
                    # Podr√≠as a√±adir un criterio de parada aqu√≠ si se encuentra la soluci√≥n
                    # return self.best_path, self.best_fitness
            else:
                self.generations_since_last_improvement += 1

            current_diversity = self.calculate_diversity(population)
            self.diversity_history.append(current_diversity)

            if self.use_adaptive_mutation:
                if current_diversity < ADAPTIVE_MUT_LOW_DIVERSITY_THRESHOLD and self.mutation_rate < MAX_MUTATION_RATE:
                    self.mutation_rate = min(MAX_MUTATION_RATE, self.mutation_rate * MUTATION_ADAPT_FACTOR_INCREASE)
                elif self.mutation_rate > self.initial_mutation_rate and self.generations_since_last_improvement < 10:
                    self.mutation_rate = max(self.initial_mutation_rate, self.mutation_rate * MUTATION_ADAPT_FACTOR_DECREASE)
                self.mutation_rate_history.append(self.mutation_rate)

            self.best_fitness_history.append(self.best_fitness)
            self.avg_fitness_history.append(np.mean([f for f in fitnesses if f > -100000]))
            self.generation_times.append(time.time() - start_time_gen)

            if self.use_population_reset and \
               self.generations_since_last_improvement > STAGNATION_FOR_RESET and \
               self.generations_since_last_reset > STAGNATION_FOR_RESET :
                if verbose: print(f"  RESET: Reseteo parcial gen {generation}.")
                num_to_reset = int(self.population_size * RESET_FRACTION)
                elite_now = [population[i][:] for i in np.argsort(fitnesses)[-self.elite_size:]]
                reset_pop = elite_now
                for _ in range(self.population_size - len(reset_pop)): # Rellenar
                    reset_pop.append(self.create_individual())
                population = reset_pop[:self.population_size]
                fitnesses = [self.fitness(ind) for ind in population]
                self.generations_since_last_reset = 0
                self.diversity_history[-1] = self.calculate_diversity(population)
                if self.use_adaptive_mutation: self.mutation_rate = self.initial_mutation_rate; self.mutation_rate_history[-1] = self.mutation_rate

            if self.animate and (generation % 2 == 0 or generation == self.max_generations or self.generations_since_last_improvement >= self.stagnation_limit-1 or (self.best_path and self.best_path[-1] == self.maze_env.end_pos)):
                self.update_dynamic_visualization(population, fitnesses)

            if self.best_path and self.best_path[-1] == self.maze_env.end_pos and self.generations_since_last_improvement > 10: # Si encontr√≥ soluci√≥n y no mejora m√°s
                if verbose: print(f"Soluci√≥n encontrada y estable. Terminando en gen {generation}.")
                break

            if self.generations_since_last_improvement >= self.stagnation_limit:
                if verbose: print(f"Estancamiento gen {generation}. Sin mejora {self.stagnation_limit} gens.")
                if self.animate and self.fig_dynamic: self.fig_dynamic.suptitle(f'ESTANCAMIENTO (Gen {generation})', fontsize=16, color='red', fontweight='bold'); display(self.fig_dynamic)
                break

            if verbose and (generation % 10 == 0 or generation == self.max_generations):
                 div_str = f"{self.diversity_history[-1]:.3f}" if self.diversity_history else "N/A"
                 mut_str = f"MutR:{self.mutation_rate:.3f}" if self.use_adaptive_mutation else ""
                 print(f"Gen {generation:3d}: BestFit={self.best_fitness:.0f} (L:{len(self.best_path) if self.best_path else 'N/A'}) AvgFit={self.avg_fitness_history[-1]:.0f} Div={div_str} {mut_str} Stagn={self.generations_since_last_improvement}")

        if verbose: print(f"Evoluci√≥n finalizada. Mejor Fitness: {self.best_fitness:.2f}, Longitud del camino: {len(self.best_path) if self.best_path else 'N/A'}")
        return self.best_path, self.best_fitness

# --- Ejemplo de Uso ---
if __name__ == '__main__': # Para ejecutar como script, o quitar para celda de Colab
    # Definir un laberinto (0 = camino, 1 = pared)
    maze_data = [
        [0, 1, 0, 0, 0, 1, 0, 0, 0, 0],
        [0, 1, 0, 1, 0, 1, 0, 1, 1, 0],
        [0, 0, 0, 1, 0, 0, 0, 1, 0, 0],
        [0, 1, 1, 1, 1, 1, 0, 1, 0, 1],
        [0, 0, 0, 0, 0, 1, 0, 0, 0, 0],
        [1, 1, 1, 1, 0, 1, 1, 1, 1, 0],
        [0, 0, 0, 1, 0, 0, 0, 0, 1, 0],
        [0, 1, 0, 1, 0, 1, 0, 1, 1, 0],
        [0, 1, 0, 0, 0, 1, 0, 0, 0, 0],
        [0, 0, 0, 1, 1, 1, 1, 1, 1, 0]
    ]
    start = (0,0)
    end = (9,9)

    # maze_data = [ # Laberinto m√°s peque√±o
    #     [0,0,0,1,0],
    #     [0,1,0,0,0],
    #     [0,1,1,1,0],
    #     [0,0,0,0,0],
    # ]
    # start = (0,0)
    # end = (3,4)


    maze_env = MazeEnvironment(maze_data, start, end)

    # Par√°metros del AG
    ga_params = {
        'population_size': 150,
        'elite_size': 25,
        'initial_mutation_rate': 0.10,
        'crossover_rate': 0.85,
        'max_generations': 100, # Reducir para pruebas r√°pidas
        'animate': True,
        'stagnation_limit': 30,
        'random_seed': 42,
        'use_adaptive_mutation': True,
        'use_population_reset': True,
        'use_local_search': True,
        'max_path_len_factor': 2.0 # Permitir caminos m√°s largos inicialmente
    }

    solver = GeneticMazeSolver(maze_env, **ga_params)

    print("Iniciando solucionador gen√©tico de laberintos...")
    best_path_found, best_fitness_found = solver.evolve(verbose=True)

    if best_path_found:
        print(f"\nMejor camino encontrado (Fitness: {best_fitness_found:.2f}):")
        # print(best_path_found)
        print(f"Longitud del camino: {len(best_path_found)}")
        if best_path_found[-1] == maze_env.end_pos:
            print("¬°El camino LLEGA al objetivo!")
        else:
            print("El camino NO LLEGA al objetivo.")
            print(f"√öltima posici√≥n: {best_path_found[-1]}, Objetivo: {maze_env.end_pos}")


        # Visualizaci√≥n final est√°tica si no hubo animaci√≥n o para tenerla aparte
        if not ga_params['animate'] or (solver.fig_dynamic is None):
            fig_final, ax_final = plt.subplots(figsize=(8,8))
            solver.draw_path(ax_final, best_path_found, color='red', lw=3)
            ax_final.set_title(f"Mejor Camino Encontrado (Fitness: {best_fitness_found:.0f}, Longitud: {len(best_path_found)})")
            plt.show()
    else:
        print("No se encontr√≥ ning√∫n camino.")



# Importar las funciones necesarias de IPython para mostrar HTML
from IPython.core.display import display, HTML

# Definir el contenido HTML, CSS y JavaScript como un string multil√≠nea
html_content = """
<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>AlphaEvolve: Descubrimiento Cient√≠fico y Algor√≠tmico</title>
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&family=Lora:ital,wght@0,400;0,700&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg-color: #f8f9fa;
      --text-color: #343a40;
      --header-color: #0056b3;
      --header-dark-color: #90c5ff;
      --accent-color: #28a745;
      --accent-dark-color: #73c888;
      --button-bg: #007bff;
      --button-hover-bg: #0056b3;
      --button-dark-bg: #ff8c00;
      --button-dark-hover-bg: #cc7000;
      --button-text-color: white;
      --theme-button-bg: #6c757d;
      --theme-button-dark-bg: #ffc107;
      --content-panel-bg: #e9ecef;
      --content-panel-dark-bg: #495057;
      --section-title-color: var(--header-color);
      --section-title-dark-color: var(--header-dark-color);
      --panel-label-color: var(--accent-color);
      --panel-label-dark-color: var(--accent-dark-color);
      --icon-color: var(--accent-color);
      --icon-dark-color: var(--accent-dark-color);
    }

    body {
      font-family: 'Lora', 'Roboto', serif;
      line-height: 1.8;
      background-color: var(--bg-color);
      color: var(--text-color);
      transition: background-color 0.3s, color 0.3s;
      padding: 20px;
      margin: 0;
    }
    .container {
      max-width: 1000px;
      margin: auto;
      padding: 25px;
      position: relative;
      background-color: var(--bg-color); /* Hereda del body para transiciones */
      border-radius: 8px;
      box-shadow: 0 3px 8px rgba(0,0,0,0.06);
    }
    body.dark-mode .container {
        box-shadow: 0 3px 10px rgba(0,0,0,0.2);
    }
    body.dark-mode {
      --bg-color: #343a40;
      --text-color: #f8f9fa;
      --header-color: var(--header-dark-color);
      --accent-color: var(--accent-dark-color);
      --button-bg: var(--button-dark-bg);
      --button-hover-bg: var(--button-dark-hover-bg);
      --content-panel-bg: var(--content-panel-dark-bg);
      --section-title-color: var(--section-title-dark-color);
      --panel-label-color: var(--panel-label-dark-color);
      --icon-color: var(--icon-dark-color);
    }

    h1 {
      font-family: 'Roboto', sans-serif;
      font-size: 2.4em;
      color: var(--header-color);
      text-align: center;
      margin-bottom: 30px;
    }
    h2.section-group-title {
        font-family: 'Roboto', sans-serif;
        font-size: 1.6em;
        color: var(--accent-color);
        margin-top: 35px;
        margin-bottom: 10px;
        border-bottom: 2px solid var(--accent-color);
        padding-bottom: 5px;
    }

    .content-panel {
      max-height: 0;
      overflow: hidden;
      transition: max-height 0.4s ease-out, padding 0.4s ease-out;
      margin-top: 0;
      padding: 0 25px; /* Se aplica cuando est√° visible */
      border-left: 4px solid var(--accent-color);
      background-color: var(--content-panel-bg);
      border-radius: 0 0 6px 6px;
    }
    .content-panel.is-visible {
      max-height: 5000px; /* Un valor grande para acomodar contenido variable */
      padding: 20px 25px;
    }
    .content-panel p, .content-panel ul, .content-panel ol {
        margin-bottom: 1.2em;
        font-size: 1.0em;
    }
    .content-panel strong.panel-label {
        color: var(--panel-label-color);
        font-family: 'Roboto', sans-serif;
        font-size: 1.1em;
        display: block;
        margin-bottom: 0.5em;
    }
    .content-panel h3 {
        font-family: 'Roboto', sans-serif;
        color: var(--section-title-color);
        font-size: 1.3em;
        margin-top: 1.5em;
        margin-bottom: 0.7em;
    }


    .section-toggle-button {
      background-color: var(--button-bg);
      color: var(--button-text-color);
      border: none;
      padding: 14px 20px;
      border-radius: 6px;
      cursor: pointer;
      margin-top: 10px;
      transition: background-color 0.3s, border-radius 0.2s;
      width: 100%;
      text-align: left;
      font-family: 'Roboto', sans-serif;
      font-size: 1.1em;
      font-weight: 700;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }
    .section-toggle-button:hover {
      background-color: var(--button-hover-bg);
    }
    .section-toggle-button.is-expanded {
        border-radius: 6px 6px 0 0;
    }
    .section-toggle-button .icon {
        margin-right: 10px;
        font-size: 0.9em;
        color: var(--button-text-color); /* Ajustado para contraste con bot√≥n */
        transition: transform 0.3s ease-out;
    }
    .section-toggle-button.is-expanded .icon {
        transform: rotate(90deg);
    }


    .theme-toggle {
      background-color: var(--theme-button-bg);
      color: white;
      border: none;
      padding: 10px 15px;
      border-radius: 6px;
      cursor: pointer;
      position: absolute;
      top: 25px;
      right: 25px;
      font-size: 0.9em;
      font-family: 'Roboto', sans-serif;
      transition: background-color 0.3s;
      z-index: 10;
    }
    body.dark-mode .theme-toggle {
       background-color: var(--theme-button-dark-bg);
       color: var(--text-color); /* Para contraste en modo oscuro */
    }

    button:focus, a:focus {
        outline: 2px solid var(--accent-color);
        outline-offset: 3px;
    }
    body.dark-mode button:focus, body.dark-mode a:focus {
         outline-color: var(--accent-dark-color);
    }
    ul, ol {
        padding-left: 30px;
    }
    li {
        margin-bottom: 0.7em;
    }
    strong {
        font-weight: 700;
    }
    code {
      background-color: rgba(0,0,0,0.05);
      padding: 2px 5px;
      border-radius: 4px;
      font-family: 'Courier New', Courier, monospace;
    }
    body.dark-mode code {
      background-color: rgba(255,255,255,0.1);
    }
  </style>
</head>
<body>
  <div class="container">
    <button id="theme-toggle-btn" class="theme-toggle" onclick="toggleTheme()" title="Cambiar tema de color">Modo Oscuro</button>

    <h1>AlphaEvolve: Un Agente de Evoluci√≥n de C√≥digo para el Descubrimiento Cient√≠fico y Algor√≠tmico</h1>

    <!-- Introducci√≥n -->
    <button class="section-toggle-button" onclick="toggleSection('s0', this)" aria-expanded="false" aria-controls="s0">
      <span>Introducci√≥n</span><span class="icon">‚ñ∫</span>
    </button>
    <div id="s0" class="content-panel">
      <p>El desarrollo de nuevos conocimientos cient√≠ficos y la creaci√≥n de algoritmos cada vez m√°s eficientes representan desaf√≠os cruciales y persistentes en la computaci√≥n moderna y la investigaci√≥n cient√≠fica. AlphaEvolve, una innovadora propuesta de Google DeepMind, emerge como una herramienta de vanguardia que marca un avance significativo en este campo. Su poder reside en la <strong>sinergia entre modelos de lenguaje de gran escala (LLMs) de √∫ltima generaci√≥n y robustas t√©cnicas de computaci√≥n evolutiva</strong>, orientadas a la automatizaci√≥n de la mejora y el descubrimiento de c√≥digo. Este sistema no solo refina algoritmos existentes, sino que tiene la capacidad de generar soluciones algor√≠tmicas novedosas, posicion√°ndose como un agente de descubrimiento con un potencial transformador. AlphaEvolve est√° espec√≠ficamente dise√±ado para acometer tareas de una complejidad excepcional, que abarcan desde la optimizaci√≥n de componentes cr√≠ticos en infraestructuras computacionales a gran escala hasta la resoluci√≥n de problemas abiertos y de larga data en las matem√°ticas puras y las ciencias computacionales aplicadas.</p>
    </div>

    <h2 class="section-group-title">Metodolog√≠a de AlphaEvolve: Un Ecosistema de Inteligencia Artificial</h2>
    <p>La arquitectura de AlphaEvolve es un sofisticado entramado de m√≥dulos que operan de forma coordinada y, crucialmente, asincr√≥nica, permitiendo un alto rendimiento y paralelizaci√≥n. Su n√∫cleo metodol√≥gico se fundamenta en un algoritmo evolutivo que, a trav√©s de un proceso iterativo de generaciones, busca y refina programas para una tarea espec√≠fica, partiendo de un c√≥digo inicial que puede ser incluso rudimentario.</p>

    <button class="section-toggle-button" onclick="toggleSection('s1', this)" aria-expanded="false" aria-controls="s1">
      <span>1. Estructura del Sistema y Flujo Evolutivo</span><span class="icon">‚ñ∫</span>
    </button>
    <div id="s1" class="content-panel">
      <p><strong class="panel-label">Detalle:</strong></p>
      <p>AlphaEvolve opera como un ecosistema aut√≥nomo. El proceso inicia con un programa base proporcionado por el usuario, junto con criterios de evaluaci√≥n. Los componentes clave incluyen:</p>
      <ul>
        <li><strong>Controlador Distribuido:</strong> Orquesta el bucle evolutivo, gestionando la comunicaci√≥n entre los diferentes m√≥dulos.</li>
        <li><strong>Muestreador de Prompts (Prompt Sampler):</strong> Construye prompts ricos y contextualizados para los LLMs, utilizando programas de la base de datos y otras informaciones relevantes.</li>
        <li><strong>Ensamblaje de LLMs (LLMs Ensemble):</strong> Un conjunto de modelos de lenguaje (como Gemini 2.0 Pro y Gemini 2.0 Flash) que generan modificaciones de c√≥digo (diffs).</li>
        <li><strong>Aplicador de Diffs:</strong> Integra las modificaciones propuestas en nuevas versiones del c√≥digo.</li>
        <li><strong>Grupo de Evaluadores (Evaluators Pool):</strong> Ejecuta una funci√≥n <code>evaluate</code> definida por el usuario. Esta funci√≥n, t√≠picamente implementada en Python, asigna una o varias puntuaciones escalares a la soluci√≥n generada, cuantificando su calidad.</li>
        <li><strong>Base de Datos de Programas (Program Database):</strong> Almacena las soluciones prometedoras junto con sus puntuaciones y otros metadatos, sirviendo como memoria evolutiva.</li>
      </ul>
      <p>El ciclo evolutivo es continuo: se seleccionan programas "padre", se generan prompts, los LLMs proponen cambios, se crean programas "hijo", se eval√∫an, y los mejores se reincorporan a la base de datos, fomentando una mejora iterativa.</p>
    </div>

    <button class="section-toggle-button" onclick="toggleSection('s2', this)" aria-expanded="false" aria-controls="s2">
      <span>2. Evoluci√≥n del C√≥digo a Gran Escala y Flexibilidad Ling√º√≠stica</span><span class="icon">‚ñ∫</span>
    </button>
    <div id="s2" class="content-panel">
      <p><strong class="panel-label">Detalle:</strong></p>
      <p>A diferencia de sistemas evolutivos anteriores como FunSearch, que se centraban en la evoluci√≥n de funciones peque√±as y aisladas (usualmente en Python y de pocas l√≠neas), AlphaEvolve est√° dise√±ado para operar sobre <strong>archivos de c√≥digo completos</strong> y puede trabajar con <strong>diversos lenguajes de programaci√≥n</strong>. El usuario puede anotar bloques espec√≠ficos de c√≥digo mediante comentarios especiales (<code># EVOLVE-BLOCK-START</code> y <code># EVOLVE-BLOCK-END</code>), indicando las secciones que el sistema debe intentar mejorar. Esto permite una integraci√≥n flexible con bases de c√≥digo existentes. Adem√°s, AlphaEvolve ofrece flexibilidad en la <em>abstracci√≥n</em> de la soluci√≥n: puede evolucionar representaciones de cadenas crudas, funciones constructoras (√∫tiles para soluciones sim√©tricas), algoritmos de b√∫squeda a medida, o incluso co-evolucionar soluciones intermedias junto con los algoritmos que las encuentran.</p>
    </div>

    <button class="section-toggle-button" onclick="toggleSection('s3', this)" aria-expanded="false" aria-controls="s3">
      <span>3. Generaci√≥n de C√≥digo Inteligente y Evaluaci√≥n Multifac√©tica</span><span class="icon">‚ñ∫</span>
    </button>
    <div id="s3" class="content-panel">
      <p><strong class="panel-label">Detalle:</strong></p>
      <p>La generaci√≥n de c√≥digo es impulsada por un ensamblaje de LLMs, donde modelos m√°s r√°pidos como Gemini 2.0 Flash permiten una alta tasa de generaci√≥n de candidatos, mientras que modelos m√°s potentes como Gemini 2.0 Pro aportan sugerencias de mayor calidad que pueden conducir a avances significativos. Los LLMs proponen cambios en un formato de "diff" (ej. <code><<<<<<< SEARCH ... ======= ... >>>>>>> REPLACE</code>), lo que permite actualizaciones espec√≠ficas y dirigidas, aunque tambi√©n pueden reescribir bloques enteros si es necesario.</p>
      <p>La evaluaci√≥n es autom√°tica y altamente configurable:</p>
      <ul>
        <li><strong>M√©tricas M√∫ltiples:</strong> AlphaEvolve puede optimizar simult√°neamente varias m√©tricas (eficiencia, simplicidad, rendimiento bajo diferentes escenarios). Esto es crucial, ya que programas que sobresalen en diferentes criterios a menudo poseen estructuras l√≥gicas distintas, enriqueciendo la diversidad de la poblaci√≥n evolutiva.</li>
        <li><strong>Cascada de Evaluaci√≥n (Pruebas de Hip√≥tesis):</strong> Se pueden especificar conjuntos de casos de prueba de dificultad creciente. Las nuevas soluciones solo avanzan a la siguiente etapa si superan las anteriores, podando r√°pidamente las ramas menos prometedoras y ahorrando recursos computacionales.</li>
        <li><strong>Retroalimentaci√≥n Generada por LLM:</strong> Para caracter√≠sticas deseables dif√≠ciles de capturar en una funci√≥n de evaluaci√≥n program√°tica (ej. simplicidad del c√≥digo), se pueden usar LLMs adicionales para calificar estos aspectos.</li>
        <li><strong>Evaluaci√≥n Paralelizada:</strong> El sistema puede distribuir la evaluaci√≥n de soluciones a trav√©s de un cl√∫ster, vital cuando la funci√≥n <code>evaluate</code> es computacionalmente costosa.</li>
      </ul>
    </div>

    <button class="section-toggle-button" onclick="toggleSection('s4', this)" aria-expanded="false" aria-controls="s4">
      <span>4. Aprovechamiento Avanzado del Contexto y Meta-Prompts Din√°micos</span><span class="icon">‚ñ∫</span>
    </button>
    <div id="s4" class="content-panel">
      <p><strong class="panel-label">Detalle:</strong></p>
      <p>La efectividad de los LLMs SOTA (State-Of-The-Art) se ve potenciada por la calidad y riqueza del contexto proporcionado. AlphaEvolve sobresale en esto mediante:</p>
      <ul>
        <li><strong>Contexto Expl√≠cito:</strong> Incorpora en los prompts detalles sobre el problema, instrucciones humanas, ecuaciones relevantes, fragmentos de c√≥digo ejemplares, e incluso literatura cient√≠fica (ej. archivos PDF).</li>
        <li><strong>Formato Estoc√°stico:</strong> Utiliza plantillas con alternativas proporcionadas por humanos, instanciadas probabil√≠sticamente para aumentar la diversidad de los prompts.</li>
        <li><strong>Resultados de Evaluaci√≥n Renderizados:</strong> Incluye en el prompt el c√≥digo de soluciones previas exitosas y sus puntuaciones, permitiendo al LLM "aprender" de los √©xitos y fracasos pasados.</li>
        <li><strong>Evoluci√≥n de Meta-Prompts:</strong> De forma notable, AlphaEvolve puede co-evolucionar las propias instrucciones y el contexto que se proporciona a los LLMs. Estas "meta-instrucciones" se almacenan y evolucionan en una base de datos separada, permitiendo que el sistema aprenda a "pedir mejor" con el tiempo.</li>
      </ul>
    </div>

    <button class="section-toggle-button" onclick="toggleSection('s5', this)" aria-expanded="false" aria-controls="s5">
      <span>5. Base de Datos Evolutiva y Estrategias de Selecci√≥n Avanzadas</span><span class="icon">‚ñ∫</span>
    </button>
    <div id="s5" class="content-panel">
      <p><strong class="panel-label">Detalle:</strong></p>
      <p>Las soluciones generadas y evaluadas se almacenan en una base de datos evolutiva. El objetivo principal de esta base de datos es <strong>resurgir √≥ptimamente ideas exploradas previamente</strong> para guiar las generaciones futuras. Un desaf√≠o clave es equilibrar la <em>explotaci√≥n</em> (refinar las mejores soluciones conocidas) y la <em>exploraci√≥n</em> (mantener la diversidad para descubrir nuevas regiones del espacio de b√∫squeda). AlphaEvolve implementa un algoritmo de base de datos inspirado en una combinaci√≥n del algoritmo MAP-Elites (que mapea soluciones a un espacio de caracter√≠sticas para mantener la diversidad) y modelos de poblaci√≥n basados en islas (que fomentan la evoluci√≥n de nichos especializados).</p>
    </div>

    <h2 class="section-group-title">Aplicaciones y Resultados Transformadores</h2>
    <p>AlphaEvolve ha demostrado su capacidad en una variedad de dominios, produciendo resultados que no solo igualan sino que superan el estado del arte.</p>

    <button class="section-toggle-button" onclick="toggleSection('s6', this)" aria-expanded="false" aria-controls="s6">
      <span>1. Descubrimiento de Algoritmos de Multiplicaci√≥n de Matrices</span><span class="icon">‚ñ∫</span>
    </button>
    <div id="s6" class="content-panel">
      <p><strong class="panel-label">Detalle:</strong></p>
      <p>En el fundamental problema de encontrar algoritmos r√°pidos para la multiplicaci√≥n de matrices, AlphaEvolve logr√≥ un hito hist√≥rico. Para la multiplicaci√≥n de matrices 4√ó4 de valores complejos, descubri√≥ un algoritmo que requiere solo <strong>48 multiplicaciones escalares</strong>. Esto representa la primera mejora sobre el algoritmo recursivo de Strassen (que necesita 49 en este caso) en m√°s de 50 a√±os para este tipo de matrices. Mejor√≥ el estado del arte para 14 tama√±os de matrices diferentes. El sistema fue guiado para encontrar soluciones exactas mediante la inclusi√≥n de un paso de redondeo en la evaluaci√≥n y una solicitud en lenguaje natural en el prompt para generar soluciones casi enteras.</p>
    </div>

    <button class="section-toggle-button" onclick="toggleSection('s7', this)" aria-expanded="false" aria-controls="s7">
      <span>2. Resoluci√≥n de Problemas Matem√°ticos Abiertos</span><span class="icon">‚ñ∫</span>
    </button>
    <div id="s7" class="content-panel">
      <p><strong class="panel-label">Detalle:</strong></p>
      <p>Aplicado a m√°s de 50 problemas abiertos en cinco ramas distintas de las matem√°ticas puras (an√°lisis, combinatoria, teor√≠a de n√∫meros, geometr√≠a), AlphaEvolve demostr√≥ ser una herramienta de investigaci√≥n polifac√©tica:</p>
      <ul>
        <li>Igual√≥ las mejores construcciones conocidas en aproximadamente el 75% de los casos.</li>
        <li>Descubri√≥ <strong>nuevas construcciones, demostrablemente mejores</strong>, que superan el estado del arte en el 20% de los problemas.</li>
        <li>Entre los √©xitos se incluyen mejoras en el problema del N√∫mero Besador (Kissing Numbers) en 11 dimensiones (encontrando una configuraci√≥n de 593 esferas), el problema de m√≠nimo solapamiento de Erd≈ës, desigualdades de autocorrelaci√≥n y principios de incertidumbre, y diversos problemas de empaquetamiento geom√©trico (como variantes del problema de Heilbronn y empaquetamiento de hex√°gonos).</li>
        <li>Notablemente, para muchos de estos problemas, AlphaEvolve evolucion√≥ <em>algoritmos de b√∫squeda heur√≠stica</em> en lugar de las construcciones directamente, demostrando una capacidad de meta-aprendizaje.</li>
      </ul>
    </div>

    <button class="section-toggle-button" onclick="toggleSection('s8', this)" aria-expanded="false" aria-controls="s8">
      <span>3. Optimizaci√≥n de Infraestructura Computacional Cr√≠tica en Google</span><span class="icon">‚ñ∫</span>
    </button>
    <div id="s8" class="content-panel">
      <p><strong class="panel-label">Detalle:</strong></p>
      <p>AlphaEvolve ha generado un impacto pr√°ctico tangible en los sistemas de Google:</p>
      <ul>
        <li><strong>Mejora de Scheduling en Centros de Datos (Borg):</strong> Descubri√≥ una funci√≥n heur√≠stica simple pero efectiva para asignar trabajos a m√°quinas, logrando una <strong>recuperaci√≥n promedio del 0.7% de los recursos computacionales</strong> a lo largo de toda la flota de Google, que de otro modo quedar√≠an varados. Esta soluci√≥n fue preferida sobre enfoques de aprendizaje profundo (DRL) por su interpretabilidad, depurabilidad y facilidad de despliegue.</li>
        <li><strong>Aceleraci√≥n de Kernels de Entrenamiento para Gemini (JAX/Pallas):</strong> Optimiz√≥ las heur√≠sticas de "tiling" (divisi√≥n de c√≥mputo en bloques) para un kernel de multiplicaci√≥n de matrices crucial en el entrenamiento del modelo Gemini. Esto result√≥ en una <strong>reducci√≥n promedio del 23% en el tiempo de ejecuci√≥n del kernel</strong> y una disminuci√≥n del 1% en el tiempo total de entrenamiento de Gemini, reduciendo adem√°s el tiempo de optimizaci√≥n del kernel de meses a d√≠as. Un caso de IA optimiz√°ndose a s√≠ misma.</li>
        <li><strong>Optimizaci√≥n de Dise√±o de Circuitos de Hardware (TPUs):</strong> Se utiliz√≥ para refinar una implementaci√≥n en Verilog de un circuito aritm√©tico clave en la unidad de multiplicaci√≥n de matrices de las TPUs. Propuso una reescritura de c√≥digo simple que eliminaba bits innecesarios, reduciendo √°rea y consumo energ√©tico. Aunque esta mejora espec√≠fica tambi√©n fue detectada por herramientas de s√≠ntesis posteriores, la contribuci√≥n de AlphaEvolve en la etapa de RTL (Register-Transfer Level) demuestra su potencial para optimizaciones tempranas en el flujo de dise√±o.</li>
        <li><strong>Refinamiento de C√≥digo Compilado (XLA IR para FlashAttention):</strong> Optimiz√≥ directamente las Representaciones Intermedias (IRs) generadas por el compilador XLA para el kernel de FlashAttention. A pesar de que este c√≥digo ya est√° altamente optimizado y el IR est√° dise√±ado para depuraci√≥n m√°s que para edici√≥n directa, AlphaEvolve logr√≥ una <strong>aceleraci√≥n del 32% en el kernel de FlashAttention</strong> y una mejora del 15% en el c√≥digo de pre y post-procesamiento asociado.</li>
      </ul>
    </div>

    <h2 class="section-group-title">Comparaci√≥n y Perspectivas</h2>

    <button class="section-toggle-button" onclick="toggleSection('s9', this)" aria-expanded="false" aria-controls="s9">
      <span>Comparaci√≥n con Enfoques Anteriores (FunSearch)</span><span class="icon">‚ñ∫</span>
    </button>
    <div id="s9" class="content-panel">
      <p><strong class="panel-label">Detalle:</strong></p>
      <p>AlphaEvolve se basa en el legado de FunSearch pero lo expande significativamente:</p>
      <ul>
        <li><strong>Escala y Lenguaje:</strong> FunSearch evolucionaba una √∫nica funci√≥n Python de pocas l√≠neas; AlphaEvolve maneja archivos de c√≥digo completos en m√∫ltiples lenguajes.</li>
        <li><strong>Modelos y Contexto:</strong> FunSearch usaba LLMs m√°s peque√±os y un contexto m√≠nimo; AlphaEvolve emplea SOTA LLMs (Gemini Pro/Flash) con un contexto rico y din√°mico, incluyendo meta-prompts.</li>
        <li><strong>Objetivos:</strong> FunSearch optimizaba una √∫nica m√©trica; AlphaEvolve maneja optimizaci√≥n multiobjetivo.</li>
        <li><strong>Generalidad:</strong> Estas extensiones permiten a AlphaEvolve abordar problemas mucho m√°s desafiantes y de mayor impacto que no eran factibles para FunSearch.</li>
      </ul>
    </div>

    <button class="section-toggle-button" onclick="toggleSection('s10', this)" aria-expanded="false" aria-controls="s10">
      <span>Limitaciones y Discusi√≥n Futura</span><span class="icon">‚ñ∫</span>
    </button>
    <div id="s10" class="content-panel">
      <p><strong class="panel-label">Detalle:</strong></p>
      <p>La principal limitaci√≥n actual de AlphaEvolve es su <strong>dependencia de un evaluador autom√°tico robusto</strong>. Si bien esto es com√∫n en matem√°ticas y ciencias de la computaci√≥n, dominios como las ciencias naturales a menudo requieren experimentaci√≥n f√≠sica. Aunque el sistema permite la evaluaci√≥n de ideas proporcionada por LLMs, este no es su modo optimizado.</p>
      <p>El futuro de AlphaEvolve es prometedor:</p>
      <ul>
        <li><strong>Destilaci√≥n:</strong> Se explorar√° la posibilidad de destilar el rendimiento mejorado de AlphaEvolve de nuevo en las futuras generaciones de los modelos LLM base.</li>
        <li><strong>Expansi√≥n de Entornos:</strong> Aumentar el n√∫mero de problemas (entornos) con funciones de evaluaci√≥n robustas impulsar√° m√°s descubrimientos de alto valor.</li>
        <li><strong>Integraci√≥n con Razonamiento de Alto Nivel:</strong> Se contempla la posibilidad de conectar AlphaEvolve con sistemas que proporcionen retroalimentaci√≥n de alto nivel (como un "AI Co-Scientist") antes de la etapa de implementaci√≥n y evaluaci√≥n de c√≥digo, combinando el razonamiento abstracto con la optimizaci√≥n concreta.</li>
      </ul>
    </div>

    <button class="section-toggle-button" onclick="toggleSection('s11', this)" aria-expanded="false" aria-controls="s11">
      <span>Conclusi√≥n</span><span class="icon">‚ñ∫</span>
    </button>
    <div id="s11" class="content-panel">
      <p><strong class="panel-label">Detalle:</strong></p>
      <p>AlphaEvolve no es simplemente una herramienta de optimizaci√≥n de c√≥digo; es un <strong>agente de descubrimiento algor√≠tmico y cient√≠fico</strong>. Al combinar de manera ingeniosa la capacidad de generaci√≥n de los LLMs con la b√∫squeda dirigida de los algoritmos evolutivos, ha demostrado una sorprendente capacidad para realizar descubrimientos en problemas matem√°ticos de larga data y para ofrecer mejoras pr√°cticas y significativas en sistemas computacionales complejos. Su arquitectura flexible, su sofisticado manejo del contexto y su capacidad para aprender y adaptarse lo posicionan como un sistema con el potencial de acelerar dr√°sticamente el ritmo de la innovaci√≥n cient√≠fica y la ingenier√≠a algor√≠tmica en los a√±os venideros. Representa un paso firme hacia una nueva era donde la IA colabora activamente en la expansi√≥n de las fronteras del conocimiento.</p>
    </div>

  </div> <!-- Fin de .container -->

  <script>
    function toggleTheme() {
      document.body.classList.toggle("dark-mode");
      let themeButton = document.getElementById('theme-toggle-btn');
      let isDarkMode = document.body.classList.contains("dark-mode");
      localStorage.setItem("theme", isDarkMode ? "dark" : "light");
      if (themeButton) {
          themeButton.textContent = isDarkMode ? "Modo Claro" : "Modo Oscuro";
      }
    }

    function toggleSection(id, buttonElement) {
      let panel = document.getElementById(id);
      let icon = buttonElement.querySelector('.icon');
      if (panel && buttonElement) {
          panel.classList.toggle('is-visible');
          let isVisible = panel.classList.contains('is-visible');
          buttonElement.setAttribute('aria-expanded', isVisible);
          buttonElement.classList.toggle('is-expanded', isVisible);
          if (icon) {
              icon.textContent = isVisible ? '‚ñº' : '‚ñ∫';
          }
      }
    }

    window.onload = function() {
      let themeButton = document.getElementById('theme-toggle-btn');
      const savedTheme = localStorage.getItem("theme");

      if (savedTheme === "dark") {
        document.body.classList.add("dark-mode");
        if (themeButton) {
            themeButton.textContent = "Modo Claro";
        }
      } else {
        document.body.classList.remove("dark-mode");
        if (themeButton) {
            themeButton.textContent = "Modo Oscuro";
        }
      }

       document.querySelectorAll('.content-panel').forEach(panel => {
         panel.classList.remove('is-visible');
         panel.style.maxHeight = '0'; // Asegurar que la animaci√≥n empiece desde 0
       });
       document.querySelectorAll('.section-toggle-button').forEach(button => {
          button.setAttribute('aria-expanded', 'false');
          button.classList.remove('is-expanded');
          let icon = button.querySelector('.icon');
          if (icon) {
              icon.textContent = '‚ñ∫';
          }
       });
    }
  </script>
</body>
</html>
"""

# Mostrar el HTML en la salida de la celda
display(HTML(html_content))

# Importar las funciones necesarias de IPython para mostrar HTML
from IPython.core.display import display, HTML

# Definir el contenido HTML, CSS y JavaScript como un string multil√≠nea
html_content = """
<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>FAQ: Algoritmos Gen√©ticos y Aplicaciones Conceptuales</title>
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&family=Lora:ital,wght@0,400;0,700&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg-color: #f8f9fa;
      --text-color: #343a40;
      --header-color: #0056b3; /* Azul oscuro para t√≠tulos */
      --header-dark-color: #90c5ff; /* Azul claro para t√≠tulos en modo oscuro */
      --accent-color: #28a745; /* Verde para acentos */
      --accent-dark-color: #73c888; /* Verde claro para acentos en modo oscuro */
      --button-bg: #007bff; /* Azul primario */
      --button-hover-bg: #0056b3; /* Azul m√°s oscuro */
      --button-dark-bg: #ff8c00; /* Naranja oscuro para modo oscuro */
      --button-dark-hover-bg: #cc7000; /* Naranja m√°s oscuro */
      --button-text-color: white;
      --theme-button-bg: #6c757d; /* Gris secundario */
      --theme-button-dark-bg: #ffc107; /* Amarillo */
      --content-panel-bg: #e9ecef; /* Gris muy claro para paneles */
      --content-panel-dark-bg: #495057; /* Gris m√°s oscuro para paneles */
      --panel-label-color: var(--accent-color);
      --panel-label-dark-color: var(--accent-dark-color);
      --icon-color: var(--button-text-color); /* Icono del mismo color que el texto del bot√≥n */
    }

    body {
      font-family: 'Lora', 'Roboto', serif;
      line-height: 1.8;
      background-color: var(--bg-color);
      color: var(--text-color);
      transition: background-color 0.3s, color 0.3s;
      padding: 20px;
      margin: 0;
    }
    .faq-container { /* Contenedor espec√≠fico para estas FAQs */
      max-width: 950px;
      margin: auto;
      padding: 25px;
      position: relative;
      background-color: var(--bg-color);
      border-radius: 8px;
      box-shadow: 0 3px 10px rgba(0,0,0,0.07);
    }
    body.dark-mode .faq-container {
        box-shadow: 0 3px 12px rgba(0,0,0,0.25);
    }
    body.dark-mode {
      --bg-color: #2c3e50; /* Un azul oscuro m√°s profundo para el fondo */
      --text-color: #ecf0f1; /* Un blanco gris√°ceo suave */
      --header-color: var(--header-dark-color);
      --accent-color: var(--accent-dark-color);
      --button-bg: var(--button-dark-bg);
      --button-hover-bg: var(--button-dark-hover-bg);
      --content-panel-bg: var(--content-panel-dark-bg);
      --panel-label-color: var(--panel-label-dark-color);
    }

    .faq-container h1 {
      font-family: 'Roboto', sans-serif;
      font-size: 2.3em;
      color: var(--header-color);
      text-align: center;
      margin-bottom: 25px;
      padding-bottom: 10px;
      border-bottom: 2px solid var(--accent-color);
    }
     .faq-container h2.section-group-title { /* T√≠tulo para agrupar preguntas */
        font-family: 'Roboto', sans-serif;
        font-size: 1.6em;
        color: var(--accent-color);
        margin-top: 30px;
        margin-bottom: 5px;
        padding-bottom: 5px;
    }


    .content-panel {
      max-height: 0;
      overflow: hidden;
      transition: max-height 0.35s ease-in-out, padding-top 0.35s ease-in-out, padding-bottom 0.35s ease-in-out;
      margin-top: 0;
      padding: 0 22px; /* Se aplica cuando est√° visible, ajustado */
      border-left: 4px solid var(--accent-color);
      background-color: var(--content-panel-bg);
      border-radius: 0 0 6px 6px;
    }
    .content-panel.is-visible {
      max-height: 3500px; /* Ajustar seg√∫n el contenido m√°s largo esperado */
      padding-top: 18px;
      padding-bottom: 18px;
    }
    .content-panel p, .content-panel ul, .content-panel ol {
        margin-bottom: 1.1em;
        font-size: 1.0em; /* Ligeramente m√°s peque√±o para densidad */
    }
    .content-panel p:last-child, .content-panel ul:last-child, .content-panel ol:last-child {
        margin-bottom: 0;
    }
    .content-panel strong.panel-label {
        color: var(--panel-label-color);
        font-family: 'Roboto', sans-serif;
        font-size: 1.05em;
        display: block;
        margin-bottom: 0.6em;
    }


    .section-toggle-button {
      background-color: var(--button-bg);
      color: var(--button-text-color);
      border: none;
      padding: 13px 18px; /* Ligeramente ajustado */
      border-radius: 6px;
      cursor: pointer;
      margin-top: 8px; /* M√°s juntas las preguntas */
      transition: background-color 0.3s, border-radius 0.2s;
      width: 100%;
      text-align: left;
      font-family: 'Roboto', sans-serif;
      font-size: 1.05em; /* Ligeramente ajustado */
      font-weight: 700;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }
    .section-toggle-button:hover {
      background-color: var(--button-hover-bg);
    }
    .section-toggle-button.is-expanded {
        border-radius: 6px 6px 0 0;
    }
    .section-toggle-button .icon {
        margin-left: 10px;
        font-size: 0.85em;
        color: var(--icon-color);
        transition: transform 0.3s ease-out;
    }
    .section-toggle-button.is-expanded .icon {
        transform: rotate(90deg);
    }


    .theme-toggle-faq {
      background-color: var(--theme-button-bg);
      color: white;
      border: none;
      padding: 9px 14px;
      border-radius: 6px;
      cursor: pointer;
      position: absolute;
      top: 28px; /* Ajustado */
      right: 25px;
      font-size: 0.85em;
      font-family: 'Roboto', sans-serif;
      transition: background-color 0.3s;
      z-index: 100; /* Asegurar que est√© encima */
    }
    body.dark-mode .theme-toggle-faq {
       background-color: var(--theme-button-dark-bg);
       color: var(--text-color);
    }

    button:focus, a:focus {
        outline: 2px solid var(--accent-color);
        outline-offset: 3px;
    }
    body.dark-mode button:focus, body.dark-mode a:focus {
         outline-color: var(--accent-dark-color);
    }
    ul, ol {
        padding-left: 25px; /* Ligeramente reducido */
    }
    li {
        margin-bottom: 0.6em;
    }
    strong {
        font-weight: 700;
    }
    code {
      background-color: rgba(0,0,0,0.04);
      padding: 2px 4px;
      border-radius: 3px;
      font-family: 'Courier New', Courier, monospace;
      font-size: 0.9em;
    }
    body.dark-mode code {
      background-color: rgba(255,255,255,0.08);
    }
  </style>
</head>
<body>
  <div class="faq-container">
    <button id="theme-toggle-faq-btn" class="theme-toggle-faq" onclick="toggleFaqTheme()" title="Cambiar tema de color">Modo Oscuro</button>

    <h1>Preguntas Frecuentes: Algoritmos Gen√©ticos y Aplicaciones Conceptuales</h1>

    <h2 class="section-group-title">Fundamentos de Algoritmos Gen√©ticos (AG)</h2>

    <!-- Pregunta 1 -->
    <button class="section-toggle-button" onclick="toggleSection('faq_ga_1', this)" aria-expanded="false" aria-controls="faq_ga_1">
      <span>1. ¬øQu√© es un Algoritmo Gen√©tico y en qu√© principios se inspira?</span><span class="icon">‚ñ∫</span>
    </button>
    <div id="faq_ga_1" class="content-panel">
      <p><strong class="panel-label">Respuesta Detallada:</strong></p>
      <p>Un Algoritmo Gen√©tico (AG) es una t√©cnica de b√∫squeda y optimizaci√≥n metaheur√≠stica inspirada directamente en los principios de la evoluci√≥n biol√≥gica y la selecci√≥n natural propuestos por Charles Darwin. Forma parte del campo m√°s amplio de la computaci√≥n evolutiva y la inteligencia artificial. Los AG simulan el proceso de "supervivencia del m√°s apto" sobre una poblaci√≥n de soluciones candidatas a un problema. A trav√©s de generaciones sucesivas, la poblaci√≥n evoluciona hacia soluciones cada vez mejores mediante la aplicaci√≥n de operadores gen√©ticos como la selecci√≥n, el cruzamiento (recombinaci√≥n) y la mutaci√≥n. Su fortaleza radica en la capacidad de explorar eficientemente grandes y complejos espacios de soluciones donde los m√©todos de optimizaci√≥n cl√°sicos (basados en gradientes o exhaustivos) pueden ser ineficaces o inviables debido a la dimensionalidad, la no linealidad o la presencia de m√∫ltiples √≥ptimos locales.</p>
    </div>

    <!-- Pregunta 2 -->
    <button class="section-toggle-button" onclick="toggleSection('faq_ga_2', this)" aria-expanded="false" aria-controls="faq_ga_2">
      <span>2. ¬øCu√°les son los componentes y pasos fundamentales en el ciclo de un Algoritmo Gen√©tico?</span><span class="icon">‚ñ∫</span>
    </button>
    <div id="faq_ga_2" class="content-panel">
      <p><strong class="panel-label">Respuesta Detallada:</strong></p>
      <p>El ciclo de un Algoritmo Gen√©tico t√≠picamente involucra los siguientes componentes y pasos fundamentales:</p>
      <ol>
        <li><strong>Inicializaci√≥n:</strong> Se crea una poblaci√≥n inicial de individuos (soluciones candidatas). Cada individuo es un "cromosoma" que codifica una posible soluci√≥n. Esta poblaci√≥n inicial suele generarse aleatoriamente, aunque tambi√©n pueden incorporarse soluciones heur√≠sticas o conocidas.</li>
        <li><strong>Evaluaci√≥n (Funci√≥n de Fitness):</strong> Cada individuo de la poblaci√≥n es evaluado mediante una funci√≥n de fitness (o aptitud). Esta funci√≥n asigna un valor num√©rico que cuantifica qu√© tan "buena" es la soluci√≥n que representa el individuo con respecto al objetivo del problema.</li>
        <li><strong>Selecci√≥n:</strong> Se seleccionan individuos de la poblaci√≥n actual para ser "progenitores" de la siguiente generaci√≥n. La selecci√≥n es probabil√≠stica y sesgada hacia los individuos con mejor fitness (los m√°s aptos tienen mayor probabilidad de ser seleccionados). M√©todos comunes incluyen la selecci√≥n por ruleta, por torneo y el elitismo.</li>
        <li><strong>Cruzamiento (Crossover):</strong> Los progenitores seleccionados se emparejan y se aplica un operador de cruzamiento para combinar su material gen√©tico y crear uno o m√°s "descendientes". El objetivo es que los descendientes hereden caracter√≠sticas deseables de ambos padres.</li>
        <li><strong>Mutaci√≥n:</strong> Se aplica un operador de mutaci√≥n a los descendientes (y a veces a otros individuos) con una baja probabilidad. La mutaci√≥n introduce peque√±os cambios aleatorios en el material gen√©tico, ayudando a mantener la diversidad en la poblaci√≥n y a explorar nuevas √°reas del espacio de soluciones, evitando la convergencia prematura.</li>
        <li><strong>Reemplazo:</strong> La nueva poblaci√≥n de descendientes reemplaza total o parcialmente a la poblaci√≥n anterior. Estrategias comunes incluyen el reemplazo generacional completo o el reemplazo de los peores individuos.</li>
        <li><strong>Criterio de Parada:</strong> El ciclo se repite (pasos 2-6) hasta que se cumple un criterio de parada. Esto puede ser un n√∫mero m√°ximo de generaciones, alcanzar un nivel de fitness satisfactorio, un tiempo l√≠mite, o cuando la mejora en el fitness se estanca.</li>
      </ol>
    </div>

    <!-- Pregunta 3 -->
    <button class="section-toggle-button" onclick="toggleSection('faq_ga_3', this)" aria-expanded="false" aria-controls="faq_ga_3">
      <span>3. ¬øQu√© es la "representaci√≥n gen√©tica" o "codificaci√≥n" en un AG y por qu√© es crucial? De ejemplos.</span><span class="icon">‚ñ∫</span>
    </button>
    <div id="faq_ga_3" class="content-panel">
      <p><strong class="panel-label">Respuesta Detallada:</strong></p>
      <p>La representaci√≥n gen√©tica, tambi√©n llamada codificaci√≥n, es la forma en que una soluci√≥n candidata al problema se traduce en un "cromosoma" o "genotipo" que el AG puede manipular. Es un paso crucial porque la elecci√≥n de la representaci√≥n afecta directamente la eficiencia y efectividad del AG, as√≠ como la facilidad para dise√±ar operadores gen√©ticos significativos.</p>
      <p>Una buena representaci√≥n debe:</p>
      <ul>
        <li>Ser capaz de representar todas las soluciones posibles (o al menos un subconjunto prometedor).</li>
        <li>Facilitar la aplicaci√≥n de operadores gen√©ticos (cruce y mutaci√≥n) de manera que generen soluciones v√°lidas o f√°cilmente reparables.</li>
        <li>Permitir una decodificaci√≥n eficiente para evaluar el fitness de la soluci√≥n fenot√≠pica.</li>
      </ul>
      <p>Ejemplos comunes de codificaci√≥n incluyen:</p>
      <ul>
        <li><strong>Binaria:</strong> La soluci√≥n se representa como una cadena de 0s y 1s. √ötil para problemas de selecci√≥n de caracter√≠sticas o donde las variables son inherentemente binarias.</li>
        <li><strong>Entera o Real:</strong> La soluci√≥n se representa como un vector de n√∫meros enteros o de punto flotante. Com√∫n para problemas de optimizaci√≥n de par√°metros.</li>
        <li><strong>Permutaciones:</strong> La soluci√≥n es una secuencia ordenada de elementos. Fundamental para problemas de ordenamiento como el Problema del Viajante (TSP), donde la permutaci√≥n representa el orden de visita de las ciudades.</li>
        <li><strong>√Årboles:</strong> La soluci√≥n se representa como una estructura de √°rbol. Usada en Programaci√≥n Gen√©tica para evolucionar programas o expresiones matem√°ticas.</li>
        <li><strong>Representaci√≥n Directa de C√≥digo (como en AlphaEvolve):</strong> La soluci√≥n es directamente el c√≥digo fuente de un programa o funci√≥n. Los operadores gen√©ticos son aplicados por un LLM que entiende la sintaxis y sem√°ntica del lenguaje.</li>
      </ul>
    </div>

    <!-- Pregunta 4 -->
    <button class="section-toggle-button" onclick="toggleSection('faq_ga_4', this)" aria-expanded="false" aria-controls="faq_ga_4">
      <span>4. Explique la funci√≥n de los operadores de cruzamiento y mutaci√≥n en un AG.</span><span class="icon">‚ñ∫</span>
    </button>
    <div id="faq_ga_4" class="content-panel">
      <p><strong class="panel-label">Respuesta Detallada:</strong></p>
      <p>Los operadores de cruzamiento y mutaci√≥n son los motores principales de la exploraci√≥n y explotaci√≥n en un Algoritmo Gen√©tico:</p>
      <ul>
        <li><strong>Cruzamiento (Crossover):</strong>
          <ul>
            <li><strong>Funci√≥n Principal:</strong> Explotaci√≥n e intensificaci√≥n. Combina informaci√≥n gen√©tica de dos (o m√°s) individuos progenitores para crear nuevos individuos descendientes. La idea es que al combinar "bloques constructivos" (buenas sub-soluciones) de padres aptos, se puedan generar descendientes a√∫n mejores.</li>
            <li><strong>Ejemplos:</strong> Cruce de un punto, cruce de m√∫ltiples puntos (para representaciones binarias/reales); Order Crossover (OX), Partially Mapped Crossover (PMX), Cycle Crossover (CX) (para permutaciones).</li>
            <li><strong>Impacto:</strong> Permite la convergencia hacia regiones prometedoras del espacio de b√∫squeda al propagar y recombinar caracter√≠sticas exitosas.</li>
          </ul>
        </li>
        <li><strong>Mutaci√≥n:</strong>
          <ul>
            <li><strong>Funci√≥n Principal:</strong> Exploraci√≥n y mantenimiento de la diversidad. Introduce peque√±os cambios aleatorios en el material gen√©tico de un individuo.</li>
            <li><strong>Ejemplos:</strong> Inversi√≥n de bit (para binario); reemplazo por un valor aleatorio, ajuste peque√±o (para real); swap, insert, reverse/inversion (para permutaciones).</li>
            <li><strong>Impacto:</strong> Previene la convergencia prematura a √≥ptimos locales al introducir nueva variabilidad gen√©tica en la poblaci√≥n. Permite al AG escapar de picos locales y explorar nuevas regiones del espacio de soluciones que podr√≠an no ser accesibles solo mediante cruzamiento. Se aplica con una probabilidad mucho menor que el cruzamiento.</li>
          </ul>
        </li>
      </ul>
      <p>Un equilibrio adecuado entre la explotaci√≥n del cruzamiento y la exploraci√≥n de la mutaci√≥n es crucial para el buen rendimiento de un AG.</p>
    </div>

    <!-- Pregunta 5 -->
    <button class="section-toggle-button" onclick="toggleSection('faq_ga_5', this)" aria-expanded="false" aria-controls="faq_ga_5">
      <span>5. ¬øQu√© es el elitismo en los Algoritmos Gen√©ticos y por qu√© es importante?</span><span class="icon">‚ñ∫</span>
    </button>
    <div id="faq_ga_5" class="content-panel">
      <p><strong class="panel-label">Respuesta Detallada:</strong></p>
      <p>El elitismo es una estrategia utilizada en los Algoritmos Gen√©ticos que consiste en **preservar directamente uno o m√°s de los mejores individuos de la poblaci√≥n actual para que pasen sin cambios a la siguiente generaci√≥n**. Es decir, los individuos "√©lite" no est√°n sujetos a los operadores de cruzamiento o mutaci√≥n y se copian tal cual.</p>
      <p><strong>Importancia del Elitismo:</strong></p>
      <ul>
        <li><strong>Prevenci√≥n de P√©rdida de Buenas Soluciones:</strong> La principal ventaja es que garantiza que la mejor soluci√≥n encontrada hasta el momento no se pierda debido a la naturaleza estoc√°stica de la selecci√≥n, el cruzamiento o la mutaci√≥n. Sin elitismo, es posible que una soluci√≥n excelente sea descartada o degradada accidentalmente.</li>
        <li><strong>Convergencia Monot√≥nica (del Mejor Individuo):</strong> Asegura que el fitness del mejor individuo de la poblaci√≥n sea no decreciente (o no creciente, si se minimiza) a lo largo de las generaciones. Esto puede acelerar la convergencia hacia buenas soluciones.</li>
        <li><strong>Punto de Referencia:</strong> Los individuos √©lite sirven como un punto de referencia constante contra el cual se pueden comparar las nuevas soluciones generadas.</li>
      </ul>
      <p>Sin embargo, un elitismo excesivo (preservar demasiados individuos) puede reducir la diversidad de la poblaci√≥n y llevar a una convergencia prematura. Por lo tanto, el n√∫mero de individuos √©lite suele ser peque√±o, t√≠picamente uno o un porcentaje bajo de la poblaci√≥n total.</p>
    </div>

    <h2 class="section-group-title">Algoritmos Gen√©ticos Aplicados (TSP, Laberintos)</h2>

    <!-- Pregunta 6 -->
    <button class="section-toggle-button" onclick="toggleSection('faq_tsp_1', this)" aria-expanded="false" aria-controls="faq_tsp_1">
      <span>6. ¬øPor qu√© los Algoritmos Gen√©ticos son adecuados para el Problema del Viajante (TSP)?</span><span class="icon">‚ñ∫</span>
    </button>
    <div id="faq_tsp_1" class="content-panel">
      <p><strong class="panel-label">Respuesta Detallada:</strong></p>
      <p>Los Algoritmos Gen√©ticos son particularmente adecuados para el Problema del Viajante (TSP) por varias razones clave:</p>
      <ol>
        <li><strong>Representaci√≥n Natural:</strong> Una soluci√≥n al TSP (una ruta que visita cada ciudad una vez) se puede representar de forma natural e intuitiva como una permutaci√≥n de ciudades. Esta codificaci√≥n es directamente compatible con operadores gen√©ticos dise√±ados para permutaciones.</li>
        <li><strong>Espacio de B√∫squeda Vasto y Complejo:</strong> El TSP es un problema NP-hard, lo que significa que el n√∫mero de posibles rutas crece factorialmente con el n√∫mero de ciudades. Para instancias grandes, la b√∫squeda exhaustiva es inviable. Los AG son eficaces para explorar estos grandes espacios de b√∫squeda de manera heur√≠stica.</li>
        <li><strong>Robustez ante √ìptimos Locales:</strong> El espacio de soluciones del TSP est√° plagado de √≥ptimos locales (rutas que son buenas pero no las mejores globalmente). Los AG, mediante la mutaci√≥n y el mantenimiento de la diversidad poblacional, tienen la capacidad de escapar de estos √≥ptimos locales.</li>
        <li><strong>Adaptabilidad a Variantes:</strong> Los AG pueden adaptarse f√°cilmente a diversas variantes del TSP, como el TSP asim√©trico, TSP con ventanas de tiempo, o problemas de ruteo de veh√≠culos (VRP) que generalizan el TSP, simplemente ajustando la funci√≥n de fitness y, a veces, los operadores.</li>
        <li><strong>Operadores Gen√©ticos Espec√≠ficos:</strong> Se han desarrollado operadores de cruzamiento (ej. Order Crossover OX, Partially Mapped Crossover PMX) y mutaci√≥n (ej. swap, inversion, insertion) espec√≠ficamente dise√±ados para trabajar con representaciones de permutaci√≥n, preservando la validez de las rutas o facilitando su reparaci√≥n.</li>
        <li><strong>Paralelizaci√≥n:</strong> Muchas partes de un AG (como la evaluaci√≥n del fitness de los individuos) son inherentemente paralelizables, lo que puede acelerar la b√∫squeda en hardware moderno.</li>
      </ol>
      <p>Aunque no garantizan encontrar la soluci√≥n √≥ptima global, los AG suelen encontrar soluciones de muy alta calidad para el TSP en un tiempo razonable.</p>
    </div>

    <!-- Pregunta 7 -->
    <button class="section-toggle-button" onclick="toggleSection('faq_tsp_2', this)" aria-expanded="false" aria-controls="faq_tsp_2">
      <span>7. ¬øC√≥mo se define t√≠picamente la funci√≥n de fitness para el Problema del Viajante (TSP)?</span><span class="icon">‚ñ∫</span>
    </button>
    <div id="faq_tsp_2" class="content-panel">
      <p><strong class="panel-label">Respuesta Detallada:</strong></p>
      <p>En el Problema del Viajante (TSP), el objetivo es encontrar la ruta m√°s corta posible. Dado que los Algoritmos Gen√©ticos est√°n dise√±ados convencionalmente para maximizar el fitness, la funci√≥n de fitness debe transformar la medida de "costo" (distancia) en una medida de "calidad" (aptitud).</p>
      <p>Las formas m√°s comunes de definir la funci√≥n de fitness para el TSP son:</p>
      <ol>
        <li><strong>Inverso de la Distancia Total:</strong>
          <p><code>Fitness(ruta) = 1 / DistanciaTotal(ruta)</code></p>
          <p>En este caso, una distancia total menor resultar√° en un valor de fitness mayor. Es importante manejar el caso de distancia cero si es te√≥ricamente posible (ej. a√±adiendo una peque√±a constante √©psilon al denominador o asegurando que las distancias sean siempre positivas).</p>
        </li>
        <li><strong>Negativo de la Distancia Total:</strong>
          <p><code>Fitness(ruta) = -DistanciaTotal(ruta)</code></p>
          <p>Aqu√≠, maximizar el fitness equivale a minimizar la distancia (ya que un n√∫mero negativo mayor est√° m√°s cerca de cero). Alternativamente, si el algoritmo de selecci√≥n busca minimizar, se puede usar directamente <code>DistanciaTotal(ruta)</code>.</p>
        </li>
        <li><strong>Escalado:</strong>
          <p><code>Fitness(ruta) = C_max - DistanciaTotal(ruta)</code></p>
          <p>Donde <code>C_max</code> es una constante suficientemente grande (por ejemplo, una estimaci√≥n del peor recorrido posible o una suma de las distancias m√°ximas). Esto asegura que el fitness sea positivo y que rutas m√°s cortas tengan mayor fitness.</p>
        </li>
      </ol>
      <p>La elecci√≥n exacta puede depender de la implementaci√≥n espec√≠fica del AG y de las caracter√≠sticas del problema, pero el principio fundamental es que el fitness debe reflejar inversamente la longitud de la ruta para guiar la evoluci√≥n hacia soluciones m√°s cortas.</p>
    </div>

    <!-- Pregunta 8 -->
    <button class="section-toggle-button" onclick="toggleSection('faq_tsp_3', this)" aria-expanded="false" aria-controls="faq_tsp_3">
      <span>8. Describa un operador de cruzamiento y uno de mutaci√≥n com√∫nmente usados para el TSP.</span><span class="icon">‚ñ∫</span>
    </button>
    <div id="faq_tsp_3" class="content-panel">
      <p><strong class="panel-label">Respuesta Detallada:</strong></p>
      <p>Para el Problema del Viajante (TSP), donde las soluciones son permutaciones de ciudades, se utilizan operadores gen√©ticos espec√≠ficos:</p>
      <ul>
        <li><strong>Operador de Cruzamiento Com√∫n: Order Crossover (OX1)</strong>
          <ol>
            <li>Se eligen dos puntos de corte aleatorios en el primer progenitor (P1).</li>
            <li>El segmento de P1 entre estos puntos de corte se copia directamente al descendiente (H1) en las mismas posiciones.</li>
            <li>Los elementos restantes se toman del segundo progenitor (P2) en el orden en que aparecen en P2, omitiendo aquellos que ya est√°n presentes en H1 (provenientes del segmento de P1).</li>
            <li>Estos elementos de P2 se insertan en las posiciones vac√≠as de H1, comenzando despu√©s del segundo punto de corte y continuando c√≠clicamente desde el inicio si es necesario.</li>
          </ol>
          <p><em>Ejemplo:</em> P1 = [1,2,3,<strong>4,5,6</strong>,7,8], P2 = [8,6,4,2,1,3,5,7]. Puntos de corte en P1 despu√©s de la pos 3 y 6 (segmento 4,5,6).</p>
          <p>H1 = [_,_,_,<strong>4,5,6</strong>,_,_]. Elementos de P2 en orden, omitiendo 4,5,6: [8,2,1,3,7].</p>
          <p>H1 = [2,1,3,<strong>4,5,6</strong>,8,7] (llenando desde la pos 7, luego 1, 2, 3).</p>
          <p>OX1 tiende a preservar el orden relativo y las posiciones absolutas de un segmento del primer padre, complementado con el orden relativo del segundo.</p>
        </li>
        <li><strong>Operador de Mutaci√≥n Com√∫n: Swap (Intercambio)</strong>
          <ol>
            <li>Se eligen dos posiciones aleatorias distintas en el cromosoma (la permutaci√≥n de ciudades).</li>
            <li>Las ciudades en estas dos posiciones se intercambian.</li>
          </ol>
          <p><em>Ejemplo:</em> Individuo = [1,2,<strong>3</strong>,4,5,<strong>6</strong>,7,8]. Posiciones aleatorias 3 y 6 (valores 3 y 6).</p>
          <p>Individuo Mutado = [1,2,<strong>6</strong>,4,5,<strong>3</strong>,7,8].</p>
          <p>Swap es un operador simple pero efectivo para introducir peque√±as perturbaciones y explorar vecindarios cercanos de la soluci√≥n actual.</p>
        </li>
      </ul>
    </div>

    <!-- Pregunta 9 -->
    <button class="section-toggle-button" onclick="toggleSection('faq_lab_1', this)" aria-expanded="false" aria-controls="faq_lab_1">
      <span>9. ¬øC√≥mo se puede representar una soluci√≥n (un camino) en un AG para el problema de navegaci√≥n en laberintos?</span><span class="icon">‚ñ∫</span>
    </button>
    <div id="faq_lab_1" class="content-panel">
      <p><strong class="panel-label">Respuesta Detallada:</strong></p>
      <p>Para el problema de navegaci√≥n en laberintos, una soluci√≥n candidata (un camino) se puede representar gen√©ticamente de varias maneras. Una de las m√°s efectivas y naturales es como una **secuencia ordenada de posiciones (coordenadas) en la cuadr√≠cula del laberinto**.</p>
      <p>Por ejemplo, si el laberinto es una matriz 2D, cada posici√≥n puede ser una tupla <code>(fila, columna)</code>. Un individuo (camino) ser√≠a una lista de estas tuplas:</p>
      <p><code>Camino = [(start_fila, start_col), (fila1, col1), (fila2, col2), ..., (end_fila, end_col)]</code></p>
      <p><strong>Caracter√≠sticas y Ventajas de esta Representaci√≥n:</strong></p>
      <ul>
        <li><strong>Claridad:</strong> Representa directamente la trayectoria del agente.</li>
        <li><strong>Validez de Pasos:</strong> Se puede verificar f√°cilmente si cada paso de una posici√≥n a la siguiente es v√°lido (adyacente y no a trav√©s de una pared).</li>
        <li><strong>Operadores Gen√©ticos:</strong>
          <ul>
            <li><strong>Cruzamiento:</strong> Se pueden aplicar operadores como el cruce de un punto, donde dos caminos padres intercambian sus segmentos despu√©s de un punto de corte. Es crucial implementar un mecanismo de "reparaci√≥n" para asegurar que el camino resultante sea topol√≥gicamente v√°lido (conectado) despu√©s del cruce, ya que los segmentos podr√≠an no unirse correctamente.</li>
            <li><strong>Mutaci√≥n:</strong> Se pueden a√±adir/eliminar/modificar pasos en el camino, por ejemplo, insertando una nueva celda v√°lida, eliminando una celda (si las adyacentes se pueden conectar), o reemplazando un sub-segmento del camino por otro.</li>
          </ul>
        </li>
        <li><strong>Flexibilidad en Longitud:</strong> Los caminos pueden tener longitudes variables, lo que es natural para este problema.</li>
      </ul>
      <p>Alternativamente, se podr√≠a codificar como una secuencia de movimientos (ej. "arriba", "abajo", "izquierda", "derecha"), pero esto puede ser m√°s dif√≠cil de manejar con operadores gen√©ticos para asegurar la validez y evitar bucles innecesarios sin mecanismos de reparaci√≥n m√°s complejos. La secuencia de posiciones suele ser m√°s directa para la evaluaci√≥n y manipulaci√≥n gen√©tica en el contexto de laberintos.</p>
    </div>

    <!-- Pregunta 10 -->
    <button class="section-toggle-button" onclick="toggleSection('faq_lab_2', this)" aria-expanded="false" aria-controls="faq_lab_2">
      <span>10. Describa algunos criterios que podr√≠an incluirse en una funci√≥n de fitness para un AG que resuelve laberintos.</span><span class="icon">‚ñ∫</span>
    </button>
    <div id="faq_lab_2" class="content-panel">
      <p><strong class="panel-label">Respuesta Detallada:</strong></p>
      <p>Una funci√≥n de fitness robusta para un AG que resuelve laberintos es multifac√©tica y debe guiar la evoluci√≥n hacia caminos v√°lidos, eficientes y que alcancen el objetivo. Algunos criterios clave incluyen:</p>
      <ol>
        <li><strong>Alcance del Objetivo:</strong>
          <ul>
            <li>Se otorga una recompensa significativamente alta (o una penalizaci√≥n muy baja) si el camino alcanza la celda objetivo (fin del laberinto). Este suele ser el componente m√°s importante del fitness.</li>
          </ul>
        </li>
        <li><strong>Longitud del Camino:</strong>
          <ul>
            <li>Se penaliza la longitud excesiva del camino. Caminos m√°s cortos, especialmente si alcanzan el objetivo, son preferibles. La penalizaci√≥n puede ser proporcional al n√∫mero de pasos.</li>
          </ul>
        </li>
        <li><strong>Distancia al Objetivo (si no se alcanza):</strong>
          <ul>
            <li>Para caminos que no llegan al final, se puede usar una heur√≠stica como la distancia de Manhattan o Euclidiana desde la √∫ltima celda del camino hasta la celda objetivo. Una menor distancia resulta en una menor penalizaci√≥n (o mayor fitness relativo), guiando la b√∫squeda.</li>
          </ul>
        </li>
        <li><strong>Penalizaci√≥n por Bucles o Redundancia:</strong>
          <ul>
            <li>Visitar repetidamente las mismas celdas o segmentos del laberinto es ineficiente. Se puede penalizar la diferencia entre la longitud total del camino y el n√∫mero de celdas √∫nicas visitadas.</li>
          </ul>
        </li>
        <li><strong>Validez del Camino (Impl√≠cita o Expl√≠cita):</strong>
          <ul>
            <li>Impl√≠citamente, los operadores gen√©ticos y la generaci√≥n de individuos deber√≠an intentar producir caminos v√°lidos (sin atravesar paredes, movimientos adyacentes). Si se permiten caminos inv√°lidos durante la evoluci√≥n (para luego repararlos), deben ser fuertemente penalizados.</li>
            <li>Un camino que no comienza en la celda de inicio tambi√©n debe ser penalizado severamente.</li>
          </ul>
        </li>
        <li><strong>Penalizaci√≥n por Pasos Inv√°lidos (si se permiten temporalmente):</strong>
          <ul>
            <li>Si un camino contiene movimientos no v√°lidos (ej. a trav√©s de paredes o diagonales si no est√°n permitidas), cada paso inv√°lido debe incurrir en una penalizaci√≥n.</li>
          </ul>
        </li>
      </ol>
      <p>El dise√±o exacto y la ponderaci√≥n de estos criterios son cruciales. Por ejemplo, se podr√≠a usar una base alta de fitness, sustraer penalizaciones por longitud y distancia al objetivo, y a√±adir una gran bonificaci√≥n si se alcanza el final. El objetivo es crear un gradiente de fitness que gu√≠e a la poblaci√≥n de manera efectiva.</p>
    </div>

    <h2 class="section-group-title">Conceptos Avanzados y AlphaEvolve</h2>

    <!-- Pregunta 11 -->
    <button class="section-toggle-button" onclick="toggleSection('faq_ag_adv_1', this)" aria-expanded="false" aria-controls="faq_ag_adv_1">
      <span>11. ¬øQu√© es la mutaci√≥n adaptativa en los Algoritmos Gen√©ticos y c√≥mo funciona?</span><span class="icon">‚ñ∫</span>
    </button>
    <div id="faq_ag_adv_1" class="content-panel">
      <p><strong class="panel-label">Respuesta Detallada:</strong></p>
      <p>La mutaci√≥n adaptativa es una t√©cnica avanzada en Algoritmos Gen√©ticos donde la **tasa de mutaci√≥n (la probabilidad de que un gen o individuo mute) no es fija, sino que se ajusta din√°micamente** durante el proceso evolutivo. El objetivo es balancear mejor la exploraci√≥n y la explotaci√≥n seg√∫n el estado actual de la poblaci√≥n.</p>
      <p><strong>Funcionamiento T√≠pico:</strong></p>
      <p>La tasa de mutaci√≥n se ajusta bas√°ndose en alguna medida del progreso o diversidad de la poblaci√≥n:</p>
      <ul>
        <li><strong>Basada en Diversidad:</strong>
          <ul>
            <li>Si la <strong>diversidad de la poblaci√≥n es baja</strong> (lo que indica posible convergencia prematura o estancamiento), la tasa de mutaci√≥n se incrementa. Esto introduce m√°s variabilidad, ayudando a la poblaci√≥n a escapar de √≥ptimos locales y explorar nuevas √°reas.</li>
            <li>Si la <strong>diversidad es alta y/o la poblaci√≥n est√° mejorando consistentemente</strong>, la tasa de mutaci√≥n puede disminuirse. Esto permite una explotaci√≥n m√°s fina de las regiones prometedoras encontradas.</li>
            <li>La diversidad puede medirse, por ejemplo, por la distancia promedio (ej. Hamming) entre los individuos o la varianza del fitness.</li>
          </ul>
        </li>
        <li><strong>Basada en el Progreso del Fitness:</strong>
          <ul>
            <li>Si no ha habido mejora en el mejor fitness durante varias generaciones (estancamiento), la tasa de mutaci√≥n podr√≠a aumentarse.</li>
            <li>Si el fitness est√° mejorando r√°pidamente, la tasa podr√≠a mantenerse baja o reducirse.</li>
          </ul>
        </li>
      </ul>
      <p>Generalmente, se establecen l√≠mites m√≠nimos y m√°ximos para la tasa de mutaci√≥n para evitar valores extremos. La mutaci√≥n adaptativa hace al AG m√°s robusto a la elecci√≥n inicial de la tasa de mutaci√≥n y puede mejorar su rendimiento en una variedad de problemas.</p>
    </div>

    <!-- Pregunta 12 -->
    <button class="section-toggle-button" onclick="toggleSection('faq_ag_adv_2', this)" aria-expanded="false" aria-controls="faq_ag_adv_2">
      <span>12. Explique el concepto de "reseteo parcial de poblaci√≥n" y su utilidad.</span><span class="icon">‚ñ∫</span>
    </button>
    <div id="faq_ag_adv_2" class="content-panel">
      <p><strong class="panel-label">Respuesta Detallada:</strong></p>
      <p>El reseteo parcial de poblaci√≥n es un mecanismo de diversificaci√≥n utilizado en Algoritmos Gen√©ticos para combatir el estancamiento y la convergencia prematura. Ocurre cuando el algoritmo detecta que no ha habido una mejora significativa en el mejor fitness de la poblaci√≥n durante un n√∫mero determinado de generaciones (definido por un umbral de estancamiento).</p>
      <p><strong>Funcionamiento:</strong></p>
      <p>Cuando se activa el reseteo parcial:</p>
      <ol>
        <li>Una **porci√≥n de la poblaci√≥n actual es reemplazada** por nuevos individuos generados aleatoriamente (o mediante alguna heur√≠stica de inicializaci√≥n).</li>
        <li>Generalmente, los **mejores individuos (la √©lite)** de la poblaci√≥n actual se preservan y se copian a la nueva poblaci√≥n para no perder las mejores soluciones encontradas hasta el momento.</li>
        <li>El resto de la poblaci√≥n "reemplazada" puede ser una fracci√≥n significativa.</li>
      </ol>
      <p><strong>Utilidad:</strong></p>
      <ul>
        <li><strong>Reintroducci√≥n de Diversidad:</strong> El principal objetivo es inyectar nueva diversidad gen√©tica en una poblaci√≥n que puede haberse vuelto demasiado homog√©nea y convergido a un √≥ptimo local.</li>
        <li><strong>Escape de √ìptimos Locales:</strong> Al introducir soluciones radicalmente diferentes, se le da al AG una nueva oportunidad de explorar otras regiones del espacio de soluciones que podr√≠an contener mejores √≥ptimos.</li>
        <li><strong>Revitalizaci√≥n de la B√∫squeda:</strong> Puede "sacudir" al algoritmo de un estado de estancamiento y reiniciar la b√∫squeda efectiva.</li>
      </ul>
      <p>Es importante que este mecanismo no sea demasiado frecuente ni reemplace a toda la poblaci√≥n (a menos que sea una estrategia espec√≠fica), para no perder por completo el progreso evolutivo acumulado. El reseteo parcial, junto con la preservaci√≥n de la √©lite, busca un equilibrio entre mantener lo bueno y explorar lo nuevo cuando la b√∫squeda se atasca.</p>
    </div>

    <!-- Pregunta 13 -->
    <button class="section-toggle-button" onclick="toggleSection('faq_ag_adv_3', this)" aria-expanded="false" aria-controls="faq_ag_adv_3">
      <span>13. ¬øQu√© es un algoritmo mem√©tico o b√∫squeda local h√≠brida en el contexto de los AG?</span><span class="icon">‚ñ∫</span>
    </button>
    <div id="faq_ag_adv_3" class="content-panel">
      <p><strong class="panel-label">Respuesta Detallada:</strong></p>
      <p>Un algoritmo mem√©tico, tambi√©n conocido como Algoritmo Gen√©tico H√≠brido o B√∫squeda Local H√≠brida, combina la **exploraci√≥n global de un Algoritmo Gen√©tico con la capacidad de explotaci√≥n fina de una t√©cnica de b√∫squeda local (o mejora local)**.</p>
      <p>La idea fundamental es que los AG son buenos para explorar ampliamente el espacio de soluciones e identificar regiones prometedoras, pero pueden no ser tan eficientes para encontrar el √≥ptimo exacto dentro de una regi√≥n una vez localizada. Las t√©cnicas de b√∫squeda local, por otro lado, son expertas en refinar una soluci√≥n existente movi√©ndose hacia los mejores vecinos en su vecindad inmediata.</p>
      <p><strong>Funcionamiento T√≠pico:</strong></p>
      <ol>
        <li>El AG opera de manera est√°ndar (selecci√≥n, cruce, mutaci√≥n) para generar nuevos individuos.</li>
        <li>En ciertos puntos del proceso evolutivo, se aplica un procedimiento de b√∫squeda local a algunos o todos los individuos de la poblaci√≥n. Esto puede ocurrir:
            <ul>
              <li>A cada nuevo individuo generado.</li>
              <li>Solo a los mejores individuos (la √©lite).</li>
              <li>Peri√≥dicamente, cada cierto n√∫mero de generaciones.</li>
              <li>Cuando se detecta estancamiento.</li>
            </ul>
        </li>
        <li>El individuo resultante de la b√∫squeda local (que es una versi√≥n mejorada del original dentro de su vecindario) reemplaza al individuo original en la poblaci√≥n.</li>
      </ol>
      <p><strong>Ventajas:</strong></p>
      <ul>
        <li><strong>Mejora de la Calidad de la Soluci√≥n:</strong> Suelen encontrar soluciones de mayor calidad que un AG puro.</li>
        <li><strong>Convergencia M√°s R√°pida:</strong> Pueden converger m√°s r√°pidamente a buenas soluciones al refinar eficientemente las soluciones prometedoras.</li>
      </ul>
      <p>El t√©rmino "mem√©tico" se refiere a la idea de "memes" como unidades de cultura o aprendizaje que se transmiten y refinan, an√°logamente a c√≥mo la b√∫squeda local refina las soluciones ("genes") generadas por el AG.</p>
    </div>

    <!-- Pregunta 14 -->
    <button class="section-toggle-button" onclick="toggleSection('faq_ae_1', this)" aria-expanded="false" aria-controls="faq_ae_1">
      <span>14. ¬øC√≥mo difiere AlphaEvolve de enfoques evolutivos anteriores como FunSearch en t√©rminos de escala y capacidades?</span><span class="icon">‚ñ∫</span>
    </button>
    <div id="faq_ae_1" class="content-panel">
      <p><strong class="panel-label">Respuesta Detallada:</strong></p>
      <p>AlphaEvolve representa una evoluci√≥n significativa sobre sistemas anteriores como FunSearch, ampliando considerablemente la escala y las capacidades de la evoluci√≥n de c√≥digo guiada por LLMs:</p>
      <ol>
        <li><strong>Escala de Evoluci√≥n del C√≥digo:</strong>
          <ul>
            <li><strong>FunSearch:</strong> Se enfocaba en evolucionar funciones peque√±as y aisladas, t√≠picamente escritas en Python y de pocas l√≠neas de c√≥digo. El objetivo era descubrir heur√≠sticas o funciones matem√°ticas concisas.</li>
            <li><strong>AlphaEvolve:</strong> Est√° dise√±ado para operar sobre **archivos de c√≥digo completos** y puede modificar **bloques de c√≥digo extensos** (cientos de l√≠neas). Puede integrarse con bases de c√≥digo existentes mediante la anotaci√≥n de "bloques de evoluci√≥n".</li>
          </ul>
        </li>
        <li><strong>Flexibilidad Ling√º√≠stica:</strong>
          <ul>
            <li><strong>FunSearch:</strong> Principalmente orientado a Python.</li>
            <li><strong>AlphaEvolve:</strong> Puede trabajar con **diversos lenguajes de programaci√≥n**, como se demostr√≥ con Verilog para dise√±o de hardware o IRs de compiladores.</li>
          </ul>
        </li>
        <li><strong>Modelos de Lenguaje y Contexto:</strong>
          <ul>
            <li><strong>FunSearch:</strong> Utilizaba LLMs m√°s peque√±os y un contexto de prompt relativamente simple.</li>
            <li><strong>AlphaEvolve:</strong> Emplea un **ensamblaje de LLMs de √∫ltima generaci√≥n (SOTA)** como Gemini 2.0 Pro y Flash. Utiliza un **contexto de prompt mucho m√°s rico y din√°mico**, que puede incluir soluciones previas, resultados de evaluaci√≥n, documentaci√≥n externa (PDFs), e incluso **meta-prompts** que son evolucionados por el propio sistema para mejorar la forma en que interact√∫a con los LLMs.</li>
          </ul>
        </li>
        <li><strong>Objetivos de Optimizaci√≥n:</strong>
          <ul>
            <li><strong>FunSearch:</strong> Generalmente optimizaba una √∫nica m√©trica o funci√≥n objetivo.</li>
            <li><strong>AlphaEvolve:</strong> Soporta la **optimizaci√≥n multiobjetivo**, permitiendo evolucionar soluciones que balanceen diferentes criterios (ej. eficiencia, simplicidad, rendimiento bajo diversas condiciones).</li>
          </ul>
        </li>
        <li><strong>Formato de Modificaci√≥n de C√≥digo:</strong>
          <ul>
            <li><strong>AlphaEvolve:</strong> Utiliza un formato de "diff" (diferencias) para proponer cambios espec√≠ficos y dirigidos al c√≥digo, aunque tambi√©n puede reescribir bloques enteros. Esto es m√°s adecuado para trabajar con c√≥digo extenso y existente.</li>
          </ul>
        </li>
        <li><strong>Capacidad de Aplicaci√≥n:</strong>
          <ul>
            <li>Debido a las mejoras anteriores, AlphaEvolve puede abordar problemas mucho m√°s complejos y de mayor impacto pr√°ctico, como la optimizaci√≥n de infraestructuras computacionales cr√≠ticas o el dise√±o de algoritmos para problemas cient√≠ficos fundamentales, tareas que estaban fuera del alcance de FunSearch.</li>
          </ul>
        </li>
      </ol>
      <p>En esencia, AlphaEvolve lleva la idea de la evoluci√≥n de c√≥digo guiada por LLMs a un nivel de madurez y aplicabilidad industrial y cient√≠fica mucho mayor.</p>
    </div>

    <!-- Pregunta 15 -->
    <button class="section-toggle-button" onclick="toggleSection('faq_ae_2', this)" aria-expanded="false" aria-controls="faq_ae_2">
      <span>15. ¬øQu√© papel juega el "Prompt Sampler" y la "Base de Datos de Programas" en el funcionamiento de AlphaEvolve?</span><span class="icon">‚ñ∫</span>
    </button>
    <div id="faq_ae_2" class="content-panel">
      <p><strong class="panel-label">Respuesta Detallada:</strong></p>
      <p>El "Prompt Sampler" y la "Base de Datos de Programas" son componentes cruciales en el bucle evolutivo de AlphaEvolve, trabajando conjuntamente para guiar la generaci√≥n de nuevas soluciones de c√≥digo:</p>
      <ul>
        <li><strong>Base de Datos de Programas (Program Database):</strong>
          <ul>
            <li><strong>Funci√≥n:</strong> Act√∫a como la "memoria" del proceso evolutivo. Almacena todas las soluciones (programas o fragmentos de c√≥digo) que han sido generadas y evaluadas, junto con sus puntuaciones de fitness, resultados de evaluaci√≥n, y otros metadatos relevantes.</li>
            <li><strong>Importancia:</strong>
              <ul>
                <li><strong>Preservaci√≥n del Conocimiento:</strong> Asegura que las buenas soluciones encontradas no se pierdan y puedan ser reutilizadas o servir de inspiraci√≥n.</li>
                <li><strong>Gu√≠a para la Evoluci√≥n:</strong> Proporciona el material base para la selecci√≥n de "progenitores" y para la construcci√≥n de prompts informativos.</li>
                <li><strong>Mantenimiento de Diversidad:</strong> Implementa estrategias (inspiradas en MAP-Elites y modelos de islas) para equilibrar la exploraci√≥n y la explotaci√≥n, almacenando no solo las mejores soluciones absolutas sino tambi√©n soluciones diversas que destacan en diferentes aspectos o nichos.</li>
              </ul>
            </li>
          </ul>
        </li>
        <li><strong>Muestreador de Prompts (Prompt Sampler):</strong>
          <ul>
            <li><strong>Funci√≥n:</strong> Es responsable de construir los prompts que se env√≠an a los LLMs para generar nuevas modificaciones de c√≥digo. Para ello, extrae informaci√≥n de la Base de Datos de Programas y de otras fuentes.</li>
            <li><strong>Construcci√≥n de Prompts Ricos:</strong>
              <ul>
                <li><strong>Selecci√≥n de Ejemplos:</strong> Muestrea programas "padre" o soluciones previas exitosas de la base de datos para incluirlos en el prompt como ejemplos de buen rendimiento o como base para la modificaci√≥n.</li>
                <li><strong>Contexto Expl√≠cito:</strong> Incorpora detalles sobre el problema, instrucciones espec√≠ficas proporcionadas por el usuario, documentaci√≥n relevante, e incluso los resultados de evaluaci√≥n de los programas muestreados.</li>
                <li><strong>Meta-Prompts:</strong> Puede utilizar "meta-instrucciones" (que tambi√©n pueden ser evolucionadas) para refinar la tarea que se le pide al LLM (ej. "sugiere una modificaci√≥n que mejore la eficiencia manteniendo la legibilidad").</li>
                <li><strong>Formato Estoc√°stico:</strong> Puede usar plantillas con alternativas para variar la estructura del prompt y fomentar la diversidad en las respuestas del LLM.</li>
              </ul>
            </li>
            <li><strong>Importancia:</strong> La calidad del prompt es determinante para la calidad de las sugerencias del LLM. Un buen Prompt Sampler asegura que los LLMs reciban la informaci√≥n m√°s √∫til y relevante para proponer cambios que realmente mejoren el c√≥digo seg√∫n los objetivos definidos.</li>
          </ul>
        </li>
      </ul>
      <p>En conjunto, la Base de Datos de Programas provee la "experiencia acumulada" y el Prompt Sampler la traduce en "instrucciones efectivas" para que los LLMs impulsen la evoluci√≥n del c√≥digo de manera inteligente.</p>
    </div>

    <!-- Pregunta 16 -->
    <button class="section-toggle-button" onclick="toggleSection('faq_ae_3', this)" aria-expanded="false" aria-controls="faq_ae_3">
      <span>16. ¬øC√≥mo maneja AlphaEvolve la evaluaci√≥n de las soluciones generadas, especialmente cuando hay m√∫ltiples criterios?</span><span class="icon">‚ñ∫</span>
    </button>
    <div id="faq_ae_3" class="content-panel">
      <p><strong class="panel-label">Respuesta Detallada:</strong></p>
      <p>AlphaEvolve cuenta con un sistema de evaluaci√≥n flexible y potente para calificar las soluciones de c√≥digo generadas, capaz de manejar m√∫ltiples criterios y optimizar la eficiencia del proceso:</p>
      <ol>
        <li><strong>Funci√≥n de Evaluaci√≥n Definida por el Usuario (<code>evaluate</code>):</strong>
          <ul>
            <li>El usuario proporciona una funci√≥n (t√≠picamente en Python) que toma una soluci√≥n generada (c√≥digo) como entrada y devuelve un conjunto de m√©tricas escalares que cuantifican su rendimiento. Estas m√©tricas se maximizan por convenci√≥n.</li>
          </ul>
        </li>
        <li><strong>Optimizaci√≥n Multiobjetivo:</strong>
          <ul>
            <li>AlphaEvolve puede optimizar simult√°neamente **m√∫ltiples m√©tricas de evaluaci√≥n**. Por ejemplo, podr√≠a buscar un c√≥digo que no solo sea r√°pido (m√©trica 1) sino tambi√©n eficiente en memoria (m√©trica 2) y simple o legible (m√©trica 3).</li>
            <li>Esto es valioso porque programas que sobresalen en diferentes criterios a menudo poseen estructuras distintas. Al incorporar ejemplos diversos y de alto rendimiento (seg√∫n diferentes definiciones de "bueno") en los prompts, se estimula la generaci√≥n de soluciones m√°s variadas y se aumentan las posibilidades de encontrar enfoques novedosos y efectivos, incluso si el inter√©s final es una √∫nica m√©trica.</li>
          </ul>
        </li>
        <li><strong>Cascada de Evaluaci√≥n (Pruebas de Hip√≥tesis):</strong>
          <ul>
            <li>Para problemas complejos o cuando la evaluaci√≥n es costosa, el usuario puede definir una **secuencia de conjuntos de pruebas de dificultad creciente**.</li>
            <li>Las nuevas soluciones se eval√∫an primero en los casos m√°s simples o a peque√±a escala. Solo si alcanzan resultados prometedores en una etapa, avanzan a la siguiente etapa m√°s dif√≠cil.</li>
            <li>Esto ayuda a **podar r√°pidamente las soluciones menos prometedoras**, ahorrando recursos computacionales y tiempo, y filtrando programas defectuosos tempranamente.</li>
          </ul>
        </li>
        <li><strong>Evaluaci√≥n Paralelizada:</strong>
          <ul>
            <li>La evaluaci√≥n de cada nueva soluci√≥n puede ser computacionalmente intensiva (ej. ejecutar simulaciones, compilar y correr benchmarks). AlphaEvolve est√° dise√±ado para **distribuir este trabajo de evaluaci√≥n de forma as√≠ncrona** a trav√©s de un cl√∫ster de evaluaci√≥n. Esto es crucial para mantener un alto rendimiento (throughput) del sistema, permitiendo evaluar muchas ideas en paralelo.</li>
          </ul>
        </li>
        <li><strong>Retroalimentaci√≥n Generada por LLM para M√©tricas Cualitativas:</strong>
          <ul>
            <li>Para caracter√≠sticas deseables que son dif√≠ciles de cuantificar program√°ticamente (ej. simplicidad del c√≥digo, legibilidad, mantenibilidad), AlphaEvolve puede utilizar **LLMs separados para calificar estos aspectos**. Estas puntuaciones cualitativas pueden a√±adirse al diccionario de m√©tricas para guiar la evoluci√≥n o usarse para descartar soluciones que no cumplan ciertos criterios cualitativos.</li>
          </ul>
        </li>
      </ol>
      <p>Este sistema de evaluaci√≥n multifac√©tico permite a AlphaEvolve abordar problemas complejos con requisitos diversos y hacerlo de manera eficiente.</p>
    </div>

    <h2 class="section-group-title">Consideraciones Conceptuales Adicionales</h2>

    <!-- Pregunta 17 (Nueva) -->
    <button class="section-toggle-button" onclick="toggleSection('faq_concept_1', this)" aria-expanded="false" aria-controls="faq_concept_1">
      <span>17. ¬øCu√°l es el papel de la diversidad en una poblaci√≥n de un AG y qu√© mecanismos se usan para mantenerla?</span><span class="icon">‚ñ∫</span>
    </button>
    <div id="faq_concept_1" class="content-panel">
      <p><strong class="panel-label">Respuesta Detallada:</strong></p>
      <p>La diversidad gen√©tica dentro de la poblaci√≥n de un Algoritmo Gen√©tico es fundamental para su √©xito a largo plazo. Se refiere a la variedad de soluciones (cromosomas) presentes en la poblaci√≥n en un momento dado.</p>
      <p><strong>Papel de la Diversidad:</strong></p>
      <ul>
        <li><strong>Prevenci√≥n de Convergencia Prematura:</strong> Si la poblaci√≥n se vuelve demasiado homog√©nea (baja diversidad), el AG puede converger r√°pidamente a un √≥ptimo local, que podr√≠a no ser el √≥ptimo global. Una poblaci√≥n diversa asegura que se exploren diferentes regiones del espacio de soluciones.</li>
        <li><strong>Exploraci√≥n Continua:</strong> La diversidad proporciona el "material crudo" para que los operadores de cruzamiento y mutaci√≥n generen nuevas soluciones potencialmente mejores. Sin ella, la evoluci√≥n se estanca.</li>
        <li><strong>Robustez:</strong> Una poblaci√≥n diversa puede adaptarse mejor a paisajes de fitness complejos y rugosos.</li>
      </ul>
      <p><strong>Mecanismos para Mantener la Diversidad:</strong></p>
      <ul>
        <li><strong>Mutaci√≥n:</strong> Es el principal mecanismo para introducir nueva informaci√≥n gen√©tica y mantener la diversidad. Una tasa de mutaci√≥n adecuada es crucial.</li>
        <li><strong>Tasas de Cruzamiento Altas:</strong> Fomentan la recombinaci√≥n de diferentes genes, aunque por s√≠ solas no garantizan diversidad si los padres son muy similares.</li>
        <li><strong>Selecci√≥n Menos Agresiva:</strong> M√©todos de selecci√≥n como el torneo (con un tama√±o de torneo peque√±o) o la ruleta pueden dar m√°s oportunidades a individuos menos aptos pero diferentes, preservando la diversidad.</li>
        <li><strong>Mutaci√≥n Adaptativa:</strong> Incrementar la tasa de mutaci√≥n cuando la diversidad es baja.</li>
        <li><strong>Reseteo Parcial de Poblaci√≥n:</strong> Reintroducir individuos aleatorios cuando se detecta estancamiento.</li>
        <li><strong>Mecanismos de Nicho (Niching):</strong> Fomentar la formaci√≥n de subpoblaciones que se especializan en diferentes regiones del espacio de soluciones (ej. fitness sharing, crowding).</li>
        <li><strong>Tama√±o de Poblaci√≥n Adecuado:</strong> Poblaciones muy peque√±as tienden a perder diversidad r√°pidamente debido a la deriva gen√©tica.</li>
        <li><strong>Evitar Duplicados Excesivos:</strong> Algunas estrategias penalizan o evitan la presencia de demasiados individuos id√©nticos en la poblaci√≥n.</li>
      </ul>
      <p>Un equilibrio entre la presi√≥n selectiva (que tiende a reducir la diversidad) y los mecanismos de mantenimiento de diversidad es esencial para un AG efectivo.</p>
    </div>

    <!-- Pregunta 18 (Nueva) -->
    <button class="section-toggle-button" onclick="toggleSection('faq_concept_2', this)" aria-expanded="false" aria-controls="faq_concept_2">
      <span>18. Compare la exploraci√≥n y la explotaci√≥n en el contexto de los AG. ¬øC√≥mo se equilibran estos dos aspectos?</span><span class="icon">‚ñ∫</span>
    </button>
    <div id="faq_concept_2" class="content-panel">
      <p><strong class="panel-label">Respuesta Detallada:</strong></p>
      <p>La exploraci√≥n y la explotaci√≥n son dos fuerzas fundamentales y a menudo contrapuestas que deben equilibrarse cuidadosamente en cualquier algoritmo de b√∫squeda heur√≠stica, incluidos los Algoritmos Gen√©ticos.</p>
      <ul>
        <li><strong>Exploraci√≥n (Exploration):</strong>
          <ul>
            <li><strong>Definici√≥n:</strong> Se refiere al proceso de investigar regiones desconocidas o poco visitadas del espacio de soluciones. El objetivo es descubrir nuevas √°reas que potencialmente podr√≠an contener soluciones de alta calidad.</li>
            <li><strong>Mecanismos en AG:</strong> Principalmente la <strong>mutaci√≥n</strong>, que introduce variabilidad aleatoria. Tambi√©n contribuyen la inicializaci√≥n diversa de la poblaci√≥n y, en cierta medida, el cruzamiento cuando combina padres gen√©ticamente distantes.</li>
            <li><strong>Importancia:</strong> Evita quedar atrapado en √≥ptimos locales y aumenta la probabilidad de encontrar el √≥ptimo global.</li>
          </ul>
        </li>
        <li><strong>Explotaci√≥n (Exploitation):</strong>
          <ul>
            <li><strong>Definici√≥n:</strong> Se refiere al proceso de refinar y mejorar las soluciones ya conocidas que han demostrado ser prometedoras. El objetivo es converger hacia el mejor punto dentro de una regi√≥n ya identificada.</li>
            <li><strong>Mecanismos en AG:</strong> Principalmente la <strong>selecci√≥n</strong> (que favorece a los individuos m√°s aptos) y el <strong>cruzamiento</strong> (que combina los "bloques constructivos" de individuos aptos). El elitismo tambi√©n es una forma fuerte de explotaci√≥n.</li>
            <li><strong>Importancia:</strong> Permite que el algoritmo converja hacia soluciones de alta calidad una vez que se han encontrado regiones prometedoras.</li>
          </ul>
        </li>
      </ul>
      <p><strong>Equilibrio entre Exploraci√≥n y Explotaci√≥n:</strong></p>
      <p>El rendimiento de un AG depende cr√≠ticamente del equilibrio adecuado entre estas dos fuerzas:</p>
      <ul>
        <li><strong>Demasiada Exploraci√≥n (poca explotaci√≥n):</strong> El algoritmo puede vagar por el espacio de soluciones sin converger nunca a una soluci√≥n buena. La b√∫squeda se vuelve demasiado aleatoria.</li>
        <li><strong>Demasiada Explotaci√≥n (poca exploraci√≥n):</strong> El algoritmo puede converger prematuramente a un √≥ptimo local, perdiendo la oportunidad de encontrar mejores soluciones en otras partes del espacio.</li>
      </ul>
      <p>Los AG intentan equilibrar esto a trav√©s de:</p>
      <ul>
        <li><strong>Fases de B√∫squeda:</strong> A menudo, la exploraci√≥n domina en las primeras generaciones (cuando la diversidad es alta), y la explotaci√≥n se vuelve m√°s prominente en etapas posteriores a medida que la poblaci√≥n converge.</li>
        <li><strong>Par√°metros del Algoritmo:</strong> La tasa de mutaci√≥n (principalmente exploraci√≥n), la tasa de cruzamiento (principalmente explotaci√≥n/recombinaci√≥n), la presi√≥n selectiva (explotaci√≥n), y el tama√±o de la poblaci√≥n influyen en este equilibrio.</li>
        <li><strong>Mecanismos Avanzados:</strong> T√©cnicas como la mutaci√≥n adaptativa, el reseteo parcial, y los algoritmos mem√©ticos (con b√∫squeda local) est√°n dise√±adas expl√≠citamente para gestionar mejor este equilibrio din√°micamente.</li>
      </ul>
      <p>Lograr el equilibrio √≥ptimo suele ser dependiente del problema y a menudo requiere experimentaci√≥n y ajuste de par√°metros.</p>
    </div>

    <!-- Pregunta 19 (Nueva) -->
    <button class="section-toggle-button" onclick="toggleSection('faq_concept_3', this)" aria-expanded="false" aria-controls="faq_concept_3">
      <span>19. ¬øCu√°les son las principales ventajas y desventajas de utilizar Algoritmos Gen√©ticos para la optimizaci√≥n?</span><span class="icon">‚ñ∫</span>
    </button>
    <div id="faq_concept_3" class="content-panel">
      <p><strong class="panel-label">Respuesta Detallada:</strong></p>
      <p>Los Algoritmos Gen√©ticos ofrecen un enfoque potente y flexible para la optimizaci√≥n, pero tambi√©n tienen sus limitaciones.</p>
      <p><strong>Ventajas:</strong></p>
      <ol>
        <li><strong>Robustez en Paisajes Complejos:</strong> Son eficaces en espacios de b√∫squeda grandes, complejos, multimodales (con muchos √≥ptimos locales) y no diferenciables, donde los m√©todos basados en gradiente fallar√≠an.</li>
        <li><strong>Exploraci√≥n Global:</strong> Su naturaleza poblacional y el operador de mutaci√≥n les permiten explorar una amplia gama de soluciones, reduciendo la probabilidad de quedar atrapados en √≥ptimos locales de baja calidad.</li>
        <li><strong>Paralelizaci√≥n Inherente:</strong> La evaluaci√≥n del fitness de los individuos de la poblaci√≥n se puede realizar en paralelo, lo que los hace adecuados para arquitecturas de c√≥mputo modernas.</li>
        <li><strong>Flexibilidad en la Representaci√≥n:</strong> Pueden adaptarse a una gran variedad de tipos de problemas mediante diferentes esquemas de codificaci√≥n (binaria, real, permutaciones, √°rboles, etc.).</li>
        <li><strong>No Requieren Informaci√≥n del Gradiente:</strong> Funcionan bas√°ndose √∫nicamente en la funci√≥n de fitness, sin necesidad de derivadas u otra informaci√≥n auxiliar sobre el problema.</li>
        <li><strong>Adaptabilidad a Restricciones:</strong> Las restricciones del problema pueden incorporarse a menudo en la funci√≥n de fitness mediante penalizaciones o mediante operadores gen√©ticos especializados que preservan la viabilidad.</li>
      </ol>
      <p><strong>Desventajas:</strong></p>
      <ol>
        <li><strong>Convergencia Lenta:</strong> Pueden requerir un n√∫mero significativo de evaluaciones de la funci√≥n de fitness (muchas generaciones) para converger a soluciones de alta calidad, especialmente en problemas muy grandes.</li>
        <li><strong>Ajuste de Par√°metros:</strong> El rendimiento de un AG puede ser sensible a la elecci√≥n de sus par√°metros (tama√±o de poblaci√≥n, tasas de mutaci√≥n/cruce, m√©todo de selecci√≥n, etc.), que a menudo deben ajustarse emp√≠ricamente.</li>
        <li><strong>No Hay Garant√≠a de Optimalidad Global:</strong> Como heur√≠sticas, no garantizan encontrar la soluci√≥n √≥ptima global, aunque suelen encontrar soluciones muy buenas o casi √≥ptimas.</li>
        <li><strong>Convergencia Prematura:</strong> Si no se maneja adecuadamente la diversidad, pueden converger prematuramente a un √≥ptimo local.</li>
        <li><strong>Dise√±o de la Funci√≥n de Fitness:</strong> Definir una funci√≥n de fitness adecuada que gu√≠e correctamente la evoluci√≥n puede ser un desaf√≠o en algunos problemas.</li>
        <li><strong>Complejidad de la Implementaci√≥n:</strong> Aunque los conceptos b√°sicos son simples, una implementaci√≥n robusta y eficiente con mecanismos avanzados puede ser compleja.</li>
      </ol>
    </div>

    <!-- Pregunta 20 (Nueva) -->
    <button class="section-toggle-button" onclick="toggleSection('faq_concept_4', this)" aria-expanded="false" aria-controls="faq_concept_4">
      <span>20. En el contexto de AlphaEvolve, ¬øc√≥mo la capacidad de los LLMs para entender y generar c√≥digo transforma los operadores gen√©ticos tradicionales?</span><span class="icon">‚ñ∫</span>
    </button>
    <div id="faq_concept_4" class="content-panel">
      <p><strong class="panel-label">Respuesta Detallada:</strong></p>
      <p>La integraci√≥n de Modelos de Lenguaje de Gran Escala (LLMs) en sistemas como AlphaEvolve transforma radicalmente la naturaleza y capacidad de los operadores gen√©ticos tradicionales (mutaci√≥n y cruzamiento) cuando se aplican a la evoluci√≥n de c√≥digo:</p>
      <ol>
        <li><strong>Operadores Sem√°nticamente Conscientes:</strong>
          <ul>
            <li><strong>Tradicional:</strong> Los operadores gen√©ticos cl√°sicos (ej. inversi√≥n de bit, swap de genes) son a menudo "ciegos" a la sem√°ntica del c√≥digo. Realizan cambios estructurales sin entender la funci√≥n del c√≥digo.</li>
            <li><strong>AlphaEvolve (con LLMs):</strong> Los LLMs act√∫an como operadores que **entienden la sintaxis y, hasta cierto punto, la sem√°ntica del lenguaje de programaci√≥n**. Pueden proponer modificaciones que son no solo sint√°cticamente correctas sino tambi√©n l√≥gicamente coherentes y orientadas a un objetivo (ej. "refactoriza esta funci√≥n para mejorar su eficiencia" o "introduce manejo de errores aqu√≠").</li>
          </ul>
        </li>
        <li><strong>Mutaciones M√°s Inteligentes y Dirigidas:</strong>
          <ul>
            <li><strong>Tradicional:</strong> La mutaci√≥n es t√≠picamente aleatoria y peque√±a (ej. cambiar un bit, intercambiar dos elementos).</li>
            <li><strong>AlphaEvolve:</strong> Los LLMs pueden realizar "mutaciones" mucho m√°s sofisticadas. Pueden reescribir secciones enteras de c√≥digo, introducir nuevos algoritmos o estructuras de datos, o aplicar patrones de dise√±o complejos, bas√°ndose en el contexto proporcionado en el prompt (que incluye el c√≥digo existente y los objetivos de mejora).</li>
          </ul>
        </li>
        <li><strong>Cruzamiento Conceptual:</strong>
          <ul>
            <li><strong>Tradicional:</strong> El cruzamiento combina segmentos de cromosomas padres. En la evoluci√≥n de c√≥digo tradicional (programaci√≥n gen√©tica basada en √°rboles), esto significa intercambiar sub√°rboles.</li>
            <li><strong>AlphaEvolve:</strong> Aunque no se describa un "cruzamiento" directo entre dos programas padres de la misma forma, los LLMs pueden lograr un "cruzamiento conceptual". Al ser expuestos a m√∫ltiples programas exitosos (padres o ejemplos de la base de datos) en el prompt, el LLM puede **sintetizar ideas de diferentes fuentes** para generar una nueva soluci√≥n que combine las fortalezas de varias aproximaciones previas.</li>
          </ul>
        </li>
        <li><strong>Generaci√≥n de Operadores "Sobre la Marcha":</strong>
          <ul>
            <li><strong>Tradicional:</strong> Los operadores gen√©ticos son predefinidos.</li>
            <li><strong>AlphaEvolve:</strong> Los LLMs, guiados por prompts (que pueden ser evolucionados ellos mismos mediante meta-prompts), pueden ser vistos como una forma de **generar o aplicar operadores de modificaci√≥n de c√≥digo de manera adaptativa y contextual**, sin necesidad de que el programador humano defina expl√≠citamente cada posible tipo de transformaci√≥n.</li>
          </ul>
        </li>
        <li><strong>Manejo de C√≥digo Complejo y Extenso:</strong>
          <ul>
            <li><strong>Tradicional:</strong> La evoluci√≥n directa de c√≥digo complejo con operadores tradicionales es muy dif√≠cil debido a la fragilidad y la interdependencia del c√≥digo.</li>
            <li><strong>AlphaEvolve:</strong> Los LLMs, especialmente con su capacidad para trabajar con "diffs" y entender contextos largos, est√°n mejor equipados para proponer cambios coherentes en bases de c√≥digo m√°s grandes y complejas.</li>
          </ul>
        </li>
      </ol>
      <p>En resumen, los LLMs en AlphaEvolve elevan los operadores gen√©ticos de simples manipulaciones sint√°cticas a transformaciones de c√≥digo m√°s inteligentes, sem√°nticamente ricas y dirigidas por objetivos, lo que permite abordar la evoluci√≥n de programas a una escala y complejidad mucho mayores.</p>
    </div>

  </div> <!-- Fin de .faq-container -->

  <script>
    function toggleFaqTheme() {
      document.body.classList.toggle("dark-mode");
      let themeButton = document.getElementById('theme-toggle-faq-btn');
      let isDarkMode = document.body.classList.contains("dark-mode");
      localStorage.setItem("faq_theme_ag_colab_conceptual", isDarkMode ? "dark" : "light"); // Clave √∫nica
      if (themeButton) {
          themeButton.textContent = isDarkMode ? "Modo Claro" : "Modo Oscuro";
      }
    }

    function toggleSection(id, buttonElement) {
      let panel = document.getElementById(id);
      let icon = buttonElement.querySelector('.icon');
      if (panel && buttonElement) {
          panel.classList.toggle('is-visible');
          let isVisible = panel.classList.contains('is-visible');
          buttonElement.setAttribute('aria-expanded', isVisible);
          buttonElement.classList.toggle('is-expanded', isVisible);
          if (icon) {
              icon.textContent = isVisible ? '‚ñº' : '‚ñ∫';
          }
      }
    }

    window.addEventListener('load', () => {
      let themeButton = document.getElementById('theme-toggle-faq-btn');
      const savedTheme = localStorage.getItem("faq_theme_ag_colab_conceptual"); // Usar clave √∫nica

      if (savedTheme === "dark") {
        document.body.classList.add("dark-mode");
        if (themeButton) { themeButton.textContent = "Modo Claro"; }
      } else {
        document.body.classList.remove("dark-mode");
        if (themeButton) { themeButton.textContent = "Modo Oscuro"; }
      }

      document.querySelectorAll('.faq-container .content-panel').forEach(panel => {
         panel.classList.remove('is-visible');
         // panel.style.maxHeight = '0'; // CSS maneja esto con la clase
      });
      document.querySelectorAll('.faq-container .section-toggle-button').forEach(button => {
          button.setAttribute('aria-expanded', 'false');
          button.classList.remove('is-expanded');
          let icon = button.querySelector('.icon');
          if (icon) {
              icon.textContent = '‚ñ∫';
          }
       });
    });
  </script>
</body>
</html>
"""

# Mostrar el HTML en la salida de la celda
display(HTML(html_content))

# Importar las funciones necesarias de IPython para mostrar HTML
from IPython.core.display import display, HTML

# Definir el contenido HTML, CSS y JavaScript como un string multil√≠nea
html_glossary_content = """
<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Glosario: Algoritmos Gen√©ticos, Evoluci√≥n de C√≥digo y Conceptos Relacionados</title>
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&family=Lora:ital,wght@0,400;0,700&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg-color: #fafbfd; /* Un blanco muy sutil, ligeramente azulado */
      --text-color: #3a3f51; /* Un gris oscuro azulado */
      --header-color: #2a72c5; /* Azul principal */
      --header-dark-color: #a3c7f0; /* Azul claro para modo oscuro */
      --accent-color: #10ac84; /* Verde azulado (teal) */
      --accent-dark-color: #58d68d; /* Verde m√°s claro */
      --button-bg: #3498db; /* Azul cielo */
      --button-hover-bg: #2980b9; /* Azul m√°s oscuro */
      --button-dark-bg: #e88e30; /* Naranja */
      --button-dark-hover-bg: #ca6f1e; /* Naranja oscuro */
      --button-text-color: white;
      --theme-button-bg: #9b59b6; /* Amatista */
      --theme-button-dark-bg: #f1c40f; /* Amarillo girasol */
      --content-panel-bg: #f1f8ff; /* Azul muy p√°lido */
      --content-panel-dark-bg: #3a4759; /* Gris azulado oscuro */
      --panel-label-color: var(--accent-color);
      --panel-label-dark-color: var(--accent-dark-color);
      --icon-color: var(--button-text-color);
      --term-title-color: var(--header-color);
      --term-title-dark-color: var(--header-dark-color);
    }

    body {
      font-family: 'Lora', 'Roboto', serif;
      line-height: 1.85;
      background-color: var(--bg-color);
      color: var(--text-color);
      transition: background-color 0.3s, color 0.3s;
      padding: 20px;
      margin: 0;
    }
    .glossary-container {
      max-width: 1000px;
      margin: auto;
      padding: 25px;
      position: relative;
      background-color: var(--bg-color);
      border-radius: 10px;
      box-shadow: 0 4px 15px rgba(0,0,0,0.08);
    }
    body.dark-mode .glossary-container {
        box-shadow: 0 4px 18px rgba(0,0,0,0.3);
    }
    body.dark-mode {
      --bg-color: #283141; /* Azul noche */
      --text-color: #dbe4f0; /* Blanco azulado */
      --header-color: var(--header-dark-color);
      --accent-color: var(--accent-dark-color);
      --button-bg: var(--button-dark-bg);
      --button-hover-bg: var(--button-dark-hover-bg);
      --content-panel-bg: var(--content-panel-dark-bg);
      --panel-label-color: var(--panel-label-dark-color);
      --term-title-color: var(--term-title-dark-color);
    }

    .glossary-container h1 {
      font-family: 'Roboto', sans-serif;
      font-size: 2.5em;
      color: var(--header-color);
      text-align: center;
      margin-bottom: 30px;
      padding-bottom: 12px;
      border-bottom: 3px solid var(--accent-color);
    }
     .glossary-container h2.section-category-title {
        font-family: 'Roboto', sans-serif;
        font-size: 1.7em;
        color: var(--accent-color);
        margin-top: 35px;
        margin-bottom: 10px;
        padding-bottom: 6px;
        border-bottom: 1px solid var(--accent-color);
    }

    .definition-panel {
      max-height: 0;
      overflow: hidden;
      transition: max-height 0.4s ease-in-out, padding-top 0.4s ease-in-out, padding-bottom 0.4s ease-in-out;
      margin-top: 0;
      padding: 0 25px;
      border-left: 5px solid var(--accent-color);
      background-color: var(--content-panel-bg);
      border-radius: 0 0 8px 8px;
    }
    .definition-panel.is-visible {
      max-height: 1500px; /* Ajustar seg√∫n necesidad */
      padding-top: 20px;
      padding-bottom: 20px;
    }
    .definition-panel p, .definition-panel ul, .definition-panel ol {
        margin-bottom: 1.15em;
        font-size: 1.02em;
    }
    .definition-panel p:last-child, .definition-panel ul:last-child, .definition-panel ol:last-child {
        margin-bottom: 0;
    }
    .definition-panel strong.term-label { /* Para "Definici√≥n:" */
        color: var(--panel-label-color);
        font-family: 'Roboto', sans-serif;
        font-size: 1.1em;
        display: block;
        margin-bottom: 0.7em;
    }


    .term-toggle-button {
      background-color: var(--button-bg);
      color: var(--button-text-color);
      border: none;
      padding: 14px 20px;
      border-radius: 8px;
      cursor: pointer;
      margin-top: 10px;
      transition: background-color 0.3s, border-radius 0.2s;
      width: 100%;
      text-align: left;
      font-family: 'Roboto', sans-serif;
      font-size: 1.15em;
      font-weight: 700;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }
    .term-toggle-button:hover {
      background-color: var(--button-hover-bg);
    }
    .term-toggle-button.is-expanded {
        border-radius: 8px 8px 0 0;
    }
    .term-toggle-button .term-text {
        color: var(--button-text-color); /* Hereda, pero expl√≠cito */
    }
    .term-toggle-button .icon {
        margin-left: 12px;
        font-size: 0.9em;
        color: var(--icon-color);
        transition: transform 0.3s ease-out;
    }
    .term-toggle-button.is-expanded .icon {
        transform: rotate(90deg);
    }


    .theme-toggle-glossary {
      background-color: var(--theme-button-bg);
      color: white;
      border: none;
      padding: 10px 15px;
      border-radius: 8px;
      cursor: pointer;
      position: absolute;
      top: 30px;
      right: 25px;
      font-size: 0.9em;
      font-family: 'Roboto', sans-serif;
      transition: background-color 0.3s;
      z-index: 100;
    }
    body.dark-mode .theme-toggle-glossary {
       background-color: var(--theme-button-dark-bg);
       color: var(--text-color);
    }

    button:focus, a:focus {
        outline: 3px solid var(--accent-color);
        outline-offset: 2px;
    }
    body.dark-mode button:focus, body.dark-mode a:focus {
         outline-color: var(--accent-dark-color);
    }
    ul, ol {
        padding-left: 28px;
    }
    li {
        margin-bottom: 0.65em;
    }
    strong {
        font-weight: 700;
    }
    code {
      background-color: rgba(0,0,0,0.05);
      padding: 3px 6px;
      border-radius: 4px;
      font-family: 'Courier New', Courier, monospace;
      font-size: 0.92em;
    }
    body.dark-mode code {
      background-color: rgba(255,255,255,0.12);
    }
  </style>
</head>
<body>
  <div class="glossary-container">
    <button id="theme-toggle-glossary-btn" class="theme-toggle-glossary" onclick="toggleGlossaryTheme()" title="Cambiar tema de color">Modo Oscuro</button>

    <h1>Glosario: Algoritmos Gen√©ticos, Evoluci√≥n de C√≥digo y Conceptos Relacionados</h1>

    <!-- Categor√≠a: Fundamentos de Algoritmos Gen√©ticos -->
    <h2 class="section-category-title">Fundamentos de Algoritmos Gen√©ticos</h2>
    <button class="term-toggle-button" onclick="toggleTerm('term_ag', this)" aria-expanded="false" aria-controls="term_ag">
      <span class="term-text">Algoritmo Gen√©tico (AG)</span><span class="icon">‚ñ∫</span>
    </button>
    <div id="term_ag" class="definition-panel">
      <p><strong class="term-label">Definici√≥n:</strong></p>
      <p>T√©cnica de b√∫squeda metaheur√≠stica inspirada en la evoluci√≥n natural y la selecci√≥n darwiniana. Opera sobre una poblaci√≥n de soluciones candidatas (individuos), aplicando operadores gen√©ticos (selecci√≥n, cruzamiento, mutaci√≥n) para evolucionar iterativamente hacia mejores soluciones con respecto a una funci√≥n de fitness.</p>
    </div>

    <button class="term-toggle-button" onclick="toggleTerm('term_cromosoma', this)" aria-expanded="false" aria-controls="term_cromosoma">
      <span class="term-text">Cromosoma (Individuo)</span><span class="icon">‚ñ∫</span>
    </button>
    <div id="term_cromosoma" class="definition-panel">
      <p><strong class="term-label">Definici√≥n:</strong></p>
      <p>Representaci√≥n codificada de una soluci√≥n candidata a un problema. En un AG, la poblaci√≥n est√° compuesta por m√∫ltiples cromosomas. Su estructura (ej. cadena binaria, permutaci√≥n, √°rbol) depende de la naturaleza del problema.</p>
    </div>

    <button class="term-toggle-button" onclick="toggleTerm('term_fitness', this)" aria-expanded="false" aria-controls="term_fitness">
      <span class="term-text">Funci√≥n de Fitness (Aptitud)</span><span class="icon">‚ñ∫</span>
    </button>
    <div id="term_fitness" class="definition-panel">
      <p><strong class="panel-label">Definici√≥n:</strong></p>
      <p>Funci√≥n que asigna un valor num√©rico a cada individuo (cromosoma) de la poblaci√≥n, indicando su calidad o "aptitud" como soluci√≥n al problema. Gu√≠a el proceso de selecci√≥n, favoreciendo a los individuos m√°s aptos.</p>
    </div>

    <button class="term-toggle-button" onclick="toggleTerm('term_seleccion', this)" aria-expanded="false" aria-controls="term_seleccion">
      <span class="term-text">Selecci√≥n</span><span class="icon">‚ñ∫</span>
    </button>
    <div id="term_seleccion" class="definition-panel">
      <p><strong class="panel-label">Definici√≥n:</strong></p>
      <p>Proceso mediante el cual se eligen individuos de la poblaci√≥n actual para ser progenitores de la siguiente generaci√≥n. M√©todos comunes incluyen la selecci√≥n por torneo, ruleta y elitismo. Est√° sesgada hacia individuos con mayor fitness.</p>
    </div>

    <button class="term-toggle-button" onclick="toggleTerm('term_cruzamiento', this)" aria-expanded="false" aria-controls="term_cruzamiento">
      <span class="term-text">Cruzamiento (Crossover / Recombinaci√≥n)</span><span class="icon">‚ñ∫</span>
    </button>
    <div id="term_cruzamiento" class="definition-panel">
      <p><strong class="panel-label">Definici√≥n:</strong></p>
      <p>Operador gen√©tico que combina material gen√©tico de dos (o m√°s) individuos progenitores para crear uno o m√°s descendientes. Su objetivo es generar nuevas soluciones que hereden caracter√≠sticas deseables de sus padres, promoviendo la explotaci√≥n de regiones prometedoras del espacio de b√∫squeda.</p>
    </div>

    <button class="term-toggle-button" onclick="toggleTerm('term_mutacion', this)" aria-expanded="false" aria-controls="term_mutacion">
      <span class="term-text">Mutaci√≥n</span><span class="icon">‚ñ∫</span>
    </button>
    <div id="term_mutacion" class="definition-panel">
      <p><strong class="panel-label">Definici√≥n:</strong></p>
      <p>Operador gen√©tico que introduce peque√±os cambios aleatorios en el cromosoma de un individuo. Su funci√≥n principal es mantener la diversidad gen√©tica en la poblaci√≥n, prevenir la convergencia prematura y permitir la exploraci√≥n de nuevas √°reas del espacio de soluciones.</p>
    </div>

    <button class="term-toggle-button" onclick="toggleTerm('term_elitismo', this)" aria-expanded="false" aria-controls="term_elitismo">
      <span class="term-text">Elitismo</span><span class="icon">‚ñ∫</span>
    </button>
    <div id="term_elitismo" class="definition-panel">
      <p><strong class="panel-label">Definici√≥n:</strong></p>
      <p>Estrategia que consiste en copiar directamente uno o m√°s de los mejores individuos de la poblaci√≥n actual a la siguiente generaci√≥n, sin someterlos a cruzamiento o mutaci√≥n. Asegura que la mejor soluci√≥n encontrada no se pierda.</p>
    </div>

    <button class="term-toggle-button" onclick="toggleTerm('term_codificacion', this)" aria-expanded="false" aria-controls="term_codificacion">
      <span class="term-text">Codificaci√≥n (Representaci√≥n Gen√©tica)</span><span class="icon">‚ñ∫</span>
    </button>
    <div id="term_codificacion" class="definition-panel">
      <p><strong class="panel-label">Definici√≥n:</strong></p>
      <p>Forma en que una soluci√≥n candidata al problema se traduce en un cromosoma manipulable por el AG. Ejemplos: cadenas binarias, permutaciones (TSP), secuencias de posiciones (laberintos), √°rboles (programaci√≥n gen√©tica), o directamente c√≥digo fuente (AlphaEvolve).</p>
    </div>

    <!-- Categor√≠a: Aplicaciones y Problemas Espec√≠ficos -->
    <h2 class="section-category-title">Aplicaciones y Problemas Espec√≠ficos</h2>
    <button class="term-toggle-button" onclick="toggleTerm('term_tsp', this)" aria-expanded="false" aria-controls="term_tsp">
      <span class="term-text">Problema del Viajante (TSP)</span><span class="icon">‚ñ∫</span>
    </button>
    <div id="term_tsp" class="definition-panel">
      <p><strong class="panel-label">Definici√≥n:</strong></p>
      <p>Problema cl√°sico de optimizaci√≥n combinatoria NP-hard. Consiste en encontrar la ruta m√°s corta posible que visite un conjunto dado de ciudades exactamente una vez y regrese a la ciudad de origen.</p>
    </div>

    <button class="term-toggle-button" onclick="toggleTerm('term_laberinto', this)" aria-expanded="false" aria-controls="term_laberinto">
      <span class="term-text">Navegaci√≥n en Laberintos</span><span class="icon">‚ñ∫</span>
    </button>
    <div id="term_laberinto" class="definition-panel">
      <p><strong class="panel-label">Definici√≥n:</strong></p>
      <p>Problema de encontrar un camino v√°lido y √≥ptimo (ej. m√°s corto) desde un punto de inicio a un punto final en un entorno con obst√°culos (paredes). Com√∫nmente modelado como una cuadr√≠cula o matriz.</p>
    </div>

    <button class="term-toggle-button" onclick="toggleTerm('term_ciclo_hamiltoniano', this)" aria-expanded="false" aria-controls="term_ciclo_hamiltoniano">
      <span class="term-text">Ciclo Hamiltoniano (HC)</span><span class="icon">‚ñ∫</span>
    </button>
    <div id="term_ciclo_hamiltoniano" class="definition-panel">
      <p><strong class="panel-label">Definici√≥n:</strong></p>
      <p>En teor√≠a de grafos, un ciclo en un grafo que visita cada v√©rtice exactamente una vez. Encontrar un ciclo Hamiltoniano es un problema NP-completo. El TSP es una generalizaci√≥n donde se busca el HC de menor coste.</p>
    </div>

    <!-- Categor√≠a: Conceptos Avanzados en AG -->
    <h2 class="section-category-title">Conceptos Avanzados en AG</h2>
    <button class="term-toggle-button" onclick="toggleTerm('term_mut_adaptativa', this)" aria-expanded="false" aria-controls="term_mut_adaptativa">
      <span class="term-text">Mutaci√≥n Adaptativa</span><span class="icon">‚ñ∫</span>
    </button>
    <div id="term_mut_adaptativa" class="definition-panel">
      <p><strong class="panel-label">Definici√≥n:</strong></p>
      <p>T√©cnica donde la tasa de mutaci√≥n se ajusta din√°micamente durante la evoluci√≥n, usualmente en funci√≥n de la diversidad de la poblaci√≥n o del progreso del fitness, para balancear exploraci√≥n y explotaci√≥n.</p>
    </div>

    <button class="term-toggle-button" onclick="toggleTerm('term_reseteo_parcial', this)" aria-expanded="false" aria-controls="term_reseteo_parcial">
      <span class="term-text">Reseteo Parcial de Poblaci√≥n</span><span class="icon">‚ñ∫</span>
    </button>
    <div id="term_reseteo_parcial" class="definition-panel">
      <p><strong class="panel-label">Definici√≥n:</strong></p>
      <p>Mecanismo para combatir el estancamiento que consiste en reemplazar una porci√≥n de la poblaci√≥n (excepto quiz√°s la √©lite) con nuevos individuos generados aleatoriamente, para reintroducir diversidad.</p>
    </div>

    <button class="term-toggle-button" onclick="toggleTerm('term_alg_memetico', this)" aria-expanded="false" aria-controls="term_alg_memetico">
      <span class="term-text">Algoritmo Mem√©tico (B√∫squeda Local H√≠brida)</span><span class="icon">‚ñ∫</span>
    </button>
    <div id="term_alg_memetico" class="definition-panel">
      <p><strong class="panel-label">Definici√≥n:</strong></p>
      <p>Un AG h√≠brido que combina la exploraci√≥n global del AG con t√©cnicas de b√∫squeda local para refinar individuos, mejorando la calidad de la soluci√≥n y la velocidad de convergencia. Ejemplo: aplicar 2-opt en soluciones del TSP.</p>
    </div>

    <button class="term-toggle-button" onclick="toggleTerm('term_map_elites', this)" aria-expanded="false" aria-controls="term_map_elites">
      <span class="term-text">MAP-Elites</span><span class="icon">‚ñ∫</span>
    </button>
    <div id="term_map_elites" class="definition-panel">
      <p><strong class="panel-label">Definici√≥n:</strong></p>
      <p>Algoritmo de iluminaci√≥n que busca encontrar un conjunto de soluciones de alta calidad que sean diversas con respecto a m√∫ltiples dimensiones de caracter√≠sticas definidas por el usuario. Mantiene un archivo (mapa) de las mejores soluciones encontradas para cada celda en un espacio de caracter√≠sticas discretizado.</p>
    </div>

    <!-- Categor√≠a: AlphaEvolve y Evoluci√≥n de C√≥digo -->
    <h2 class="section-category-title">AlphaEvolve y Evoluci√≥n de C√≥digo</h2>
    <button class="term-toggle-button" onclick="toggleTerm('term_alphaevolve', this)" aria-expanded="false" aria-controls="term_alphaevolve">
      <span class="term-text">AlphaEvolve</span><span class="icon">‚ñ∫</span>
    </button>
    <div id="term_alphaevolve" class="definition-panel">
      <p><strong class="panel-label">Definici√≥n:</strong></p>
      <p>Un agente de evoluci√≥n de c√≥digo desarrollado por Google DeepMind que utiliza un ensamblaje de Modelos de Lenguaje de Gran Escala (LLMs) dentro de un marco de computaci√≥n evolutiva para mejorar y descubrir algoritmos y c√≥digo en general. Puede operar sobre archivos de c√≥digo completos y en diversos lenguajes.</p>
    </div>

    <button class="term-toggle-button" onclick="toggleTerm('term_llm', this)" aria-expanded="false" aria-controls="term_llm">
      <span class="term-text">Modelo de Lenguaje de Gran Escala (LLM)</span><span class="icon">‚ñ∫</span>
    </button>
    <div id="term_llm" class="definition-panel">
      <p><strong class="panel-label">Definici√≥n:</strong></p>
      <p>Un modelo de inteligencia artificial entrenado con grandes cantidades de datos de texto (y c√≥digo) capaz de comprender, generar y manipular lenguaje natural y c√≥digo de programaci√≥n. En AlphaEvolve, los LLMs act√∫an como operadores de mutaci√≥n y cruzamiento "inteligentes".</p>
    </div>

    <button class="term-toggle-button" onclick="toggleTerm('term_prompt_sampler', this)" aria-expanded="false" aria-controls="term_prompt_sampler">
      <span class="term-text">Prompt Sampler (Muestreador de Prompts)</span><span class="icon">‚ñ∫</span>
    </button>
    <div id="term_prompt_sampler" class="definition-panel">
      <p><strong class="panel-label">Definici√≥n:</strong></p>
      <p>Componente de AlphaEvolve que construye los prompts (instrucciones) para los LLMs. Utiliza programas de la base de datos evolutiva, contexto expl√≠cito, resultados de evaluaci√≥n y meta-prompts para guiar a los LLMs en la generaci√≥n de modificaciones de c√≥digo √∫tiles.</p>
    </div>

    <button class="term-toggle-button" onclick="toggleTerm('term_meta_prompt', this)" aria-expanded="false" aria-controls="term_meta_prompt">
      <span class="term-text">Meta-Prompt</span><span class="icon">‚ñ∫</span>
    </button>
    <div id="term_meta_prompt" class="definition-panel">
      <p><strong class="panel-label">Definici√≥n:</strong></p>
      <p>En AlphaEvolve, son instrucciones y contexto sugeridos por el propio LLM en un paso adicional de generaci√≥n de prompts. Estos meta-prompts pueden ser co-evolucionados, permitiendo al sistema aprender a mejorar la forma en que solicita modificaciones de c√≥digo a los LLMs.</p>
    </div>

    <button class="term-toggle-button" onclick="toggleTerm('term_diff_codigo', this)" aria-expanded="false" aria-controls="term_diff_codigo">
      <span class="term-text">Diff (Diferencias de C√≥digo)</span><span class="icon">‚ñ∫</span>
    </button>
    <div id="term_diff_codigo" class="definition-panel">
      <p><strong class="panel-label">Definici√≥n:</strong></p>
      <p>Formato utilizado por AlphaEvolve para que los LLMs propongan cambios espec√≠ficos al c√≥digo. Representa las adiciones, eliminaciones y modificaciones a un bloque de c√≥digo original (ej. formato `<<<<<<< SEARCH ... ======= ... >>>>>>> REPLACE`).</p>
    </div>

  </div> <!-- Fin de .glossary-container -->

  <script>
    function toggleGlossaryTheme() {
      document.body.classList.toggle("dark-mode");
      let themeButton = document.getElementById('theme-toggle-glossary-btn');
      let isDarkMode = document.body.classList.contains("dark-mode");
      localStorage.setItem("glossary_theme_colab", isDarkMode ? "dark" : "light"); // Clave √∫nica
      if (themeButton) {
          themeButton.textContent = isDarkMode ? "Modo Claro" : "Modo Oscuro";
      }
    }

    function toggleTerm(id, buttonElement) { // Renombrada para evitar conflictos
      let panel = document.getElementById(id);
      let icon = buttonElement.querySelector('.icon');
      if (panel && buttonElement) {
          panel.classList.toggle('is-visible');
          let isVisible = panel.classList.contains('is-visible');
          buttonElement.setAttribute('aria-expanded', isVisible);
          buttonElement.classList.toggle('is-expanded', isVisible);
          if (icon) {
              icon.textContent = isVisible ? '‚ñº' : '‚ñ∫';
          }
      }
    }

    window.addEventListener('load', () => {
      let themeButton = document.getElementById('theme-toggle-glossary-btn');
      const savedTheme = localStorage.getItem("glossary_theme_colab");

      if (savedTheme === "dark") {
        document.body.classList.add("dark-mode");
        if (themeButton) { themeButton.textContent = "Modo Claro"; }
      } else {
        document.body.classList.remove("dark-mode");
        if (themeButton) { themeButton.textContent = "Modo Oscuro"; }
      }

      document.querySelectorAll('.glossary-container .definition-panel').forEach(panel => {
         panel.classList.remove('is-visible');
      });
      document.querySelectorAll('.glossary-container .term-toggle-button').forEach(button => {
          button.setAttribute('aria-expanded', 'false');
          button.classList.remove('is-expanded');
          let icon = button.querySelector('.icon');
          if (icon) {
              icon.textContent = '‚ñ∫';
          }
       });
    });
  </script>
</body>
</html>
"""

# Mostrar el HTML en la salida de la celda
display(HTML(html_glossary_content))