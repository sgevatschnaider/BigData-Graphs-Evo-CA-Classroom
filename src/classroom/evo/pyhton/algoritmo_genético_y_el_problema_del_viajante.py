# -*- coding: utf-8 -*-
"""Algoritmo_genético_y_el_problema_del_viajante.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1TZHeEzV5YuyXC4SlCBWbTzClo5h4sUP2
"""

# Importar las funciones necesarias de IPython para mostrar HTML
from IPython.core.display import display, HTML

# Definir el contenido HTML, CSS y JavaScript como un string multilínea
html_content = """
<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>AlphaEvolve: AG con Q-learning para el TSP</title>
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&family=Lora:ital,wght@0,400;0,700;1,400&display=swap" rel="stylesheet">
  <style>
    /* Definición de variables CSS para temas */
    :root {
      --bg-color: #fdfefe; /* Blanco hueso */
      --text-color: #34495e; /* Azul pizarra */
      --header-color: #2c3e50; /* Azul medianoche */
      --header-dark-color: #bdc3c7; /* Plata */
      --accent-color: #16a085; /* Verde mar */
      --accent-dark-color: #48c9b0; /* Turquesa */
      --button-bg: #3498db; /* Azul Peter River */
      --button-hover-bg: #2980b9; /* Azul Belize Hole */
      --button-dark-bg: #8e44ad; /* Amatista */
      --button-dark-hover-bg: #9b59b6; /* Lila */
      --button-text-color: white;
      --theme-button-bg: #7f8c8d; /* Gris asfalto */
      --theme-button-dark-bg: #f39c12; /* Naranja */
      --content-panel-bg: #ecf0f1; /* Nubes */
      --content-panel-dark-bg: #3b5368; /* Un gris azulado más oscuro */
      --author-color: #566573; /* Gris pizarra más claro */
      --index-button-bg: #5dade2; /* Azul claro para botones de índice */
      --index-button-hover-bg: #2e86c1;
      --index-button-dark-bg: #af7ac5; /* Morado claro para índice oscuro */
      --index-button-dark-hover-bg: #9b59b6;
    }

    body {
      font-family: 'Lora', 'Roboto', serif;
      line-height: 1.9;
      background-color: var(--bg-color);
      color: var(--text-color);
      transition: background-color 0.3s, color 0.3s;
      padding: 20px;
      margin: 0;
    }
    .container {
      max-width: 1000px;
      margin: auto;
      padding: 30px;
      position: relative;
      background-color: var(--bg-color);
      border-radius: 8px;
      box-shadow: 0 4px 10px rgba(0,0,0,0.05);
    }
    body.dark-mode .container {
        box-shadow: 0 4px 15px rgba(0,0,0,0.15);
    }
    body.dark-mode {
      --bg-color: #2c3e50;
      --text-color: #ecf0f1;
      --header-color: var(--header-dark-color);
      --accent-color: var(--accent-dark-color);
      --button-bg: var(--button-dark-bg);
      --button-hover-bg: var(--button-dark-hover-bg);
      --content-panel-bg: var(--content-panel-dark-bg);
      --author-color: #bdc3c7;
      --index-button-bg: var(--index-button-dark-bg);
      --index-button-hover-bg: var(--index-button-dark-hover-bg);
    }

    h1 {
      font-family: 'Roboto', sans-serif;
      font-size: 2.6em;
      color: var(--header-color);
      text-align: center;
      margin-bottom: 15px;
    }
    .author-line {
        font-family: 'Roboto', sans-serif;
        text-align: center;
        color: var(--author-color);
        font-size: 1.1em;
        margin-bottom: 30px;
        font-style: italic;
    }
    .section-toggle-button h2 {
      font-family: 'Roboto', sans-serif;
      font-size: 1.6em;
      color: var(--button-text-color);
      margin: 0;
      padding: 0;
      font-weight: 700;
      text-align: left;
    }
     .content-panel h3 {
      font-family: 'Roboto', sans-serif;
      font-size: 1.4em;
      color: var(--accent-color);
      margin-top: 15px;
      margin-bottom: 10px;
      padding-bottom: 5px;
      border-bottom: 1px solid var(--accent-color);
      text-align: left;
    }
    .index-item-panel p, .index-item-panel ul {
        font-family: 'Lora', serif;
        font-size: 1em;
        margin-bottom: 0.5em;
    }
    .index-item-panel ul { padding-left: 20px; }


    .content-panel {
      display: none;
      margin-top: 0;
      padding: 20px 25px;
      border-left: 4px solid var(--accent-color);
      background-color: var(--content-panel-bg);
      border-radius: 0 0 6px 6px;
    }
    .content-panel.is-visible {
      display: block;
    }
    /* Estilo específico para el panel de Objetivo */
    #alpha_objetivo ul {
        list-style-type: disc; /* Viñetas estándar para la lista de objetivos */
    }


    .section-toggle-button {
      background-color: var(--button-bg);
      border: none;
      padding: 14px 20px;
      border-radius: 6px;
      cursor: pointer;
      margin-top: 18px;
      transition: background-color 0.3s, border-radius 0.2s;
      width: 100%;
      display: flex;
      align-items: center;
    }
    .section-toggle-button:hover {
      background-color: var(--button-hover-bg);
    }
    .section-toggle-button.is-expanded {
        border-radius: 6px 6px 0 0;
    }

    /* --- MODIFICACIÓN AQUÍ --- */
    .index-main-button {
        /* background-color: var(--header-color); Ya no es necesario, heredará de .section-toggle-button */
        margin-top: 25px; /* Mantenemos el margen superior específico */
    }
    /* body.dark-mode .index-main-button {
        background-color: var(--header-dark-color); Ya no es necesario
        color: var(--bg-color); Esto hacía que el texto del h2 fuera oscuro sobre fondo oscuro del botón,
                                ahora el h2 heredará el color de .section-toggle-button h2 (blanco)
    } */
    .index-main-button h2 { font-size: 1.8em; } /* Mantenemos el tamaño de fuente específico para el h2 */

    .index-item-button {
        background-color: var(--index-button-bg);
        font-size: 1.1em;
        padding: 10px 15px;
        margin-top: 8px;
        margin-left: 20px;
        width: calc(100% - 20px);
    }
     .index-item-button h2 {
        font-size: 1.1em;
        font-weight: normal;
    }


    .theme-toggle {
      background-color: var(--theme-button-bg);
      color: white;
      border: none;
      padding: 9px 14px;
      border-radius: 6px;
      cursor: pointer;
      position: absolute;
      top: 30px;
      right: 30px;
      font-size: 0.9em;
      transition: background-color 0.3s;
      z-index: 10;
    }
    body.dark-mode .theme-toggle {
       background-color: var(--theme-button-dark-bg);
       color: var(--text-color);
    }

    button:focus, a:focus {
        outline: 2px solid var(--accent-color);
        outline-offset: 3px;
    }
    body.dark-mode button:focus, body.dark-mode a:focus {
         outline-color: var(--accent-dark-color);
    }
    .content-panel p, .content-panel ul {
        margin-bottom: 1.1em;
    }
    .content-panel p:last-child, .content-panel ul:last-child {
        margin-bottom: 0;
    }
    ul {
        padding-left: 30px;
    }
    li {
        margin-bottom: 0.6em;
    }
    strong {
        font-weight: 700;
    }
    hr {
        border: 0;
        height: 1px;
        background-image: linear-gradient(to right, rgba(0,0,0,0), var(--text-color), rgba(0,0,0,0));
        opacity: 0.5;
        margin: 30px 0;
    }
  </style>
</head>
<body>
  <div class="container">
    <button id="theme-toggle-btn" class="theme-toggle" onclick="toggleTheme()" title="Cambiar tema de color">Modo Oscuro</button>

    <!-- --- MODIFICACIÓN AQUÍ --- -->
    <h1>El Problema del viajante y el algoritmo genético</h1>
    <p class="author-line">Material Elaborado por Sergio Gevatschnaider</p>

    <!-- Sección: Introducción  -->
    <button class="section-toggle-button" onclick="toggleSection('alpha_intro', this)" aria-expanded="false" aria-controls="alpha_intro">
      <h2>Introducción  al Módulo</h2>
    </button>
    <div id="alpha_intro" class="content-panel">
      <h3>El Desafío del Problema del Viajante (TSP)</h3>
      <p>El Problema del Viajante (TSP, por sus siglas en inglés) es uno de los desafíos más emblemáticos en la teoría de la optimización combinatoria. Su formulación simple —encontrar la ruta más corta que recorre un conjunto de ciudades visitando cada una exactamente una vez y regresando al punto de origen— contrasta con su complejidad computacional, al ser un problema NP-hard. Esta dificultad ha motivado el desarrollo de estrategias heurísticas y metaheurísticas capaces de hallar soluciones eficientes en contextos reales, donde métodos exactos resultan inabordables.</p>
      <h3>Algoritmos Genéticos y la Hibridación con Aprendizaje por Refuerzo</h3>
      <p>En este contexto, los algoritmos genéticos (AG) destacan como una herramienta poderosa, gracias a su capacidad de adaptación y exploración de espacios de soluciones extensos. El presente módulo se centra en el diseño, implementación y análisis de un algoritmo genético extendido con aprendizaje por refuerzo (específicamente, Q-learning) para la selección adaptativa de operadores de mutación. Esta hibridación evolutiva refuerza el proceso de búsqueda local y global, permitiendo al algoritmo evolucionar su propia estrategia de variación en función del desempeño observado.</p>
      <h3>Enfoque del Módulo: AlphaEvolve</h3>
      <p>A través de visualizaciones dinámicas, formulaciones teóricas y resultados cuantitativos, se busca ofrecer una experiencia integral que combina la teoría evolutiva con la implementación computacional moderna. Esta aproximación, denominada AlphaEvolve, propone una arquitectura flexible y extensible para abordar instancias complejas del TSP y, potencialmente, de otros problemas combinatorios.</p>
    </div>
    <hr>

    <!-- Sección: Objetivo -->
    <button class="section-toggle-button" onclick="toggleSection('alpha_objetivo', this)" aria-expanded="false" aria-controls="alpha_objetivo">
      <h2>Objetivo </h2>
    </button>
    <div id="alpha_objetivo" class="content-panel">
      <p>Desarrollar e implementar un algoritmo genético híbrido con aprendizaje por refuerzo (Q-learning) para resolver de manera eficiente el Problema del Viajante, analizando su comportamiento adaptativo en la selección de operadores de mutación, su capacidad de escape del estancamiento evolutivo, y su desempeño frente a estrategias tradicionales.</p>
      <p>Este objetivo incluye:</p>
      <ul>
        <li>Explorar la sinergia entre técnicas evolutivas y aprendizaje por refuerzo.</li>
        <li>Medir la influencia del agente Q-learning sobre la convergencia y la diversidad poblacional.</li>
        <li>Evaluar la escalabilidad y generalización del enfoque a distintas instancias del TSP.</li>
      </ul>
    </div>
    <hr>

    <!-- Sección: Índice Propuesto -->
    <!-- La clase index-main-button se mantiene para otros estilos como margin-top o el tamaño del h2, pero el color de fondo ahora lo hereda -->
    <button class="section-toggle-button index-main-button" onclick="toggleSection('alpha_indice', this)" aria-expanded="false" aria-controls="alpha_indice">
      <h2>Índice del Módulo</h2>
    </button>
    <div id="alpha_indice" class="content-panel">
      <!-- Fundamentos del TSP -->
      <button class="section-toggle-button index-item-button" onclick="toggleSection('idx_fund_tsp', this)" aria-expanded="false" aria-controls="idx_fund_tsp">
        <h2>Fundamentos del Problema del Viajante (TSP)</h2>
      </button>
      <div id="idx_fund_tsp" class="content-panel index-item-panel">
        <p>Definición formal del problema</p>
        <p>Complejidad computacional y espacio de soluciones</p>
      </div>

      <!-- Teoría de AG -->
      <button class="section-toggle-button index-item-button" onclick="toggleSection('idx_teoria_ag', this)" aria-expanded="false" aria-controls="idx_teoria_ag">
        <h2>Teoría de Algoritmos Genéticos</h2>
      </button>
      <div id="idx_teoria_ag" class="content-panel index-item-panel">
        <p>Principios biológicos y computacionales</p>
        <p>Representación genética para problemas de permutación</p>
        <p>Operadores clásicos: selección, cruce, mutación</p>
      </div>

      <!-- Diseño del AG para TSP -->
      <button class="section-toggle-button index-item-button" onclick="toggleSection('idx_diseno_ag_tsp', this)" aria-expanded="false" aria-controls="idx_diseno_ag_tsp">
        <h2>Diseño del AG para TSP</h2>
      </button>
      <div id="idx_diseno_ag_tsp" class="content-panel index-item-panel">
        <p>Codificación del recorrido</p>
        <p>Heurísticas iniciales (aleatorio, vecino más cercano, greedy)</p>
        <p>Evaluación de fitness y penalización estructurada</p>
      </div>

      <!-- Extensión con Q-learning: AlphaEvolve -->
      <button class="section-toggle-button index-item-button" onclick="toggleSection('idx_qlearning', this)" aria-expanded="false" aria-controls="idx_qlearning">
        <h2>Extensión con Q-learning: AlphaEvolve</h2>
      </button>
      <div id="idx_qlearning" class="content-panel index-item-panel">
        <p>Motivación para aprendizaje adaptativo de mutaciones</p>
        <p>Estados, acciones y recompensas en el contexto evolutivo</p>
        <p>Adaptación del parámetro epsilon y exploración/explotación</p>
      </div>

      <!-- Visualización Dinámica -->
      <button class="section-toggle-button index-item-button" onclick="toggleSection('idx_visualizacion', this)" aria-expanded="false" aria-controls="idx_visualizacion">
        <h2>Visualización Dinámica del Proceso Evolutivo</h2>
      </button>
      <div id="idx_visualizacion" class="content-panel index-item-panel">
        <p>Evolución de la mejor solución</p>
        <p>Diversidad poblacional y estancamiento</p>
        <p>Comportamiento del agente RL (acciones, epsilon, recompensas)</p>
      </div>

      <!-- Evaluación de Resultados -->
      <button class="section-toggle-button index-item-button" onclick="toggleSection('idx_evaluacion', this)" aria-expanded="false" aria-controls="idx_evaluacion">
        <h2>Evaluación de Resultados</h2>
      </button>
      <div id="idx_evaluacion" class="content-panel index-item-panel">
        <p>Análisis cuantitativo del desempeño</p>
        <p>Comparación con estrategias no adaptativas</p>
        <p>Observaciones sobre convergencia y diversidad</p>
      </div>

      <!-- Discusión y Extensiones -->
      <button class="section-toggle-button index-item-button" onclick="toggleSection('idx_discusion', this)" aria-expanded="false" aria-controls="idx_discusion">
        <h2>Discusión y Extensiones</h2>
      </button>
      <div id="idx_discusion" class="content-panel index-item-panel">
        <p>Uso de experience replay (futuro)</p>
        <p>Hibridación con técnicas como simulated annealing o local search</p>
        <p>Aplicabilidad a otros problemas NP-hard</p>
      </div>

      <!-- Conclusión -->
      <button class="section-toggle-button index-item-button" onclick="toggleSection('idx_conclusion_final', this)" aria-expanded="false" aria-controls="idx_conclusion_final">
        <h2>Conclusión</h2>
      </button>
      <div id="idx_conclusion_final" class="content-panel index-item-panel">
        <p>Reflexión sobre la efectividad de la arquitectura</p>
        <p>Aportes del enfoque adaptativo al campo de la optimización evolutiva</p>
      </div>

      <!-- Anexos -->
      <button class="section-toggle-button index-item-button" onclick="toggleSection('idx_anexos', this)" aria-expanded="false" aria-controls="idx_anexos">
        <h2>Anexos</h2>
      </button>
      <div id="idx_anexos" class="content-panel index-item-panel">
        <p>Código fuente documentado</p>
        <p>Parámetros utilizados</p>
        <p>Instancias de prueba reproducibles</p>
      </div>
    </div> <!-- Fin del panel principal del índice -->

  </div> <!-- Fin de .container -->

  <script>
    // Función para cambiar entre modo claro y oscuro
    function toggleTheme() {
      document.body.classList.toggle("dark-mode");
      let themeButton = document.getElementById('theme-toggle-btn');
      let isDarkMode = document.body.classList.contains("dark-mode");
      localStorage.setItem("theme", isDarkMode ? "dark" : "light");
      if (themeButton) {
          themeButton.textContent = isDarkMode ? "Modo Claro" : "Modo Oscuro";
      }
    }

    // Función para mostrar/ocultar paneles de contenido
    function toggleSection(id, buttonElement) {
      let panel = document.getElementById(id);
      if (panel && buttonElement) {
          panel.classList.toggle('is-visible');
          let isVisible = panel.classList.contains('is-visible');
          buttonElement.setAttribute('aria-expanded', isVisible);
          buttonElement.classList.toggle('is-expanded', isVisible);
      }
    }

    // Función que se ejecuta cuando la página carga
    window.onload = function() {
      let themeButton = document.getElementById('theme-toggle-btn');
      const savedTheme = localStorage.getItem("theme");

      if (savedTheme === "dark") {
        document.body.classList.add("dark-mode");
        if (themeButton) {
            themeButton.textContent = "Modo Claro";
        }
      } else {
        document.body.classList.remove("dark-mode");
        if (themeButton) {
            themeButton.textContent = "Modo Oscuro";
        }
      }

       document.querySelectorAll('.content-panel').forEach(panel => {
         panel.classList.remove('is-visible');
       });
       document.querySelectorAll('.section-toggle-button').forEach(button => {
          button.setAttribute('aria-expanded', 'false');
          button.classList.remove('is-expanded');
       });
    }
  </script>
</body>
</html>
"""

# Mostrar el HTML en la salida de la celda
display(HTML(html_content))

# Importar las funciones necesarias de IPython para mostrar HTML
from IPython.core.display import display, HTML

# Definir el contenido HTML, CSS y JavaScript como un string multilínea
html_content = """
<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Algoritmos Genéticos: Una Introducción Detallada</title>
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet">
  <style>
    /* Definición de variables CSS para temas */
    :root {
      --bg-color: #f9f9f9;
      --text-color: #333;
      --header-color: #2c3e50;
      --header-dark-color: #ecf0f1;
      --accent-color: #16a085; /* Verde azulado para GA */
      --accent-dark-color: #76d7c4; /* Verde azulado más claro para modo oscuro */
      --button-bg: #1abc9c; /* Verde azulado más brillante para botones */
      --button-hover-bg: #16a085; /* Verde azulado para hover */
      --button-dark-bg: #e67e22; /* Naranja para modo oscuro */
      --button-dark-hover-bg: #d35400; /* Naranja oscuro para hover */
      --button-text-color: white;
      --theme-button-bg: #8e44ad; /* Morado claro */
      --theme-button-dark-bg: #f39c12; /* Naranja */
      --content-panel-bg: #f1fefd;
      --content-panel-dark-bg: #283747;
      --table-border-color: #bdc3c7;
      --table-header-bg: #e8f6f3;
      --table-header-dark-bg: #3e5b76;
    }

    body {
      font-family: 'Roboto', Arial, sans-serif;
      line-height: 1.8;
      background-color: var(--bg-color);
      color: var(--text-color);
      transition: background-color 0.3s, color 0.3s;
      padding: 20px;
      margin: 0;
    }
    .container {
      max-width: 900px;
      margin: auto;
      padding: 20px;
      position: relative;
      background-color: var(--bg-color);
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    }
    body.dark-mode .container {
        box-shadow: 0 2px 10px rgba(0,0,0,0.3);
    }
    body.dark-mode {
      --bg-color: #2c3e50;
      --text-color: #ecf0f1;
      --header-color: var(--header-dark-color);
      --accent-color: var(--accent-dark-color);
      --button-bg: var(--button-dark-bg);
      --button-hover-bg: var(--button-dark-hover-bg);
      --content-panel-bg: var(--content-panel-dark-bg);
      --table-border-color: #566573;
      --table-header-bg: var(--table-header-dark-bg);
    }

    h1 {
      font-size: 2.4em;
      color: var(--header-color);
      text-align: center;
      margin-bottom: 15px;
    }
     h2 { /* Para subtítulos dentro de las secciones */
      font-size: 1.6em;
      color: var(--accent-color);
      margin-top: 20px;
      margin-bottom: 10px;
      padding-bottom: 3px;
      border-bottom: 2px solid var(--accent-color);
      text-align: left;
    }
    h3 { /* Para sub-subtítulos */
      font-size: 1.3em;
      color: var(--header-color);
      margin-top: 15px;
      margin-bottom: 8px;
      text-align: left;
    }


    .content-panel {
      display: none;
      margin-top: 0;
      padding: 20px;
      border-left: 4px solid var(--accent-color);
      background-color: var(--content-panel-bg);
      border-radius: 0 0 5px 5px;
    }
    .content-panel.is-visible {
      display: block;
    }

    .section-toggle-button {
      background-color: var(--button-bg);
      color: var(--button-text-color);
      border: none;
      padding: 12px 18px;
      border-radius: 5px;
      cursor: pointer;
      margin-top: 15px;
      transition: background-color 0.3s, border-radius 0.2s;
      width: 100%;
      text-align: left;
      font-size: 1.2em;
      font-weight: 700; /* Roboto bold */
    }
    .section-toggle-button:hover {
      background-color: var(--button-hover-bg);
    }
    .section-toggle-button.is-expanded {
        border-radius: 5px 5px 0 0;
    }

    .theme-toggle {
      background-color: var(--theme-button-bg);
      color: white;
      border: none;
      padding: 8px 12px;
      border-radius: 5px;
      cursor: pointer;
      position: absolute;
      top: 20px;
      right: 20px;
      font-size: 0.9em;
      transition: background-color 0.3s;
      z-index: 10;
    }
    body.dark-mode .theme-toggle {
       background-color: var(--theme-button-dark-bg);
    }

    button:focus, a:focus {
        outline: 2px solid var(--accent-color);
        outline-offset: 2px;
    }
    body.dark-mode button:focus, body.dark-mode a:focus {
         outline-color: var(--accent-dark-color);
    }
    .content-panel p, .content-panel ul, .content-panel ol {
        margin-bottom: 1em;
    }
    .content-panel p:last-child, .content-panel ul:last-child, .content-panel ol:last-child {
        margin-bottom: 0;
    }
    ul, ol {
        padding-left: 30px;
    }
    li {
        margin-bottom: 0.5em;
    }
    strong {
        font-weight: 700; /* Roboto bold */
    }

    /* Estilos para la tabla Ventajas/Desventajas */
    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 15px;
      margin-bottom: 15px;
    }
    th, td {
      border: 1px solid var(--table-border-color);
      padding: 10px;
      text-align: left;
      vertical-align: top;
    }
    th {
      background-color: var(--table-header-bg);
      color: var(--header-color);
      font-weight: 700;
    }
    body.dark-mode th {
        color: var(--header-dark-color);
    }
    caption {
      caption-side: top;
      font-size: 1.2em;
      font-weight: bold;
      color: var(--header-color);
      margin-bottom: 10px;
      text-align: center;
    }

  </style>
</head>
<body>
  <div class="container">
    <button id="theme-toggle-btn" class="theme-toggle" onclick="toggleTheme()" title="Cambiar tema de color">Modo Oscuro</button>

    <h1>Algoritmos Genéticos: Una Introducción Detallada</h1>

    <!-- Sección: ¿Qué es un Algoritmo Genético? -->
    <button class="section-toggle-button" onclick="toggleSection('ga_que_es', this)" aria-expanded="false" aria-controls="ga_que_es">
      ¿Qué es un Algoritmo Genético?
    </button>
    <div id="ga_que_es" class="content-panel">
      <p>Un algoritmo genético (GA, por sus siglas en inglés) es un método de optimización y búsqueda heurística inspirado en los principios de la selección natural y la evolución biológica propuestos por Charles Darwin. Forma parte del campo de la inteligencia artificial y más específicamente de los algoritmos evolutivos.</p>
      <p>Su fortaleza radica en la capacidad de explorar grandes espacios de soluciones y encontrar óptimos aproximados en problemas donde los métodos clásicos de optimización son poco eficaces o inviables por la complejidad del problema.</p>
      <h3>Definición Formal</h3>
      <p>Un algoritmo genético es un procedimiento estocástico que simula la evolución de una población de individuos para resolver un problema de optimización. Cada individuo representa una posible solución codificada como un genotipo (cromosoma), y su calidad se evalúa mediante una función de aptitud (fitness).</p>
    </div>

    <!-- Sección: ¿Cómo funciona un Algoritmo Genético? -->
    <button class="section-toggle-button" onclick="toggleSection('ga_como_funciona', this)" aria-expanded="false" aria-controls="ga_como_funciona">
      ¿Cómo funciona un Algoritmo Genético?
    </button>
    <div id="ga_como_funciona" class="content-panel">
      <p>El proceso puede resumirse en los siguientes pasos fundamentales:</p>
      <ol>
        <li><strong>Inicialización:</strong> Se genera una población inicial de soluciones aleatorias.</li>
        <li><strong>Evaluación:</strong> Cada individuo es evaluado con la función de fitness, que mide qué tan buena es esa solución.</li>
        <li><strong>Selección:</strong> Se seleccionan los individuos más aptos para reproducirse. Se usan métodos como ruleta, torneo o elitismo.</li>
        <li><strong>Cruzamiento (Crossover):</strong> Se combinan pares de individuos seleccionados para producir descendientes con mezcla genética.</li>
        <li><strong>Mutación:</strong> Se introducen cambios aleatorios en los descendientes para mantener diversidad genética.</li>
        <li><strong>Reemplazo:</strong> Se forman nuevas generaciones con los descendientes, reemplazando parte o toda la población anterior.</li>
        <li><strong>Criterio de parada:</strong> El algoritmo se detiene cuando se cumple un número de generaciones, se alcanza un valor objetivo, o no hay mejoras significativas.</li>
      </ol>
    </div>

    <!-- Sección: Representación Genética (Codificación) -->
    <button class="section-toggle-button" onclick="toggleSection('ga_representacion', this)" aria-expanded="false" aria-controls="ga_representacion">
      Representación Genética (Codificación)
    </button>
    <div id="ga_representacion" class="content-panel">
      <p>Existen múltiples formas de codificar una solución:</p>
      <ul>
        <li><strong>Binaria:</strong> uso de cadenas de 0s y 1s.</li>
        <li><strong>Entera o real:</strong> para problemas con variables numéricas.</li>
        <li><strong>Permutaciones:</strong> común en problemas de grafos como el viajero (TSP).</li>
        <li><strong>Árboles:</strong> como en la programación genética.</li>
      </ul>
    </div>

    <!-- Sección: Aplicaciones Prácticas -->
    <button class="section-toggle-button" onclick="toggleSection('ga_aplicaciones', this)" aria-expanded="false" aria-controls="ga_aplicaciones">
      Aplicaciones Prácticas
    </button>
    <div id="ga_aplicaciones" class="content-panel">
      <p>Los algoritmos genéticos tienen una gran diversidad de aplicaciones reales en ingeniería, informática, logística y más:</p>
      <h3>1. Optimización Combinatoria</h3>
      <ul>
        <li>Problema del Viajero (TSP)</li>
        <li>Coloración de grafos</li>
        <li>Asignación de tareas</li>
        <li>Problemas de rutas de vehículos (VRP)</li>
      </ul>
      <h3>2. Ingeniería y Diseño</h3>
      <ul>
        <li>Optimización de estructuras mecánicas.</li>
        <li>Diseño de circuitos eléctricos.</li>
        <li>Generación de diseños CAD.</li>
      </ul>
      <h3>3. Machine Learning y Data Science</h3>
      <ul>
        <li>Selección de atributos (feature selection).</li>
        <li>Optimización de hiperparámetros.</li>
        <li>Aprendizaje de reglas.</li>
      </ul>
      <h3>4. Robótica y Control</h3>
      <ul>
        <li>Planificación de trayectorias.</li>
        <li>Controladores adaptativos.</li>
      </ul>
      <h3>5. Finanzas</h3>
      <ul>
        <li>Optimización de carteras de inversión.</li>
        <li>Trading algorítmico basado en reglas evolucionadas.</li>
      </ul>
      <h3>6. Bioinformática</h3>
      <ul>
        <li>Alineamiento de secuencias.</li>
        <li>Modelado de proteínas.</li>
        <li>Evolución de redes génicas.</li>
      </ul>
    </div>

    <!-- Sección: Ejemplo en Grafos: Coloración de Grafos -->
    <button class="section-toggle-button" onclick="toggleSection('ga_ejemplo_grafos', this)" aria-expanded="false" aria-controls="ga_ejemplo_grafos">
      Ejemplo en Grafos: Coloración de Grafos
    </button>
    <div id="ga_ejemplo_grafos" class="content-panel">
      <p>El problema de la coloración de grafos consiste en asignar colores a los vértices de un grafo tal que dos vértices adyacentes no tengan el mismo color, minimizando el número total de colores usados (número cromático).</p>
      <p><strong>¿Cómo aplica un algoritmo genético aquí?</strong></p>
      <ul>
        <li><strong>Codificación:</strong> cada cromosoma es un vector donde cada entrada representa el color de un nodo.</li>
        <li><strong>Fitness:</strong> penaliza conflictos (adyacentes con mismo color) y favorece menos colores.</li>
        <li><strong>Operadores:</strong> se definen cruces entre vectores de color y mutaciones aleatorias.</li>
      </ul>
      <p>Esto permite resolver de forma aproximada este problema NP-hard, donde métodos exactos se vuelven costosos en grafos grandes.</p>
    </div>

    <!-- Sección: Ventajas y Desventajas -->
    <button class="section-toggle-button" onclick="toggleSection('ga_ventajas_desventajas', this)" aria-expanded="false" aria-controls="ga_ventajas_desventajas">
      Ventajas y Desventajas
    </button>
    <div id="ga_ventajas_desventajas" class="content-panel">
      <table>
        <caption>Comparativa de Algoritmos Genéticos</caption>
        <thead>
          <tr>
            <th>Ventajas</th>
            <th>Desventajas</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>Alta capacidad de exploración</td>
            <td>Puede ser lento para converger</td>
          </tr>
          <tr>
            <td>Robusto ante múltiples óptimos locales</td>
            <td>Necesita ajuste fino de parámetros</td>
          </tr>
          <tr>
            <td>Adaptable a distintos tipos de problemas</td>
            <td>Sin garantías de encontrar el óptimo real</td>
          </tr>
        </tbody>
      </table>
    </div>

    <!-- Sección: Conclusión -->
    <button class="section-toggle-button" onclick="toggleSection('ga_conclusion', this)" aria-expanded="false" aria-controls="ga_conclusion">
      Conclusión
    </button>
    <div id="ga_conclusion" class="content-panel">
      <p>Los algoritmos genéticos son herramientas poderosas dentro de la computación evolutiva. Su capacidad para manejar espacios de búsqueda complejos, discretos o continuos, y su aplicabilidad a problemas reales de gran escala, los convierten en una pieza clave en la caja de herramientas del científico computacional, ingeniero o matemático aplicado.</p>
      <p>Su implementación puede variar dependiendo del problema, pero los principios de selección, cruza y mutación permanecen como el núcleo del proceso de evolución artificial.</p>
    </div>

  </div> <!-- Fin de .container -->

  <script>
    // Función para cambiar entre modo claro y oscuro
    function toggleTheme() {
      document.body.classList.toggle("dark-mode");
      let themeButton = document.getElementById('theme-toggle-btn');
      let isDarkMode = document.body.classList.contains("dark-mode");
      localStorage.setItem("theme", isDarkMode ? "dark" : "light");
      if (themeButton) {
          themeButton.textContent = isDarkMode ? "Modo Claro" : "Modo Oscuro";
      }
    }

    // Función para mostrar/ocultar paneles de contenido
    function toggleSection(id, buttonElement) {
      let panel = document.getElementById(id);
      if (panel && buttonElement) {
          panel.classList.toggle('is-visible');
          let isVisible = panel.classList.contains('is-visible');
          buttonElement.setAttribute('aria-expanded', isVisible);
          buttonElement.classList.toggle('is-expanded', isVisible);
      }
    }

    // Función que se ejecuta cuando la página carga
    window.onload = function() {
      let themeButton = document.getElementById('theme-toggle-btn');
      const savedTheme = localStorage.getItem("theme");

      if (savedTheme === "dark") {
        document.body.classList.add("dark-mode");
        if (themeButton) {
            themeButton.textContent = "Modo Claro";
        }
      } else {
        document.body.classList.remove("dark-mode");
        if (themeButton) {
            themeButton.textContent = "Modo Oscuro";
        }
      }

       document.querySelectorAll('.content-panel').forEach(panel => {
         panel.classList.remove('is-visible');
       });
       document.querySelectorAll('.section-toggle-button').forEach(button => {
          button.setAttribute('aria-expanded', 'false');
          button.classList.remove('is-expanded');
       });
    }
  </script>
</body>
</html>
"""

# Mostrar el HTML en la salida de la celda
display(HTML(html_content))

import numpy as np
import matplotlib.pyplot as plt
import math

# Función objetivo
def objective_function(x: float) -> float:
    return x * math.sin(10 * math.pi * x) + 1.0

# Valores en el dominio [0, 1]
x_vals = np.linspace(0, 1, 1000)
y_vals = [objective_function(x) for x in x_vals]

# Detectar máximos locales
local_maxima = []
for i in range(1, len(y_vals) - 1):
    if y_vals[i] > y_vals[i - 1] and y_vals[i] > y_vals[i + 1]:
        local_maxima.append((x_vals[i], y_vals[i]))

# Encontrar el óptimo global
if local_maxima:
    global_max = max(local_maxima, key=lambda t: t[1])
    # Excluir el global de los locales para no marcar dos veces
    local_maxima_sin_global = [p for p in local_maxima if p != global_max]
else:
    global_max = (x_vals[np.argmax(y_vals)], max(y_vals))
    local_maxima_sin_global = []

# Graficar
plt.figure(figsize=(10, 6))
plt.plot(x_vals, y_vals, label=r'$f(x) = x \cdot \sin(10\pi x) + 1$', linewidth=2)
# Marcar óptimo global
plt.plot(global_max[0], global_max[1], 'ro', markersize=10, label=f'Óptimo global: x={global_max[0]:.4f}, f(x)={global_max[1]:.4f}')
# Marcar óptimos locales
if local_maxima_sin_global:
    lx, ly = zip(*local_maxima_sin_global)
    plt.plot(lx, ly, 'o', color='orange', markersize=8, label='Óptimos locales')
plt.title("Óptimos local y global de $f(x)$", fontsize=14)
plt.xlabel("x")
plt.ylabel("f(x)")
plt.grid(True, alpha=0.3)
plt.legend()
plt.tight_layout()
plt.show()

"""o,0,1  continua  conjunto de soluciones  o espacio de solucion  20 25 2 elevado 20

1,1, 0  1,0, 1 1.1.1
"""

import numpy as np
import matplotlib.pyplot as plt
from scipy.optimize import minimize, differential_evolution
import random
from typing import List, Tuple
import math

class MultimodalOptimizationComparison:
    def __init__(self):
        self.function_name = "f(x) = x⋅sin(10πx) + 1.0"

    def objective_function(self, x):
        """Función objetivo multimodal"""
        if isinstance(x, (list, np.ndarray)):
            x = x[0] if len(x) > 0 else x
        return x * math.sin(10 * math.pi * x) + 1.0

    def objective_function_minimize(self, x):
        """Versión para minimización (negativa)"""
        return -self.objective_function(x)

    def gradient_function(self, x):
        """Gradiente analítico de f(x)"""
        if isinstance(x, (list, np.ndarray)):
            x = x[0] if len(x) > 0 else x
        # df/dx = sin(10πx) + x⋅10π⋅cos(10πx)
        return math.sin(10 * math.pi * x) + x * 10 * math.pi * math.cos(10 * math.pi * x)

    def analyze_function_landscape(self):
        """Analiza el paisaje de la función para entender su complejidad"""
        x = np.linspace(0, 1, 2000)
        y = [self.objective_function(xi) for xi in x]

        # Encontrar máximos locales
        local_maxima = []
        for i in range(1, len(y)-1):
            if y[i] > y[i-1] and y[i] > y[i+1] and y[i] > 1.5:  # Solo picos significativos
                local_maxima.append((x[i], y[i]))

        # Ordenar por valor de función
        local_maxima.sort(key=lambda point: point[1], reverse=True)

        print("=== ANÁLISIS DEL PAISAJE DE LA FUNCIÓN ===")
        print(f"Función: {self.function_name}")
        print(f"Dominio: x ∈ [0,1]")
        print(f"Número de máximos locales significativos: {len(local_maxima)}")
        print(f"Máximo global: x = {local_maxima[0][0]:.6f}, f(x) = {local_maxima[0][1]:.6f}")
        print("\nTop 5 máximos locales:")
        for i, (xi, fi) in enumerate(local_maxima[:5]):
            print(f"  {i+1}. x = {xi:.6f}, f(x) = {fi:.6f}")
        print()

        return x, y, local_maxima

    def test_gradient_methods(self, num_starts=15):
        """Prueba métodos basados en gradiente desde múltiples puntos iniciales"""
        print("=== MÉTODOS BASADOS EN GRADIENTE ===")

        # Puntos iniciales distribuidos uniformemente
        start_points = np.linspace(0.05, 0.95, num_starts)

        results_bfgs = []
        results_lbfgs = []
        results_cg = []

        print("Probando desde múltiples puntos iniciales...")

        for i, x0 in enumerate(start_points):
            print(f"\rPunto inicial {i+1}/{num_starts}: x0 = {x0:.3f}", end="")

            # BFGS
            try:
                res_bfgs = minimize(self.objective_function_minimize, [x0],
                                 method='BFGS',
                                 options={'gtol': 1e-8, 'maxiter': 1000})
                if res_bfgs.success and 0 <= res_bfgs.x[0] <= 1:
                    results_bfgs.append((res_bfgs.x[0], -res_bfgs.fun))
            except:
                pass

            # L-BFGS-B (con límites)
            try:
                res_lbfgs = minimize(self.objective_function_minimize, [x0],
                                   method='L-BFGS-B',
                                   bounds=[(0, 1)],
                                   options={'gtol': 1e-8, 'maxiter': 1000})
                if res_lbfgs.success:
                    results_lbfgs.append((res_lbfgs.x[0], -res_lbfgs.fun))
            except:
                pass

            # Conjugate Gradient
            try:
                res_cg = minimize(self.objective_function_minimize, [x0],
                                method='CG',
                                options={'gtol': 1e-8, 'maxiter': 1000})
                if res_cg.success and 0 <= res_cg.x[0] <= 1:
                    results_cg.append((res_cg.x[0], -res_cg.fun))
            except:
                pass

        print("\n")

        # Analizar resultados
        def analyze_results(results, method_name):
            if not results:
                print(f"{method_name}: No se encontraron soluciones válidas")
                return None

            # Eliminar duplicados (misma solución desde diferentes puntos)
            unique_results = []
            for x, f in results:
                is_duplicate = False
                for ux, uf in unique_results:
                    if abs(x - ux) < 1e-4:  # Mismo punto
                        is_duplicate = True
                        break
                if not is_duplicate:
                    unique_results.append((x, f))

            unique_results.sort(key=lambda point: point[1], reverse=True)
            best_x, best_f = unique_results[0]

            print(f"\n{method_name}:")
            print(f"  Soluciones únicas encontradas: {len(unique_results)}")
            print(f"  Mejor solución: x = {best_x:.6f}, f(x) = {best_f:.6f}")
            print(f"  Tasa de éxito: {len(results)}/{num_starts} = {len(results)/num_starts*100:.1f}%")

            if len(unique_results) > 1:
                print("  Top 3 soluciones:")
                for i, (x, f) in enumerate(unique_results[:3]):
                    print(f"    {i+1}. x = {x:.6f}, f(x) = {f:.6f}")

            return unique_results

        bfgs_solutions = analyze_results(results_bfgs, "BFGS")
        lbfgs_solutions = analyze_results(results_lbfgs, "L-BFGS-B")
        cg_solutions = analyze_results(results_cg, "Conjugate Gradient")

        return {
            'bfgs': bfgs_solutions,
            'lbfgs': lbfgs_solutions,
            'cg': cg_solutions,
            'start_points': start_points
        }

    def run_genetic_algorithm(self):
        """Ejecuta algoritmo genético simplificado"""
        print("\n=== ALGORITMO GENÉTICO ===")

        # Parámetros del AG
        population_size = 100
        generations = 300
        mutation_rate = 0.02
        crossover_rate = 0.8

        # Inicializar población
        population = [random.uniform(0, 1) for _ in range(population_size)]
        best_history = []

        for gen in range(generations):
            # Evaluar fitness
            fitness = [self.objective_function(x) for x in population]

            # Encontrar mejor
            best_idx = fitness.index(max(fitness))
            best_x = population[best_idx]
            best_f = fitness[best_idx]
            best_history.append((best_x, best_f))

            if gen % 50 == 0:
                print(f"  Generación {gen}: x = {best_x:.6f}, f(x) = {best_f:.6f}")

            # Selección por torneo y reproducción
            new_population = []

            # Elitismo: mantener 10% mejores
            elite_size = population_size // 10
            elite_indices = sorted(range(len(fitness)), key=lambda i: fitness[i], reverse=True)[:elite_size]
            new_population.extend([population[i] for i in elite_indices])

            # Generar resto
            while len(new_population) < population_size:
                # Selección por torneo
                parent1 = self.tournament_selection(population, fitness)
                parent2 = self.tournament_selection(population, fitness)

                # Cruce
                if random.random() < crossover_rate:
                    alpha = random.uniform(0, 1)
                    child1 = alpha * parent1 + (1 - alpha) * parent2
                    child2 = (1 - alpha) * parent1 + alpha * parent2
                else:
                    child1, child2 = parent1, parent2

                # Mutación
                if random.random() < mutation_rate:
                    child1 += random.gauss(0, 0.05)
                    child1 = max(0, min(1, child1))  # Mantener en [0,1]

                if random.random() < mutation_rate:
                    child2 += random.gauss(0, 0.05)
                    child2 = max(0, min(1, child2))  # Mantener en [0,1]

                new_population.extend([child1, child2])

            population = new_population[:population_size]

        # Resultado final
        final_fitness = [self.objective_function(x) for x in population]
        best_idx = final_fitness.index(max(final_fitness))
        ga_best_x = population[best_idx]
        ga_best_f = final_fitness[best_idx]

        print(f"\nAlgoritmo Genético - Resultado final:")
        print(f"  Mejor solución: x = {ga_best_x:.6f}, f(x) = {ga_best_f:.6f}")

        return ga_best_x, ga_best_f, best_history

    def tournament_selection(self, population, fitness, tournament_size=5):
        """Selección por torneo"""
        tournament_indices = random.sample(range(len(population)), tournament_size)
        tournament_fitness = [fitness[i] for i in tournament_indices]
        winner_idx = tournament_indices[tournament_fitness.index(max(tournament_fitness))]
        return population[winner_idx]

    def test_differential_evolution(self):
        """Prueba evolución diferencial (scipy)"""
        print("\n=== EVOLUCIÓN DIFERENCIAL ===")

        result = differential_evolution(self.objective_function_minimize,
                                      bounds=[(0, 1)],
                                      maxiter=300,
                                      popsize=15,
                                      seed=42)

        de_best_x = result.x[0]
        de_best_f = -result.fun

        print(f"Evolución Diferencial:")
        print(f"  Mejor solución: x = {de_best_x:.6f}, f(x) = {de_best_f:.6f}")
        print(f"  Convergió: {'Sí' if result.success else 'No'}")
        print(f"  Evaluaciones de función: {result.nfev}")

        return de_best_x, de_best_f

    def visualize_comparison(self, gradient_results, ga_result, de_result, landscape_data):
        """Visualiza la comparación de métodos"""
        x_range, y_range, local_maxima = landscape_data
        ga_x, ga_f, ga_history = ga_result
        de_x, de_f = de_result

        fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2, figsize=(16, 12))

        # 1. Paisaje de la función con todas las soluciones
        ax1.plot(x_range, y_range, 'b-', linewidth=2, label='f(x) = x⋅sin(10πx) + 1')

        # Marcar máximos locales teóricos
        local_x = [x for x, _ in local_maxima[:10]]  # Top 10
        local_y = [y for _, y in local_maxima[:10]]
        ax1.scatter(local_x, local_y, c='lightgray', s=50, alpha=0.7, label='Máximos locales')

        # Soluciones de métodos de gradiente
        colors = ['red', 'orange', 'purple']
        methods = ['bfgs', 'lbfgs', 'cg']
        method_names = ['BFGS', 'L-BFGS-B', 'Conj. Gradient']

        for i, method in enumerate(methods):
            if gradient_results[method]:
                solutions_x = [x for x, _ in gradient_results[method]]
                solutions_y = [y for _, y in gradient_results[method]]
                ax1.scatter(solutions_x, solutions_y, c=colors[i], s=80,
                           marker='s', alpha=0.8, label=f'{method_names[i]} solutions')

        # Mejor solución del AG
        ax1.scatter([ga_x], [ga_f], c='green', s=150, marker='*',
                   label=f'AG: x={ga_x:.3f}', edgecolors='black', linewidth=2)

        # Mejor solución de DE
        ax1.scatter([de_x], [de_f], c='cyan', s=120, marker='D',
                   label=f'DE: x={de_x:.3f}', edgecolors='black', linewidth=1)

        ax1.set_xlabel('x')
        ax1.set_ylabel('f(x)')
        ax1.set_title('Comparación de Métodos de Optimización')
        ax1.legend()
        ax1.grid(True, alpha=0.3)

        # 2. Convergencia del algoritmo genético
        generations = range(len(ga_history))
        ga_fitness = [f for _, f in ga_history]

        ax2.plot(generations, ga_fitness, 'g-', linewidth=2)
        ax2.set_xlabel('Generación')
        ax2.set_ylabel('Mejor Fitness')
        ax2.set_title('Convergencia del Algoritmo Genético')
        ax2.grid(True, alpha=0.3)

        # 3. Distribución de soluciones por método
        method_performance = {}
        for i, method in enumerate(methods):
            if gradient_results[method]:
                best_f = max([f for _, f in gradient_results[method]])
                method_performance[method_names[i]] = best_f

        method_performance['Algoritmo Genético'] = ga_f
        method_performance['Evolución Diferencial'] = de_f

        methods_list = list(method_performance.keys())
        performance_list = list(method_performance.values())

        bars = ax3.bar(methods_list, performance_list,
                      color=['red', 'orange', 'purple', 'green', 'cyan'])
        ax3.set_ylabel('Mejor Fitness Encontrado')
        ax3.set_title('Comparación de Rendimiento por Método')
        ax3.tick_params(axis='x', rotation=45)

        # Añadir valores en las barras
        for bar, value in zip(bars, performance_list):
            ax3.text(bar.get_x() + bar.get_width()/2, bar.get_height() + 0.05,
                    f'{value:.3f}', ha='center', va='bottom')

        ax3.grid(True, alpha=0.3, axis='y')

        # 4. Análisis de diversidad de soluciones
        ax4.set_title('Análisis de Exploración del Espacio')

        # Puntos iniciales vs soluciones finales para métodos de gradiente
        start_points = gradient_results['start_points']
        ax4.scatter(start_points, [1.0] * len(start_points),
                   c='gray', alpha=0.5, s=30, label='Puntos iniciales')

        # Soluciones encontradas
        for i, method in enumerate(methods):
            if gradient_results[method]:
                solutions_x = [x for x, _ in gradient_results[method]]
                y_offset = 1.5 + i * 0.3
                ax4.scatter(solutions_x, [y_offset] * len(solutions_x),
                           c=colors[i], s=60, alpha=0.8, label=f'{method_names[i]}')

        # AG y DE
        ax4.scatter([ga_x], [3.0], c='green', s=100, marker='*', label='AG')
        ax4.scatter([de_x], [3.2], c='cyan', s=80, marker='D', label='DE')

        ax4.set_xlabel('x')
        ax4.set_ylabel('Método')
        ax4.set_ylim(0.5, 3.5)
        ax4.legend()
        ax4.grid(True, alpha=0.3)

        plt.tight_layout()
        plt.show()

    def run_complete_comparison(self):
        """Ejecuta la comparación completa"""
        print("🔍 COMPARACIÓN DE MÉTODOS DE OPTIMIZACIÓN")
        print("=" * 60)

        # 1. Analizar paisaje
        landscape_data = self.analyze_function_landscape()

        # 2. Probar métodos de gradiente
        gradient_results = self.test_gradient_methods()

        # 3. Ejecutar algoritmo genético
        ga_result = self.run_genetic_algorithm()

        # 4. Probar evolución diferencial
        de_result = self.test_differential_evolution()

        # 5. Resumen comparativo
        print("\n" + "=" * 60)
        print("📊 RESUMEN COMPARATIVO")
        print("=" * 60)

        # Obtener máximo teórico
        _, _, local_maxima = landscape_data
        theoretical_max = local_maxima[0][1]

        def print_method_summary(name, best_f, comment=""):
            error = abs(theoretical_max - best_f)
            percentage = (best_f / theoretical_max) * 100
            print(f"{name:20} | f(x) = {best_f:.6f} | Error: {error:.6f} | {percentage:.2f}% del óptimo {comment}")

        # Métodos de gradiente
        for method, name in [('bfgs', 'BFGS'), ('lbfgs', 'L-BFGS-B'), ('cg', 'Conj. Gradient')]:
            if gradient_results[method]:
                best_f = max([f for _, f in gradient_results[method]])
                num_solutions = len(gradient_results[method])
                print_method_summary(name, best_f, f"({num_solutions} soluciones)")
            else:
                print(f"{name:20} | No encontró soluciones válidas")

        # Métodos evolutivos
        ga_x, ga_f, _ = ga_result
        de_x, de_f = de_result
        print_method_summary("Algoritmo Genético", ga_f, "✓ Robusto")
        print_method_summary("Evolución Diferencial", de_f, "✓ Robusto")

        print(f"\nMáximo teórico: {theoretical_max:.6f}")

        # 6. Visualizar
        self.visualize_comparison(gradient_results, ga_result, de_result, landscape_data)

        # 7. Conclusiones
        print("\n" + "=" * 60)
        print("📝 CONCLUSIONES")
        print("=" * 60)
        print("🔴 MÉTODOS DE GRADIENTE:")
        print("   • Se 'atascan' en máximos locales")
        print("   • Dependen fuertemente del punto inicial")
        print("   • Rápidos pero no garantizan el óptimo global")
        print("   • Útiles para refinamiento local")

        print("\n🟢 MÉTODOS EVOLUTIVOS:")
        print("   • Exploran todo el espacio de búsqueda")
        print("   • Menos propensos a máximos locales")
        print("   • Más lentos pero más robustos")
        print("   • Ideales para funciones multimodales")

        print(f"\n🏆 GANADOR: {'Algoritmo Genético' if ga_f > de_f else 'Evolución Diferencial'}")
        print(f"   Encontró el {max(ga_f, de_f)/theoretical_max*100:.1f}% del óptimo teórico")

def main():
    """Función principal"""
    # Configurar semillas para reproducibilidad
    random.seed(42)
    np.random.seed(42)

    # Crear y ejecutar comparación
    comparator = MultimodalOptimizationComparison()
    comparator.run_complete_comparison()

if __name__ == "__main__":
    main()

import numpy as np
import matplotlib.pyplot as plt
import random
from typing import List, Tuple
import math

class GeneticAlgorithm:
    def __init__(self,
                 population_size: int = 100,
                 chromosome_length: int = 20,
                 crossover_rate: float = 0.8,
                 mutation_rate: float = 0.01,
                 elitism_rate: float = 0.1,
                 tournament_size: int = 5):
        self.population_size = population_size
        self.chromosome_length = chromosome_length
        self.crossover_rate = crossover_rate
        self.mutation_rate = mutation_rate
        self.elitism_rate = elitism_rate
        self.tournament_size = tournament_size
        self.elite_size = int(population_size * elitism_rate)
        self.best_fitness_history = []
        self.avg_fitness_history = []
        self.best_individual_history = []

    def objective_function(self, x: float) -> float:
        return x * math.sin(10 * math.pi * x) + 1.0

    def binary_to_decimal(self, binary_chromosome: List[int]) -> float:
        decimal_value = 0
        for i, bit in enumerate(binary_chromosome):
            decimal_value += bit * (2 ** (-(i + 1)))
        return decimal_value

    def decimal_to_binary(self, decimal_value: float) -> List[int]:
        binary = []
        remaining = decimal_value
        for i in range(self.chromosome_length):
            bit_value = 2 ** (-(i + 1))
            if remaining >= bit_value:
                binary.append(1)
                remaining -= bit_value
            else:
                binary.append(0)
        return binary

    def initialize_population(self) -> List[List[int]]:
        population = []
        for _ in range(self.population_size):
            chromosome = [random.randint(0, 1) for _ in range(self.chromosome_length)]
            population.append(chromosome)
        return population

    def evaluate_fitness(self, population: List[List[int]]) -> List[float]:
        fitness_values = []
        for chromosome in population:
            x = self.binary_to_decimal(chromosome)
            fitness = self.objective_function(x)
            fitness_values.append(fitness)
        return fitness_values

    def tournament_selection(self, population: List[List[int]], fitness_values: List[float]) -> List[int]:
        tournament_indices = random.sample(range(len(population)), self.tournament_size)
        tournament_fitness = [fitness_values[i] for i in tournament_indices]
        winner_index = tournament_indices[tournament_fitness.index(max(tournament_fitness))]
        return population[winner_index]

    def roulette_wheel_selection(self, population: List[List[int]], fitness_values: List[float]) -> List[int]:
        min_fitness = min(fitness_values)
        adjusted_fitness = [f - min_fitness + 0.1 for f in fitness_values]
        total_fitness = sum(adjusted_fitness)
        pick = random.uniform(0, total_fitness)
        current = 0
        for i, fitness in enumerate(adjusted_fitness):
            current += fitness
            if current >= pick:
                return population[i]
        return population[-1]

    def single_point_crossover(self, parent1: List[int], parent2: List[int]) -> Tuple[List[int], List[int]]:
        if random.random() > self.crossover_rate:
            return parent1.copy(), parent2.copy()
        crossover_point = random.randint(1, self.chromosome_length - 1)
        offspring1 = parent1[:crossover_point] + parent2[crossover_point:]
        offspring2 = parent2[:crossover_point] + parent1[crossover_point:]
        return offspring1, offspring2

    def uniform_crossover(self, parent1: List[int], parent2: List[int]) -> Tuple[List[int], List[int]]:
        if random.random() > self.crossover_rate:
            return parent1.copy(), parent2.copy()
        offspring1, offspring2 = [], []
        for i in range(self.chromosome_length):
            if random.random() < 0.5:
                offspring1.append(parent1[i])
                offspring2.append(parent2[i])
            else:
                offspring1.append(parent2[i])
                offspring2.append(parent1[i])
        return offspring1, offspring2

    def bit_flip_mutation(self, chromosome: List[int]) -> List[int]:
        mutated = chromosome.copy()
        for i in range(self.chromosome_length):
            if random.random() < self.mutation_rate:
                mutated[i] = 1 - mutated[i]
        return mutated

    def adaptive_mutation(self, chromosome: List[int], generation: int) -> List[int]:
        adaptive_rate = self.mutation_rate * (1 - generation / 1000)
        adaptive_rate = max(adaptive_rate, 0.001)
        mutated = chromosome.copy()
        for i in range(self.chromosome_length):
            if random.random() < adaptive_rate:
                mutated[i] = 1 - mutated[i]
        return mutated

    def elitism_selection(self, population: List[List[int]], fitness_values: List[float]) -> List[List[int]]:
        paired = list(zip(population, fitness_values))
        paired.sort(key=lambda x: x[1], reverse=True)
        elite = [individual for individual, _ in paired[:self.elite_size]]
        return elite

    def optimize(self, generations: int = 500, verbose: bool = True) -> Tuple[float, float]:
        population = self.initialize_population()
        for generation in range(generations):
            fitness_values = self.evaluate_fitness(population)
            best_fitness = max(fitness_values)
            avg_fitness = sum(fitness_values) / len(fitness_values)
            best_idx = fitness_values.index(best_fitness)
            best_x = self.binary_to_decimal(population[best_idx])
            self.best_fitness_history.append(best_fitness)
            self.avg_fitness_history.append(avg_fitness)
            self.best_individual_history.append((best_x, best_fitness))
            if verbose and generation % 50 == 0:
                print(f"Generación {generation}: Mejor fitness = {best_fitness:.6f}, x = {best_x:.6f}")
            new_population = []
            elite = self.elitism_selection(population, fitness_values)
            new_population.extend(elite)
            while len(new_population) < self.population_size:
                parent1 = self.tournament_selection(population, fitness_values)
                parent2 = self.tournament_selection(population, fitness_values)
                offspring1, offspring2 = self.single_point_crossover(parent1, parent2)
                offspring1 = self.bit_flip_mutation(offspring1)
                offspring2 = self.bit_flip_mutation(offspring2)
                new_population.extend([offspring1, offspring2])
            population = new_population[:self.population_size]
        final_fitness = self.evaluate_fitness(population)
        best_final_fitness = max(final_fitness)
        best_final_idx = final_fitness.index(best_final_fitness)
        best_final_x = self.binary_to_decimal(population[best_final_idx])
        return best_final_x, best_final_fitness

    def plot_results(self):
        fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2, figsize=(15, 10))
        ax1.plot(self.best_fitness_history, 'r-', label='Mejor fitness', linewidth=2)
        ax1.plot(self.avg_fitness_history, 'b--', label='Fitness promedio', alpha=0.7)
        ax1.set_xlabel('Generación')
        ax1.set_ylabel('Fitness')
        ax1.set_title('Evolución del Fitness')
        ax1.legend()
        ax1.grid(True, alpha=0.3)
        x_range = np.linspace(0, 1, 1000)
        y_range = [self.objective_function(x) for x in x_range]
        ax2.plot(x_range, y_range, 'b-', linewidth=2, label='f(x) = x·sin(10πx) + 1')
        best_x, best_fitness = self.best_individual_history[-1]
        ax2.plot(best_x, best_fitness, 'ro', markersize=10,
                label=f'Mejor solución: x={best_x:.4f}, f(x)={best_fitness:.4f}')
        ax2.set_xlabel('x')
        ax2.set_ylabel('f(x)')
        ax2.set_title('Función Objetivo y Mejor Solución')
        ax2.legend()
        ax2.grid(True, alpha=0.3)
        sample_points = [x for x, _ in self.best_individual_history[::10]]
        sample_fitness = [f for _, f in self.best_individual_history[::10]]
        ax3.scatter(sample_points, sample_fitness, alpha=0.6, s=30)
        ax3.plot(x_range, y_range, 'b-', alpha=0.3)
        ax3.set_xlabel('x')
        ax3.set_ylabel('f(x)')
        ax3.set_title('Exploración del Espacio de Búsqueda')
        ax3.grid(True, alpha=0.3)
        best_x_history = [x for x, _ in self.best_individual_history]
        ax4.plot(best_x_history, 'g-', linewidth=2)
        ax4.set_xlabel('Generación')
        ax4.set_ylabel('Mejor x')
        ax4.set_title('Convergencia de la Variable x')
        ax4.grid(True, alpha=0.3)
        plt.tight_layout()
        plt.show()

def main():
    print("=== ALGORITMO GENÉTICO PARA OPTIMIZACIÓN ===")
    print("Función: f(x) = x⋅sin(10πx) + 1.0")
    print("Dominio: x ∈ [0,1]")
    print("Objetivo: Maximización\n")
    ga = GeneticAlgorithm(
        population_size=150,
        chromosome_length=25,
        crossover_rate=0.85,
        mutation_rate=0.015,
        elitism_rate=0.15,
        tournament_size=7
    )
    print("Iniciando optimización...")
    best_x, best_fitness = ga.optimize(generations=800, verbose=True)
    print("\n" + "="*50)
    print("RESULTADOS FINALES:")
    print(f"Mejor x encontrado: {best_x:.8f}")
    print(f"Mejor fitness: {best_fitness:.8f}")

    # Cálculo del óptimo teórico real
    x_test = np.linspace(0, 1, 100000)
    f_test = [ga.objective_function(x) for x in x_test]
    max_f = np.max(f_test)
    max_x = x_test[np.argmax(f_test)]
    print(f"Valor teórico máximo ≈ {max_f:.8f} en x ≈ {max_x:.8f}")

    final_10_best = ga.best_fitness_history[-10:]
    convergence = max(final_10_best) - min(final_10_best)
    print(f"Convergencia (variación últimas 10 gen): {convergence:.8f}")

    print("\nAnálisis de máximos locales encontrados:")
    # Detectar picos locales en función objetivo
    local_maxima = []
    for i in range(1, len(f_test)-1):
        if f_test[i] > f_test[i-1] and f_test[i] > f_test[i+1]:
            local_maxima.append((x_test[i], f_test[i]))
    local_maxima.sort(key=lambda x: x[1], reverse=True)
    print("Top 5 máximos locales teóricos:")
    for i, (x, f) in enumerate(local_maxima[:5]):
        print(f"  {i+1}. x = {x:.6f}, f(x) = {f:.6f}")
    ga.plot_results()
    return best_x, best_fitness

if __name__ == "__main__":
    random.seed(42)
    np.random.seed(42)
    best_x, best_fitness = main()

import numpy as np
import matplotlib.pyplot as plt
import random
from typing import List, Tuple
import math

class ImprovedGeneticAlgorithm:
    def __init__(self,
                 population_size: int = 200,
                 chromosome_length: int = 30,
                 crossover_rate: float = 0.9,
                 mutation_rate: float = 0.02,
                 elitism_rate: float = 0.05,
                 tournament_size: int = 3,
                 immigration_rate: float = 0.1,
                 diversity_threshold: float = 0.01):
        self.population_size = population_size
        self.chromosome_length = chromosome_length
        self.crossover_rate = crossover_rate
        self.mutation_rate = mutation_rate
        self.elitism_rate = elitism_rate
        self.tournament_size = tournament_size
        self.immigration_rate = immigration_rate
        self.diversity_threshold = diversity_threshold
        self.elite_size = int(population_size * elitism_rate)
        self.immigrant_size = int(population_size * immigration_rate)
        self.best_fitness_history = []
        self.avg_fitness_history = []
        self.diversity_history = []
        self.best_individual_history = []
        self.stagnation_counter = 0
        self.max_stagnation = 50

    def objective_function(self, x: float) -> float:
        return x * math.sin(10 * math.pi * x) + 1.0

    def binary_to_decimal(self, binary_chromosome: List[int]) -> float:
        decimal_value = 0
        for i, bit in enumerate(binary_chromosome):
            decimal_value += bit * (2 ** (-(i + 1)))
        return decimal_value

    def decimal_to_binary(self, decimal_value: float) -> List[int]:
        binary = []
        remaining = decimal_value
        for i in range(self.chromosome_length):
            bit_value = 2 ** (-(i + 1))
            if remaining >= bit_value:
                binary.append(1)
                remaining -= bit_value
            else:
                binary.append(0)
        return binary

    def initialize_population(self) -> List[List[int]]:
        population = []
        for _ in range(int(self.population_size * 0.7)):
            chromosome = [random.randint(0, 1) for _ in range(self.chromosome_length)]
            population.append(chromosome)
        regions = np.linspace(0, 1, int(self.population_size * 0.3))
        for x_seed in regions:
            chromosome = self.decimal_to_binary(x_seed)
            for i in range(len(chromosome)):
                if random.random() < 0.1:
                    chromosome[i] = 1 - chromosome[i]
            population.append(chromosome)
        return population

    def calculate_diversity(self, population: List[List[int]]) -> float:
        if len(population) < 2:
            return 0.0
        total_distance = 0
        comparisons = 0
        for i in range(len(population)):
            for j in range(i + 1, len(population)):
                distance = sum(1 for a, b in zip(population[i], population[j]) if a != b)
                total_distance += distance
                comparisons += 1
        return total_distance / (comparisons * self.chromosome_length) if comparisons > 0 else 0

    def evaluate_fitness(self, population: List[List[int]]) -> List[float]:
        base_fitness = []
        for chromosome in population:
            x = self.binary_to_decimal(chromosome)
            fitness = self.objective_function(x)
            base_fitness.append(fitness)
        shared_fitness = []
        for i, fitness_i in enumerate(base_fitness):
            sharing_sum = 0
            for j, fitness_j in enumerate(base_fitness):
                if i != j:
                    distance = sum(1 for a, b in zip(population[i], population[j]) if a != b)
                    distance_norm = distance / self.chromosome_length
                    if distance_norm < 0.1:
                        sharing_sum += 1 - (distance_norm / 0.1)
            shared_fitness.append(fitness_i / (1 + sharing_sum))
        return shared_fitness

    def tournament_selection(self, population: List[List[int]], fitness_values: List[float]) -> List[int]:
        tournament_indices = random.sample(range(len(population)), self.tournament_size)
        tournament_fitness = [fitness_values[i] for i in tournament_indices]
        winner_index = tournament_indices[tournament_fitness.index(max(tournament_fitness))]
        return population[winner_index]

    def multi_point_crossover(self, parent1: List[int], parent2: List[int]) -> Tuple[List[int], List[int]]:
        if random.random() > self.crossover_rate:
            return parent1.copy(), parent2.copy()
        num_points = random.randint(2, 3)
        crossover_points = sorted(random.sample(range(1, self.chromosome_length), num_points))
        offspring1, offspring2 = [], []
        current_parent = 0
        last_point = 0
        for point in crossover_points + [self.chromosome_length]:
            if current_parent == 0:
                offspring1.extend(parent1[last_point:point])
                offspring2.extend(parent2[last_point:point])
            else:
                offspring1.extend(parent2[last_point:point])
                offspring2.extend(parent1[last_point:point])
            current_parent = 1 - current_parent
            last_point = point
        return offspring1, offspring2

    def adaptive_mutation(self, chromosome: List[int], generation: int, diversity: float) -> List[int]:
        adaptive_rate = self.mutation_rate
        if diversity < self.diversity_threshold:
            adaptive_rate *= 3
        adaptive_rate *= (1 - generation / 2000)
        adaptive_rate = max(adaptive_rate, 0.005)
        mutated = chromosome.copy()
        for i in range(self.chromosome_length):
            if random.random() < adaptive_rate:
                mutated[i] = 1 - mutated[i]
        if random.random() < 0.05:
            jump_length = random.randint(3, 8)
            start_pos = random.randint(0, self.chromosome_length - jump_length)
            for i in range(start_pos, start_pos + jump_length):
                mutated[i] = random.randint(0, 1)
        return mutated

    def immigration(self, population: List[List[int]]) -> List[List[int]]:
        new_population = population.copy()
        fitness_values = [self.objective_function(self.binary_to_decimal(ind)) for ind in population]
        sorted_indices = sorted(range(len(fitness_values)), key=lambda i: fitness_values[i])
        for i in range(self.immigrant_size):
            worst_idx = sorted_indices[i]
            new_individual = [random.randint(0, 1) for _ in range(self.chromosome_length)]
            new_population[worst_idx] = new_individual
        return new_population

    def restart_population(self, population: List[List[int]], keep_best: int = 5) -> List[List[int]]:
        fitness_values = [self.objective_function(self.binary_to_decimal(ind)) for ind in population]
        best_indices = sorted(range(len(fitness_values)), key=lambda i: fitness_values[i], reverse=True)[:keep_best]
        best_individuals = [population[i] for i in best_indices]
        new_population = self.initialize_population()
        for i, best_ind in enumerate(best_individuals):
            new_population[i] = best_ind
        return new_population

    def optimize(self, generations: int = 1000, verbose: bool = True) -> Tuple[float, float]:
        population = self.initialize_population()
        last_best_fitness = -float('inf')
        for generation in range(generations):
            fitness_values = self.evaluate_fitness(population)
            diversity = self.calculate_diversity(population)
            best_fitness = max(fitness_values)
            avg_fitness = sum(fitness_values) / len(fitness_values)
            best_idx = fitness_values.index(best_fitness)
            best_x = self.binary_to_decimal(population[best_idx])
            self.best_fitness_history.append(best_fitness)
            self.avg_fitness_history.append(avg_fitness)
            self.diversity_history.append(diversity)
            self.best_individual_history.append((best_x, best_fitness))
            if abs(best_fitness - last_best_fitness) < 1e-8:
                self.stagnation_counter += 1
            else:
                self.stagnation_counter = 0
            if verbose and generation % 50 == 0:
                print(f"Gen {generation}: Fitness={best_fitness:.6f}, x={best_x:.6f}, Div={diversity:.4f}, Stag={self.stagnation_counter}")
            if self.stagnation_counter >= self.max_stagnation:
                if verbose:
                    print(f"  >> Reiniciando población en generación {generation}")
                population = self.restart_population(population)
                self.stagnation_counter = 0
                continue
            new_population = []
            elite_indices = sorted(range(len(fitness_values)), key=lambda i: fitness_values[i], reverse=True)[:self.elite_size]
            elite = [population[i] for i in elite_indices]
            new_population.extend(elite)
            while len(new_population) < self.population_size:
                parent1 = self.tournament_selection(population, fitness_values)
                parent2 = self.tournament_selection(population, fitness_values)
                offspring1, offspring2 = self.multi_point_crossover(parent1, parent2)
                offspring1 = self.adaptive_mutation(offspring1, generation, diversity)
                offspring2 = self.adaptive_mutation(offspring2, generation, diversity)
                new_population.extend([offspring1, offspring2])
            population = new_population[:self.population_size]
            if generation % 100 == 0 and generation > 0:
                population = self.immigration(population)
            last_best_fitness = best_fitness
        final_fitness = [self.objective_function(self.binary_to_decimal(ind)) for ind in population]
        best_final_fitness = max(final_fitness)
        best_final_idx = final_fitness.index(best_final_fitness)
        best_final_x = self.binary_to_decimal(population[best_final_idx])
        return best_final_x, best_final_fitness

    def plot_results(self, max_x, max_f):
        fig, ((ax1, ax2), (ax3, ax4)) = plt.subplots(2, 2, figsize=(16, 12))
        ax1_twin = ax1.twinx()
        line1 = ax1.plot(self.best_fitness_history, 'r-', label='Mejor fitness', linewidth=2)
        line2 = ax1.plot(self.avg_fitness_history, 'b--', label='Fitness promedio', alpha=0.7)
        line3 = ax1_twin.plot(self.diversity_history, 'g:', label='Diversidad', alpha=0.8)
        ax1.set_xlabel('Generación')
        ax1.set_ylabel('Fitness', color='black')
        ax1_twin.set_ylabel('Diversidad', color='green')
        ax1.set_title('Evolución del Fitness y Diversidad')
        lines = line1 + line2 + line3
        labels = [l.get_label() for l in lines]
        ax1.legend(lines, labels, loc='upper left')
        ax1.grid(True, alpha=0.3)
        x_range = np.linspace(0, 1, 2000)
        y_range = [self.objective_function(x) for x in x_range]
        ax2.plot(x_range, y_range, 'b-', linewidth=2, label='f(x) = x·sin(10πx) + 1')
        best_x, best_fitness = self.best_individual_history[-1]
        ax2.plot(best_x, best_fitness, 'ro', markersize=12, label=f'Mejor: x={best_x:.6f}, f(x)={best_fitness:.6f}')
        ax2.plot(max_x, max_f, 'go', markersize=10, label=f'Óptimo teórico: x≈{max_x:.6f}, f(x)≈{max_f:.6f}')
        ax2.set_xlabel('x')
        ax2.set_ylabel('f(x)')
        ax2.set_title('Función Objetivo y Soluciones')
        ax2.legend()
        ax2.grid(True, alpha=0.3)
        exploration_x = [x for x, _ in self.best_individual_history[::20]]
        exploration_f = [f for _, f in self.best_individual_history[::20]]
        ax3.plot(x_range, y_range, 'b-', alpha=0.3, linewidth=1)
        scatter = ax3.scatter(exploration_x, exploration_f, c=range(len(exploration_x)), cmap='viridis', alpha=0.7, s=50)
        plt.colorbar(scatter, ax=ax3, label='Generación')
        ax3.set_xlabel('x')
        ax3.set_ylabel('f(x)')
        ax3.set_title('Exploración del Espacio (Evolución Temporal)')
        ax3.grid(True, alpha=0.3)
        best_x_history = [x for x, _ in self.best_individual_history]
        ax4.plot(best_x_history, 'purple', linewidth=2)
        ax4.axhline(y=max_x, color='red', linestyle='--', alpha=0.7, label=f'Óptimo teórico x≈{max_x:.6f}')
        ax4.set_xlabel('Generación')
        ax4.set_ylabel('Mejor x')
        ax4.set_title('Convergencia de la Variable x')
        ax4.legend()
        ax4.grid(True, alpha=0.3)
        plt.tight_layout()
        plt.show()

def main():
    print("=== ALGORITMO GENÉTICO MEJORADO PARA OPTIMIZACIÓN GLOBAL ===")
    print("Función: f(x) = x⋅sin(10πx) + 1.0")
    print("Dominio: x ∈ [0,1]")
    print("Objetivo: Encontrar el ÓPTIMO GLOBAL\n")
    best_overall_x = 0
    best_overall_fitness = -float('inf')
    best_ga = None
    num_runs = 5
    print(f"Ejecutando {num_runs} corridas independientes...\n")
    for run in range(num_runs):
        print(f"--- CORRIDA {run + 1} ---")
        ga = ImprovedGeneticAlgorithm(
            population_size=300,
            chromosome_length=35,
            crossover_rate=0.9,
            mutation_rate=0.03,
            elitism_rate=0.05,
            tournament_size=3,
            immigration_rate=0.15,
            diversity_threshold=0.02
        )
        best_x, best_fitness = ga.optimize(generations=1500, verbose=False)
        print(f"Resultado: x = {best_x:.8f}, fitness = {best_fitness:.8f}")
        if best_fitness > best_overall_fitness:
            best_overall_fitness = best_fitness
            best_overall_x = best_x
            best_ga = ga
        print()
    print("="*60)
    print("MEJOR RESULTADO DE TODAS LAS CORRIDAS:")
    print(f"Mejor x: {best_overall_x:.8f}")
    print(f"Mejor fitness: {best_overall_fitness:.8f}")
    # Cálculo del óptimo teórico real en [0,1]
    x_test = np.linspace(0, 1, 100000)
    f_test = [best_ga.objective_function(x) for x in x_test]
    max_f = np.max(f_test)
    max_x = x_test[np.argmax(f_test)]
    print(f"\nÓptimo teórico (calculado): x ≈ {max_x:.8f}, f(x) ≈ {max_f:.8f}")
    # Visualizar el mejor resultado
    if best_ga:
        best_ga.plot_results(max_x, max_f)
    return best_overall_x, best_overall_fitness

if __name__ == "__main__":
    seeds = [42, 123, 456, 789, 999]
    for seed in seeds:
        random.seed(seed)
        np.random.seed(seed)
        print(f"\n{'='*20} SEMILLA {seed} {'='*20}")
        best_x, best_fitness = main()
        # Si encuentra el óptimo global, parar
        if best_fitness > 1.84:
            print("¡Óptimo global encontrado! Deteniendo búsqueda.")
            break
        print(f"Resultado con semilla {seed}: {best_fitness:.6f}")

# Importar las funciones necesarias de IPython para mostrar HTML
from IPython.core.display import display, HTML

# Definir el contenido HTML, CSS y JavaScript como un string multilínea
html_content = """
<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Formulación Matemática de Algoritmos Genéticos</title>
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet">
  <style>
    /* Definición de variables CSS para temas */
    :root {
      --bg-color: #f9f9f9;
      --text-color: #333;
      --header-color: #2c3e50;
      --header-dark-color: #ecf0f1;
      --accent-color: #3498db; /* Azul clásico para formalidad */
      --accent-dark-color: #85c1e9; /* Azul más claro para modo oscuro */
      --button-bg: #5dade2; /* Azul un poco más claro para botones */
      --button-hover-bg: #2e86c1; /* Azul más oscuro para hover */
      --button-dark-bg: #af7ac5; /* Morado para modo oscuro */
      --button-dark-hover-bg: #8e44ad; /* Morado oscuro para hover */
      --button-text-color: white;
      --theme-button-bg: #8e44ad;
      --theme-button-dark-bg: #f39c12;
      --content-panel-bg: #eaf2f8;
      --content-panel-dark-bg: #28323a; /* Un gris azulado más oscuro */
      --table-border-color: #bdc3c7;
      --table-header-bg: #d6eaf8;
      --table-header-dark-bg: #3c4f62;
      --formula-bg: #ffffff;
      --formula-dark-bg: #34495e;
      --formula-border: #cccccc;
      --formula-dark-border: #556677;
    }

    body {
      font-family: 'Roboto', Arial, sans-serif;
      line-height: 1.8;
      background-color: var(--bg-color);
      color: var(--text-color);
      transition: background-color 0.3s, color 0.3s;
      padding: 20px;
      margin: 0;
    }
    .container {
      max-width: 900px;
      margin: auto;
      padding: 20px;
      position: relative;
      background-color: var(--bg-color);
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    }
    body.dark-mode .container {
        box-shadow: 0 2px 10px rgba(0,0,0,0.3);
    }
    body.dark-mode {
      --bg-color: #212f3c; /* Fondo más oscuro */
      --text-color: #ecf0f1;
      --header-color: var(--header-dark-color);
      --accent-color: var(--accent-dark-color);
      --button-bg: var(--button-dark-bg);
      --button-hover-bg: var(--button-dark-hover-bg);
      --content-panel-bg: var(--content-panel-dark-bg);
      --table-border-color: #566573;
      --table-header-bg: var(--table-header-dark-bg);
      --formula-bg: var(--formula-dark-bg);
      --formula-border: var(--formula-dark-border);
    }

    h1 {
      font-size: 2.2em; /* Ligeramente más pequeño para tema formal */
      color: var(--header-color);
      text-align: center;
      margin-bottom: 20px;
    }
    h2 {
      font-size: 1.7em;
      color: var(--accent-color);
      margin-top: 25px;
      margin-bottom: 10px;
      padding-bottom: 5px;
      border-bottom: 2px solid var(--accent-color);
      text-align: left;
    }
    h3 {
      font-size: 1.4em;
      color: var(--header-color);
      margin-top: 20px;
      margin-bottom: 10px;
      text-align: left;
    }

    .content-panel {
      display: none;
      margin-top: 0;
      padding: 20px;
      border-left: 4px solid var(--accent-color);
      background-color: var(--content-panel-bg);
      border-radius: 0 0 5px 5px;
    }
    .content-panel.is-visible {
      display: block;
    }

    .section-toggle-button {
      background-color: var(--button-bg);
      color: var(--button-text-color);
      border: none;
      padding: 12px 18px;
      border-radius: 5px;
      cursor: pointer;
      margin-top: 15px;
      transition: background-color 0.3s, border-radius 0.2s;
      width: 100%;
      text-align: left;
      font-size: 1.2em;
      font-weight: 700;
    }
    .section-toggle-button:hover {
      background-color: var(--button-hover-bg);
    }
    .section-toggle-button.is-expanded {
        border-radius: 5px 5px 0 0;
    }

    .theme-toggle {
      background-color: var(--theme-button-bg);
      color: white;
      border: none;
      padding: 8px 12px;
      border-radius: 5px;
      cursor: pointer;
      position: absolute;
      top: 20px;
      right: 20px;
      font-size: 0.9em;
      transition: background-color 0.3s;
      z-index: 10;
    }
    body.dark-mode .theme-toggle {
       background-color: var(--theme-button-dark-bg);
    }

    button:focus, a:focus {
        outline: 2px solid var(--accent-color);
        outline-offset: 2px;
    }
    body.dark-mode button:focus, body.dark-mode a:focus {
         outline-color: var(--accent-dark-color);
    }
    .content-panel p, .content-panel ul, .content-panel ol, .content-panel .formula-container {
        margin-bottom: 1.2em;
    }
    .content-panel p:last-child, .content-panel ul:last-child, .content-panel ol:last-child, .content-panel .formula-container:last-child {
        margin-bottom: 0;
    }
    ul, ol {
        padding-left: 30px;
    }
    li {
        margin-bottom: 0.6em;
    }
    strong {
        font-weight: 700;
    }
    .initial-intro {
        font-style: italic;
        margin-bottom: 20px;
        padding: 10px;
        background-color: var(--content-panel-bg);
        border-left: 3px solid var(--accent-color);
    }

    /* Estilos para fórmulas */
    .formula-container {
        background-color: var(--formula-bg);
        border: 1px solid var(--formula-border);
        padding: 15px;
        margin: 10px 0;
        border-radius: 4px;
        overflow-x: auto; /* Para fórmulas largas */
        font-family: 'Times New Roman', Times, serif; /* Fuente más matemática */
        font-size: 1.1em;
    }
    .formula-container strong { /* Para etiquetas de fórmula */
        display: block;
        margin-bottom: 8px;
        color: var(--header-color);
        font-family: 'Roboto', Arial, sans-serif; /* Volver a Roboto para etiquetas */
    }
    .formula-container var, .formula-container i { /* Para variables matemáticas */
        font-style: italic;
    }
    .formula-container .fraction {
        display: inline-block;
        text-align: center;
        vertical-align: middle;
    }
    .formula-container .numerator {
        border-bottom: 1px solid var(--text-color);
        display: block;
        padding: 0 0.2em;
    }
    .formula-container .denominator {
        display: block;
        padding: 0 0.2em;
    }


    /* Estilos para la tabla de resumen */
    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 20px;
      margin-bottom: 15px;
    }
    th, td {
      border: 1px solid var(--table-border-color);
      padding: 12px; /* Más padding */
      text-align: left;
      vertical-align: top;
    }
    th {
      background-color: var(--table-header-bg);
      color: var(--header-color);
      font-weight: 700;
    }
    body.dark-mode th {
        color: var(--header-dark-color);
    }
    td:first-child { /* Primera columna (Enfoque) en negrita */
        font-weight: bold;
    }
    caption {
      caption-side: top;
      font-size: 1.3em;
      font-weight: bold;
      color: var(--header-color);
      margin-bottom: 10px;
      text-align: center;
    }

  </style>
</head>
<body>
  <div class="container">
    <button id="theme-toggle-btn" class="theme-toggle" onclick="toggleTheme()" title="Cambiar tema de color">Modo Oscuro</button>

    <h1>Formulación Matemática del Algoritmo Genético</h1>
    <p class="initial-intro">
      La formulación matemática del algoritmo genético (AG) es particular, ya que no es un algoritmo determinista clásico como el simplex o el gradiente descendente. Es un proceso estocástico, por lo tanto, su formulación se basa más en probabilidades, teoría de Markov, teoría de esquemas y teoría de cadenas genéticas. Aquí se presentan los enfoques esenciales.
    </p>

    <!-- Sección 1: Modelo de Markov -->
    <button class="section-toggle-button" onclick="toggleSection('fm_markov', this)" aria-expanded="false" aria-controls="fm_markov">
      1. Modelo de Markov (estocástico)
    </button>
    <div id="fm_markov" class="content-panel">
      <p>Los algoritmos genéticos pueden modelarse como cadenas de Markov de primer orden en las que cada estado representa una población de soluciones, y la probabilidad de transición depende solo de la población actual.</p>
      <p>Sea <i>P<sub>t</sub></i> la población en la generación <i>t</i>.</p>
      <p>El algoritmo genético define una función de transición estocástica <i>T</i> tal que:</p>
      <div class="formula-container">
        P(<i>P<sub>t+1</sub></i> | <i>P<sub>t</sub></i>) = <i>T</i>(<i>P<sub>t</sub></i>)
      </div>
      <p>Bajo ciertas condiciones (p. ej. diversidad suficiente, no cero probabilidades de mutación), se puede demostrar que el AG converge en probabilidad a un conjunto de soluciones óptimas (no necesariamente el global).</p>
    </div>

    <!-- Sección 2: Teorema del Esquema de Holland -->
    <button class="section-toggle-button" onclick="toggleSection('fm_schema', this)" aria-expanded="false" aria-controls="fm_schema">
      2. Teorema del Esquema de Holland (Schema Theorem)
    </button>
    <div id="fm_schema" class="content-panel">
      <p>Uno de los fundamentos teóricos más importantes en AG. Define cómo los esquemas (patrones parciales de cromosomas) evolucionan a lo largo del tiempo.</p>
      <h3>Definición de esquema:</h3>
      <p>Un esquema <i>H</i> es una plantilla de genes que especifica valores fijos en ciertas posiciones y "comodines" (*) en otras.</p>
      <p>Por ejemplo, para una codificación binaria de 6 bits, el esquema:</p>
      <div class="formula-container"><i>H</i> = 1 * 0 * * 1</div>
      <p>representa todos los cromosomas donde:</p>
      <ul>
        <li>el primer bit es 1,</li>
        <li>el tercer bit es 0,</li>
        <li>el sexto bit es 1,</li>
        <li>y los demás pueden tomar cualquier valor.</li>
      </ul>
      <h3>Fórmula del Teorema del Esquema:</h3>
      <p>El número esperado de individuos en la próxima generación que pertenecen al esquema <i>H</i>, denotado <i>m</i>(<i>H</i>, <i>t</i>+1), es:</p>
      <div class="formula-container">
        <i>m</i>(<i>H</i>, <i>t</i>+1) ≥ <i>m</i>(<i>H</i>, <i>t</i>) ⋅
        <span class="fraction"><span class="numerator"><i>f</i>(<i>H</i>)</span><span class="denominator"><i>f̄</i></span></span>
        ⋅ (1 − <i>p<sub>c</sub></i> ⋅
        <span class="fraction"><span class="numerator">δ(<i>H</i>)</span><span class="denominator"><i>l</i>−1</span></span>
        − <i>p<sub>m</sub></i> ⋅ <i>o</i>(<i>H</i>))
      </div>
      <p>Donde:</p>
      <ul>
        <li><i>m</i>(<i>H</i>, <i>t</i>): número de individuos en <i>H</i> en la generación <i>t</i>.</li>
        <li><i>f</i>(<i>H</i>): aptitud promedio de los individuos que pertenecen a <i>H</i>.</li>
        <li><i>f̄</i>: aptitud promedio de toda la población.</li>
        <li><i>p<sub>c</sub></i>: probabilidad de cruce.</li>
        <li>δ(<i>H</i>): longitud del esquema (distancia entre los bits más lejanos definidos).</li>
        <li><i>l</i>: longitud del cromosoma.</li>
        <li><i>p<sub>m</sub></i>: probabilidad de mutación por bit.</li>
        <li><i>o</i>(<i>H</i>): número de bits definidos en el esquema.</li>
      </ul>
      <h3>Interpretación:</h3>
      <p>El teorema muestra cómo los esquemas de alta aptitud, cortos y con pocos bits definidos tienden a sobrevivir y multiplicarse — "supervivencia del más apto y más compacto".</p>
    </div>

    <!-- Sección 3: Evolución de la distribución de probabilidad -->
    <button class="section-toggle-button" onclick="toggleSection('fm_distribucion', this)" aria-expanded="false" aria-controls="fm_distribucion">
      3. Evolución de la distribución de probabilidad
    </button>
    <div id="fm_distribucion" class="content-panel">
      <p>En lugar de analizar individuos específicos, se puede modelar cómo cambia la distribución de probabilidad sobre el espacio de soluciones.</p>
      <p>Sea <i>x</i> ∈ <i>S</i> una solución posible, y <i>P<sub>t</sub></i>(<i>x</i>) la probabilidad de que <i>x</i> esté presente en la población en la generación <i>t</i>.</p>
      <p>El algoritmo genético define un operador de evolución <i>G</i> tal que:</p>
      <div class="formula-container">
        <i>P<sub>t+1</sub></i>(<i>x</i>) = <i>G</i>(<i>P<sub>t</sub></i>(<i>x</i>))
      </div>
      <p>Este enfoque se usa en la teoría de algoritmos evolutivos distribuidos y de estimación de distribución (Estimation of Distribution Algorithms, EDA), que son variantes más formales y analíticas.</p>
    </div>

    <!-- Sección 4: Optimización matemática basada en fitness -->
    <button class="section-toggle-button" onclick="toggleSection('fm_optimizacion', this)" aria-expanded="false" aria-controls="fm_optimizacion">
      4. Optimización matemática basada en fitness
    </button>
    <div id="fm_optimizacion" class="content-panel">
      <p>Aunque los AG no buscan optimizar una función directamente como en los métodos clásicos, el objetivo final sigue siendo:</p>
      <div class="formula-container">
        max<sub><i>x</i>∈<i>S</i></sub> <i>f</i>(<i>x</i>)
      </div>
      <p>El AG actúa como un algoritmo de búsqueda estocástico que intenta encontrar una <i>x<sup>*</sup></i> ∈ <i>S</i> tal que:</p>
      <div class="formula-container">
        <i>f</i>(<i>x<sup>*</sup></i>) ≥ <i>f</i>(<i>x</i>), ∀<i>x</i> ∈ <i>S</i>
      </div>
      <p>Dado que no hay garantía de encontrar el óptimo global, se suele hablar de:</p>
      <ul>
        <li>óptimos aproximados</li>
        <li>soluciones suficientemente buenas</li>
        <li>convergencia en probabilidad (bajo ciertas condiciones teóricas)</li>
      </ul>
    </div>

    <!-- Sección 5: Resumen de la formulación matemática -->
    <button class="section-toggle-button" onclick="toggleSection('fm_resumen', this)" aria-expanded="false" aria-controls="fm_resumen">
      Resumen de la Formulación Matemática
    </button>
    <div id="fm_resumen" class="content-panel">
      <table>
        <caption>Principales Enfoques de Formulación Matemática en AG</caption>
        <thead>
          <tr>
            <th>Enfoque</th>
            <th>Explicación</th>
            <th>Fórmula / Modelo Clave</th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>Cadenas de Markov</td>
            <td>El AG es un proceso estocástico sobre poblaciones.</td>
            <td><i>P</i>(<i>P<sub>t+1</sub></i> | <i>P<sub>t</sub></i>) = <i>T</i>(<i>P<sub>t</sub></i>)</td>
          </tr>
          <tr>
            <td>Teorema del Esquema</td>
            <td>Patrones con buena aptitud tienden a reproducirse.</td>
            <td><i>m</i>(<i>H</i>, <i>t</i>+1) ≥ <i>m</i>(<i>H</i>,<i>t</i>) ⋅ (<i>f</i>(<i>H</i>)/<i>f̄</i>) ⋅ (1 - pérdidas)</td>
          </tr>
          <tr>
            <td>Distribución de probabilidad</td>
            <td>Evolución de probabilidad sobre el espacio de soluciones.</td>
            <td><i>P<sub>t+1</sub></i>(<i>x</i>) = <i>G</i>(<i>P<sub>t</sub></i>(<i>x</i>))</td>
          </tr>
          <tr>
            <td>Optimización estocástica</td>
            <td>AG busca maximizar <i>f</i>(<i>x</i>) sin derivadas ni convexidad.</td>
            <td>max<sub><i>x</i>∈<i>S</i></sub> <i>f</i>(<i>x</i>)</td>
          </tr>
        </tbody>
      </table>
    </div>

  </div> <!-- Fin de .container -->

  <script>
    // Función para cambiar entre modo claro y oscuro
    function toggleTheme() {
      document.body.classList.toggle("dark-mode");
      let themeButton = document.getElementById('theme-toggle-btn');
      let isDarkMode = document.body.classList.contains("dark-mode");
      localStorage.setItem("theme", isDarkMode ? "dark" : "light");
      if (themeButton) {
          themeButton.textContent = isDarkMode ? "Modo Claro" : "Modo Oscuro";
      }
    }

    // Función para mostrar/ocultar paneles de contenido
    function toggleSection(id, buttonElement) {
      let panel = document.getElementById(id);
      if (panel && buttonElement) {
          panel.classList.toggle('is-visible');
          let isVisible = panel.classList.contains('is-visible');
          buttonElement.setAttribute('aria-expanded', isVisible);
          buttonElement.classList.toggle('is-expanded', isVisible);
      }
    }

    // Función que se ejecuta cuando la página carga
    window.onload = function() {
      let themeButton = document.getElementById('theme-toggle-btn');
      const savedTheme = localStorage.getItem("theme");

      if (savedTheme === "dark") {
        document.body.classList.add("dark-mode");
        if (themeButton) {
            themeButton.textContent = "Modo Claro";
        }
      } else {
        document.body.classList.remove("dark-mode");
        if (themeButton) {
            themeButton.textContent = "Modo Oscuro";
        }
      }

       document.querySelectorAll('.content-panel').forEach(panel => {
         panel.classList.remove('is-visible');
       });
       document.querySelectorAll('.section-toggle-button').forEach(button => {
          button.setAttribute('aria-expanded', 'false');
          button.classList.remove('is-expanded');
       });
    }
  </script>
</body>
</html>
"""

# Mostrar el HTML en la salida de la celda
display(HTML(html_content))

"""ergodicidad  i puede a cualquier punto de la solución , no hay ciclos que tres pasos al  vuelvo al inicio  mayor variedad de la población , mutacion torneos, ruletas  aumenta variabilidad de la poblacion ergocidad en todo el espacio solución no solo en una parte   optimos globables"""

import networkx as nx
import matplotlib.pyplot as plt
import numpy as np
import random
import seaborn as sns
import time

# Configuración de estilo visual
plt.style.use('default')
sns.set_palette("husl")
plt.rcParams['figure.facecolor'] = 'white'
plt.rcParams['axes.facecolor'] = 'white'
plt.rcParams['savefig.facecolor'] = 'white'

class GeneticHamiltonianSolver:
    def __init__(self, graph, population_size=100, elite_size=20, mutation_rate=0.15,
                 crossover_rate=0.8, max_generations=500, animate=False,
                 stagnation_limit=50, random_seed=None):  # Nuevos parámetros

        self.random_seed = random_seed
        if self.random_seed is not None:
            random.seed(self.random_seed)
            np.random.seed(self.random_seed)

        self.graph = graph
        self.nodes = list(graph.nodes())

        if not self.nodes:
            raise ValueError("El grafo no puede estar vacío.")

        if len(self.nodes) > 1 and not nx.is_connected(self.graph):
            # Permitir grafos de 1 nodo (trivialmente HC para algunas definiciones)
            # Grafos de 0 nodos ya se manejan arriba.
            raise ValueError("El grafo no es conexo. Un ciclo Hamiltoniano no puede existir.")

        self.n_nodes = len(self.nodes)
        if self.n_nodes < 3 and self.n_nodes > 0:  # Incluye n_nodes == 1, 2
            print(f"Advertencia: El grafo tiene {self.n_nodes} nodos. "
                  "La definición estricta de ciclo Hamiltoniano es para n >= 3 nodos.")

        self.population_size = population_size
        self.elite_size = elite_size
        self.mutation_rate = mutation_rate
        self.crossover_rate = crossover_rate
        self.max_generations = max_generations
        self.animate = animate
        self.stagnation_limit = stagnation_limit

        self.best_fitness_history = []
        self.avg_fitness_history = []
        self.diversity_history = []
        self.generation_times = []

        self.best_cycle = None
        self.best_fitness = float('-inf')
        self.current_generation = 0
        self.generations_since_last_improvement = 0

        self.pos = nx.spring_layout(
            graph,
            seed=self.random_seed if self.random_seed is not None else 42,
            k=2/np.sqrt(self.n_nodes) if self.n_nodes > 0 else 2,
            iterations=100
        )
        self.fig_dynamic = None
        self.axes_dynamic = None

    def create_individual(self):
        individual = self.nodes.copy()
        random.shuffle(individual)
        return individual

    def create_population(self):
        population = []
        if self.n_nodes == 0:
            return []
        # Asegurar que pop_size / 4 no sea 0 si pop_size es pequeño
        num_greedy = max(1, self.population_size // 4) if self.population_size >= 4 else 0
        num_random_fill = self.population_size // 2

        for _ in range(num_random_fill):
            population.append(self.create_individual())
        for _ in range(num_greedy):
            if len(population) < self.population_size:  # Evitar exceder
                population.append(self.create_greedy_individual())
        while len(population) < self.population_size:
            population.append(self.create_individual())
        return population

    def create_greedy_individual(self):
        if not self.nodes:
            return []
        unvisited = set(self.nodes)
        start_node = random.choice(self.nodes)
        current = start_node
        path = [current]
        unvisited.remove(current)
        while unvisited:
            neighbors = [n for n in self.graph.neighbors(current) if n in unvisited]
            next_node = random.choice(neighbors) if neighbors else random.choice(list(unvisited))
            path.append(next_node)
            unvisited.remove(next_node)
            current = next_node
        return path

    def fitness(self, individual):
        if not individual or len(individual) != self.n_nodes:
            return float('-inf')
        score = 0
        valid_edges = 0
        total_edges = self.n_nodes

        max_consecutive_valid_edges = 0
        current_consecutive_valid_edges = 0

        for i in range(self.n_nodes):
            current_node, next_node = individual[i], individual[(i + 1) % self.n_nodes]
            if self.graph.has_edge(current_node, next_node):
                valid_edges += 1
                score += 10
                current_consecutive_valid_edges += 1
            else:
                score -= 7  # Penalización un poco mayor por aristas faltantes
                if current_consecutive_valid_edges > max_consecutive_valid_edges:
                    max_consecutive_valid_edges = current_consecutive_valid_edges
                current_consecutive_valid_edges = 0

        if current_consecutive_valid_edges > max_consecutive_valid_edges:
            max_consecutive_valid_edges = current_consecutive_valid_edges

        if total_edges > 0:
            score += (max_consecutive_valid_edges / total_edges) * 20  # Bonificación por secuencia más larga

        if valid_edges == total_edges and len(set(individual)) == self.n_nodes:
            score += 100
        completeness_ratio = valid_edges / total_edges if total_edges > 0 else 0
        score += completeness_ratio * 50
        if len(set(individual)) != len(individual):
            score -= 500
        return score

    def is_hamiltonian_cycle(self, individual):
        if not individual or len(individual) != self.n_nodes or len(set(individual)) != self.n_nodes:
            return False
        for i in range(self.n_nodes):
            if not self.graph.has_edge(individual[i], individual[(i + 1) % self.n_nodes]):
                return False
        return True

    def selection(self, population, fitnesses):
        selected = []
        pop_size = len(population)
        if pop_size == 0:
            return []
        for _ in range(pop_size):
            tourn_size = min(5, pop_size)
            tourn_indices = random.sample(range(pop_size), tourn_size)
            winner_idx_in_tourn = np.argmax([fitnesses[i] for i in tourn_indices])
            selected.append(population[tourn_indices[winner_idx_in_tourn]])
        return selected

    def crossover(self, parent1, parent2):
        if random.random() > self.crossover_rate or len(parent1) < 3:
            return parent1.copy(), parent2.copy()
        size = len(parent1)
        child1, child2 = [None] * size, [None] * size
        start, end = sorted(random.sample(range(size), 2))
        child1[start:end+1] = parent1[start:end+1]
        child2[start:end+1] = parent2[start:end+1]
        self._fill_child(child1, parent2, start, end, size)
        self._fill_child(child2, parent1, start, end, size)
        return child1, child2

    def _fill_child(self, child, parent, start, end, size):
        child_segment_set = set(child[start:end+1])
        current_pos = (end + 1) % size
        parent_ptr = (end + 1) % size
        filled_count = 0
        elements_to_fill = size - (end - start + 1)
        # Iterar un máximo de 'size' veces para evitar bucles infinitos si algo va mal con parent_ptr
        for _ in range(size):
            if filled_count >= elements_to_fill:
                break
            if parent[parent_ptr] not in child_segment_set:
                child[current_pos] = parent[parent_ptr]
                current_pos = (current_pos + 1) % size
                filled_count += 1
            parent_ptr = (parent_ptr + 1) % size

        if None in child:
            missing_nodes = list(set(self.nodes) - set(filter(None, child)))
            random.shuffle(missing_nodes)
            j = 0
            for i in range(size):
                if child[i] is None:
                    if j < len(missing_nodes):
                        child[i] = missing_nodes[j]
                        j += 1
                    else:  # Debería ser imposible si la lógica es correcta, pero como fallback...
                        child[i] = random.choice(list(set(self.nodes) - set(filter(None, child))))

    def mutate(self, individual):
        if random.random() < self.mutation_rate and len(individual) >= 2:
            mutation_type = random.choice(['swap', 'reverse', 'insert'])
            if mutation_type == 'swap':
                idx1, idx2 = random.sample(range(len(individual)), 2)
                individual[idx1], individual[idx2] = individual[idx2], individual[idx1]
            elif mutation_type == 'reverse' and len(individual) > 2:
                start, end = sorted(random.sample(range(len(individual)), 2))
                individual[start:end+1] = individual[start:end+1][::-1]
            elif mutation_type == 'insert' and len(individual) > 1:  # Necesita al menos 2 elementos para mover
                from_idx = random.randrange(len(individual))
                # Asegurar que to_idx sea diferente si es posible y significativo
                possible_to_indices = list(range(len(individual)))
                if len(possible_to_indices) > 1:
                    possible_to_indices.pop(from_idx if from_idx < len(possible_to_indices) else -1)  # Evitar error si from_idx es el ultimo

                to_idx = random.choice(possible_to_indices) if possible_to_indices else from_idx

                element = individual.pop(from_idx)
                individual.insert(to_idx, element)
        return individual

    def calculate_diversity(self, population):
        if len(population) < 2 or not population[0]:
            return 0.0
        num_comparisons, total_distance = 0, 0
        ind_len = len(population[0])
        if ind_len == 0:
            return 0.0
        # Para poblaciones grandes, muestrear pares para estimar diversidad
        sample_size = min(len(population), 50)  # Comparar hasta 50 individuos

        indices_to_compare = random.sample(range(len(population)), sample_size)

        for i_idx in range(len(indices_to_compare)):
            for j_idx in range(i_idx + 1, len(indices_to_compare)):
                idx1 = indices_to_compare[i_idx]
                idx2 = indices_to_compare[j_idx]
                dist = sum(1 for k in range(ind_len) if population[idx1][k] != population[idx2][k])
                total_distance += dist / ind_len
                num_comparisons += 1
        return total_distance / num_comparisons if num_comparisons > 0 else 0.0

    def setup_dynamic_visualization(self):
        if not self.animate:
            return
        plt.ion()
        self.fig_dynamic, self.axes_dynamic = plt.subplots(2, 3, figsize=(22, 13))
        self.fig_dynamic.patch.set_facecolor('white')
        self.fig_dynamic.suptitle('Evolución del Algoritmo Genético en Tiempo Real', fontsize=20, fontweight='bold')
        titles = [
            'Grafo Original', 'Mejor Solución Actual', 'Evolución del Fitness',
            'Top 5 Individuos', 'Diversidad Poblacional', 'Estadísticas Generación Actual'
        ]
        for i, ax in enumerate(self.axes_dynamic.flat):
            ax.set_title(titles[i], fontsize=14, fontweight='bold')
        plt.tight_layout(rect=[0, 0, 1, 0.96])
        plt.show(block=False)

    def update_dynamic_visualization(self, population, fitnesses):
        if not self.animate or self.axes_dynamic is None or not plt.fignum_exists(self.fig_dynamic.number):
            return
        for ax in self.axes_dynamic.flat:
            ax.clear()
        titles = [
            'Grafo Original', 'Mejor Solución Actual', 'Evolución del Fitness',
            'Top 5 Individuos', 'Diversidad Poblacional', 'Estadísticas Generación Actual'
        ]
        for i, ax in enumerate(self.axes_dynamic.flat):
            ax.set_title(titles[i], fontsize=14, fontweight='bold')

        # Panel 1: Grafo base
        ax = self.axes_dynamic[0, 0]
        edge_collection_dyn_base = nx.draw_networkx_edges(
            self.graph, self.pos,
            edge_color='#666666', width=1.8, alpha=0.85, ax=ax
        )
        if edge_collection_dyn_base:
            for ec_item in edge_collection_dyn_base if isinstance(edge_collection_dyn_base, list) else [edge_collection_dyn_base]:
                ec_item.set_zorder(1)
        node_collection_dyn_base = nx.draw_networkx_nodes(
            self.graph, self.pos,
            node_color='#87CEEB', node_size=300,
            edgecolors='#333333', linewidths=1.5, ax=ax
        )
        if node_collection_dyn_base:
            node_collection_dyn_base.set_zorder(2)
        labels_drawn_dyn_base = nx.draw_networkx_labels(self.graph, self.pos, font_size=9, font_weight='bold', ax=ax)
        if labels_drawn_dyn_base:
            for label_artist in labels_drawn_dyn_base.values():
                label_artist.set_zorder(3)
        ax.axis('off')

        # Panel 2: Mejor solución actual
        ax = self.axes_dynamic[0, 1]
        if self.best_cycle:
            is_hc = self.is_hamiltonian_cycle(self.best_cycle)
            title_suffix = " (Hamiltoniano)" if is_hc else ""
            self._draw_solution_on_axis(
                ax, self.best_cycle,
                f'Gen {self.current_generation} - Fitness: {self.best_fitness:.1f}{title_suffix}'
            )
        else:
            ax.text(0.5, 0.5, 'Sin solución aún', ha='center', va='center', transform=ax.transAxes, fontsize=12)
            nx.draw_networkx_nodes(self.graph, self.pos, node_color='#DDDDDD', node_size=300, ax=ax)
            nx.draw_networkx_edges(self.graph, self.pos, edge_color='#EEEEEE', width=1.5, alpha=0.5, ax=ax)
            ax.axis('off')

        # Panel 3: Evolución del fitness
        ax = self.axes_dynamic[0, 2]
        if len(self.best_fitness_history) > 1:
            gens = range(len(self.best_fitness_history))
            ax.plot(gens, self.best_fitness_history, 'g-', linewidth=2.5, label='Mejor Fitness')
            ax.plot(gens, self.avg_fitness_history, 'b--', linewidth=2, label='Fitness Promedio')
            ax.set_xlabel('Generación', fontsize=10)
            ax.set_ylabel('Fitness', fontsize=10)
            ax.legend(fontsize=9)
            ax.grid(True, linestyle=':', alpha=0.5)
        else:
            ax.text(0.5, 0.5, 'Calculando fitness...', ha='center', va='center', transform=ax.transAxes, fontsize=12)

        # Panel 4: Top 5 individuos
        ax = self.axes_dynamic[1, 0]
        if fitnesses and population:
            sorted_indices = np.argsort(fitnesses)[::-1]
            top_n = min(5, len(population))
            top_fits = [fitnesses[i] for i in sorted_indices[:top_n]]
            colors = sns.color_palette("viridis", n_colors=top_n)
            bars = ax.bar(range(top_n), top_fits, color=colors)
            ax.set_xlabel('Top Individuos', fontsize=10)
            ax.set_ylabel('Fitness', fontsize=10)
            ax.set_xticks(range(top_n))
            ax.set_xticklabels([f'#{i+1}' for i in range(top_n)], fontsize=9)
            for bar_idx, bar in enumerate(bars):
                ax.text(
                    bar.get_x() + bar.get_width()/2.,
                    bar.get_height(),
                    f'{top_fits[bar_idx]:.1f}',
                    ha='center', va='bottom', fontsize=8, fontweight='bold'
                )
        else:
            ax.text(0.5, 0.5, 'Esperando población...', ha='center', va='center', transform=ax.transAxes, fontsize=12)

        # Panel 5: Diversidad poblacional
        ax = self.axes_dynamic[1, 1]
        if len(self.diversity_history) > 1:
            ax.plot(range(len(self.diversity_history)), self.diversity_history, 'r-', linewidth=2.5)
            ax.set_xlabel('Generación', fontsize=10)
            ax.set_ylabel('Diversidad (Hamming prom.)', fontsize=10)
            ax.grid(True, linestyle=':', alpha=0.5)
            ax.set_ylim(0, 1)
        else:
            ax.text(0.5, 0.5, 'Calculando diversidad...', ha='center', va='center', transform=ax.transAxes, fontsize=12)

        # Panel 6: Estadísticas de generación actual
        ax = self.axes_dynamic[1, 2]
        if fitnesses:
            is_hc_found = (self.best_cycle and self.is_hamiltonian_cycle(self.best_cycle))
            hc_status = 'SÍ' if is_hc_found else 'NO'
            time_gen_str = f"Tiempo Gen.: {self.generation_times[-1]:.3f}s" if self.generation_times else "Tiempo Gen.: N/A"
            stagnation_str = f"Estanc.: {self.generations_since_last_improvement}/{self.stagnation_limit}"
            stats_text = (
                f"Generación: {self.current_generation}/{self.max_generations} ({stagnation_str})\n"
                f"Población: {len(population)}\nMejor Fitness: {max(fitnesses):.2f}\n"
                f"Fitness Prom.: {np.mean(fitnesses):.2f}\n"
                f"Diversidad: {self.diversity_history[-1] if self.diversity_history else 0:.3f}\n"
                f"Hamiltoniano?: {hc_status}\n{time_gen_str}"
            )
        else:
            stats_text = "Calculando estadísticas..."
        ax.text(
            0.05, 0.95, stats_text,
            transform=ax.transAxes, fontsize=10, va='top', fontfamily='monospace',
            bbox=dict(boxstyle="round,pad=0.4", facecolor="#e0f2f7", alpha=0.9)
        )
        ax.axis('off')

        plt.tight_layout(rect=[0, 0, 1, 0.96])
        try:
            self.fig_dynamic.canvas.flush_events()
            plt.pause(0.05)
        except Exception:
            self.animate = False  # Desactivar si hay problemas con UI

    def _draw_solution_on_axis(self, ax, solution, title):
        edge_collection_bg = nx.draw_networkx_edges(
            self.graph, self.pos,
            edge_color='#BBBBBB', width=1.5, alpha=0.75, ax=ax
        )
        if edge_collection_bg:
            for ec_item in edge_collection_bg if isinstance(edge_collection_bg, list) else [edge_collection_bg]:
                ec_item.set_zorder(1)

        cycle_edges = []
        if solution and len(solution) == self.n_nodes:
            for i in range(self.n_nodes):
                cycle_edges.append((solution[i], solution[(i + 1) % self.n_nodes]))

        valid_cycle_edges = [edge for edge in cycle_edges if self.graph.has_edge(*edge)]
        invalid_cycle_edges = [edge for edge in cycle_edges if not self.graph.has_edge(*edge)]

        if valid_cycle_edges:
            edge_collection_valid_sol = nx.draw_networkx_edges(
                self.graph, self.pos,
                edgelist=valid_cycle_edges,
                edge_color='#228B22', width=3, alpha=0.9, ax=ax
            )
            if edge_collection_valid_sol:
                for ec_item in edge_collection_valid_sol if isinstance(edge_collection_valid_sol, list) else [edge_collection_valid_sol]:
                    ec_item.set_zorder(2)
        if invalid_cycle_edges:
            for u, v in invalid_cycle_edges:
                if u in self.pos and v in self.pos:
                    ax.plot(
                        [self.pos[u][0], self.pos[v][0]],
                        [self.pos[u][1], self.pos[v][1]],
                        'r--', linewidth=2.5, alpha=0.8, zorder=2
                    )

        node_colors_list = ['#DDDDDD'] * len(self.nodes)
        if solution:
            cmap_colors = plt.cm.Set3.colors
            num_cmap_colors = len(cmap_colors)
            node_color_map = {
                node_in_solution: cmap_colors[i % num_cmap_colors]
                for i, node_in_solution in enumerate(solution)
            }
            node_colors_list = [node_color_map.get(node, '#DDDDDD') for node in self.graph.nodes()]

        node_collection_sol = nx.draw_networkx_nodes(
            self.graph, self.pos,
            node_color=node_colors_list,
            node_size=300,
            edgecolors='#333333',
            linewidths=1.5,
            ax=ax
        )
        if node_collection_sol:
            node_collection_sol.set_zorder(3)
        labels_drawn_sol = nx.draw_networkx_labels(self.graph, self.pos, font_size=9, font_weight='bold', ax=ax)
        if labels_drawn_sol:
            for label_artist in labels_drawn_sol.values():
                label_artist.set_zorder(4)
        ax.set_title(title, fontsize=12, fontweight='bold')
        ax.axis('off')

    def evolve(self, verbose=True):
        if self.n_nodes == 0:
            return None, float('-inf')
        if self.n_nodes < 3:  # Casos triviales
            is_trivial_hc = False
            if self.n_nodes == 1:
                self.best_cycle = self.nodes.copy()
                is_trivial_hc = True
            elif self.n_nodes == 2 and self.graph.has_edge(self.nodes[0], self.nodes[1]):
                self.best_cycle = self.nodes.copy()
                is_trivial_hc = True  # Path [0,1], ciclo es (0,1) y (1,0)

            if is_trivial_hc:
                self.best_fitness = self.fitness(self.best_cycle)
                self.best_fitness_history.append(self.best_fitness)
                self.avg_fitness_history.append(self.best_fitness)
                self.diversity_history.append(0)
                self.generation_times.append(0)
                if verbose:
                    print(f"Ciclo Hamiltoniano (trivial) encontrado para {self.n_nodes} nodos.")
                if self.animate:
                    self.setup_dynamic_visualization()
                    self.update_dynamic_visualization([self.best_cycle], [self.best_fitness])
                    if self.fig_dynamic:
                        self.fig_dynamic.suptitle(
                            'CICLO HAMILTONIANO (TRIVIAL) ENCONTRADO!',
                            fontsize=24, color='green'
                        )
                        plt.pause(2)
                        plt.ioff()
                return self.best_cycle, self.best_fitness

        self.generations_since_last_improvement = 0  # Resetear al inicio de la evolución
        if self.animate:
            self.setup_dynamic_visualization()
        population = self.create_population()
        if not population:
            if self.animate:
                plt.ioff()
            return None, float('-inf')

        hamiltonian_found = False  # Flag para estado final

        for generation in range(self.max_generations):
            self.current_generation = generation
            start_time = time.time()
            fitnesses = [self.fitness(ind) for ind in population]

            max_fit_idx = np.argmax(fitnesses)
            if fitnesses[max_fit_idx] > self.best_fitness:
                self.best_fitness = fitnesses[max_fit_idx]
                self.best_cycle = population[max_fit_idx].copy()
                self.generations_since_last_improvement = 0
            else:
                self.generations_since_last_improvement += 1

            avg_fitness = np.mean(fitnesses)
            diversity = self.calculate_diversity(population)
            self.best_fitness_history.append(self.best_fitness)
            self.avg_fitness_history.append(avg_fitness)
            self.diversity_history.append(diversity)
            self.generation_times.append(time.time() - start_time)

            if self.animate and (generation % 1 == 0 or generation == self.max_generations - 1):
                self.update_dynamic_visualization(population, fitnesses)

            hamiltonian_found = self.best_cycle and self.is_hamiltonian_cycle(self.best_cycle)
            if hamiltonian_found:
                if verbose:
                    print(f"Ciclo Hamiltoniano encontrado en generación {generation}!")
                if self.animate and self.fig_dynamic:
                    self.update_dynamic_visualization(population, fitnesses)  # Última actualización
                    self.fig_dynamic.suptitle(
                        'CICLO HAMILTONIANO ENCONTRADO!',
                        fontsize=24, color='green'
                    )
                    plt.pause(3)
                break

            if self.generations_since_last_improvement >= self.stagnation_limit:
                if verbose:
                    print(
                        f"Terminado por estancamiento: No hubo mejora en el mejor fitness "
                        f"during {self.stagnation_limit} generaciones (Gen {generation})."
                    )
                if self.animate and self.fig_dynamic:
                    self.update_dynamic_visualization(population, fitnesses)
                    self.fig_dynamic.suptitle(
                        f'TERMINADO POR ESTANCAMIENTO (Gen {generation})',
                        fontsize=20, color='red'
                    )
                    plt.pause(3)
                break

            selected = self.selection(population, fitnesses)
            elite_indices = np.argsort(fitnesses)[-self.elite_size:]
            new_population = [population[i] for i in elite_indices]

            while len(new_population) < self.population_size:
                if len(selected) >= 2:
                    p1, p2 = random.sample(selected, 2)
                elif selected:
                    p1, p2 = selected[0], selected[0]
                else:
                    p1, p2 = self.create_individual(), self.create_individual()
                c1, c2 = self.crossover(p1, p2)
                new_population.append(self.mutate(c1))
                if len(new_population) < self.population_size:
                    new_population.append(self.mutate(c2))
            population = new_population[:self.population_size]

            if verbose and (generation % 25 == 0 or generation == self.max_generations - 1):
                status = "Encontrado!" if hamiltonian_found else "Buscando..."
                stagn_str = f"Stagn: {self.generations_since_last_improvement}"
                print(
                    f"Gen {generation:4d}/{self.max_generations} ({stagn_str}): "
                    f"BestFit={self.best_fitness:7.1f}, AvgFit={avg_fitness:7.1f}, "
                    f"Div={diversity:.3f}, Time={self.generation_times[-1]:.3f}s - {status}"
                )

        if verbose and not hamiltonian_found and self.generations_since_last_improvement < self.stagnation_limit:
            print(
                f"Algoritmo finalizado por alcanzar max_generations. "
                f"No se encontró ciclo Hamiltoniano tras {self.max_generations} generaciones."
            )
            if self.best_cycle:
                print(f"Mejor solución (no HC) fitness {self.best_fitness:.1f}: {self.best_cycle}")

        if self.animate:
            if self.fig_dynamic and plt.fignum_exists(self.fig_dynamic.number):
                if not hamiltonian_found and self.generations_since_last_improvement < self.stagnation_limit:
                    self.fig_dynamic.suptitle(
                        f'ALGORITMO FINALIZADO (MAX GENS: {self.current_generation + 1})',
                        fontsize=20, color='orange'
                    )
                    plt.pause(3)  # Mostrar un poco más si no fue por estancamiento o éxito
                plt.ioff()
                plt.close(self.fig_dynamic)
            self.fig_dynamic = None
            self.axes_dynamic = None
        return self.best_cycle, self.best_fitness

def create_enhanced_graph(n=20, p_additional_edge=0.15, ensure_hamiltonian=True, seed=None):
    if seed is not None:
        random.seed(seed)  # Para gnp_random_graph y elecciones aleatorias

    if n == 0:
        return nx.Graph()
    if n == 1:
        G = nx.Graph()
        G.add_node(0)
        return G
    if ensure_hamiltonian:
        G = nx.cycle_graph(n)
        nodes = list(G.nodes())
        for i in range(n):
            for j in range(i + 2, n):  # Evitar aristas adyacentes del ciclo y la que lo cierra
                if not (i == 0 and j == n - 1) and random.random() < p_additional_edge:
                    G.add_edge(nodes[i], nodes[j])
    else:
        # seed en gnp_random_graph asegura reproducibilidad del grafo base aleatorio
        G = nx.gnp_random_graph(n, p_additional_edge, seed=seed)
        if n > 0 and not nx.is_connected(G):  # Intentar conectar si no lo está
            components = list(nx.connected_components(G))
            if len(components) > 1:
                for i_comp in range(len(components) - 1):
                    G.add_edge(
                        random.choice(list(components[i_comp])),
                        random.choice(list(components[i_comp + 1]))
                    )
    return G

def visualize_graph_and_solution(G, solution=None, pos=None, title="Grafo y Solución", ax=None):
    standalone_plot = ax is None
    if standalone_plot:
        fig, ax_new = plt.subplots(figsize=(14, 10))
        ax_new.set_facecolor('white')
        fig.patch.set_facecolor('white')
        ax = ax_new

    if pos is None:
        # Si no se pasa pos, generarlo (usar semilla si está disponible)
        seed_for_layout = 42
        k_val = 2 / np.sqrt(len(G.nodes())) if len(G.nodes()) > 0 else 2
        pos = nx.spring_layout(G, seed=seed_for_layout, k=k_val, iterations=80)

    base_edge_color = '#BBBBBB' if solution else '#666666'
    base_edge_width = 1.5 if solution else 1.8
    base_edge_alpha = 0.75 if solution else 0.9

    edge_collection_base = nx.draw_networkx_edges(
        G, pos,
        edge_color=base_edge_color,
        width=base_edge_width,
        alpha=base_edge_alpha,
        ax=ax
    )
    if edge_collection_base:
        for ec_item in edge_collection_base if isinstance(edge_collection_base, list) else [edge_collection_base]:
            ec_item.set_zorder(1)

    cycle_edges_list_for_legend = []
    if solution and len(solution) == len(G.nodes()):
        cycle_edges_list_for_legend = [
            (solution[i], solution[(i + 1) % len(solution)])
            for i in range(len(solution))
        ]
        valid_cycle_edges = [edge for edge in cycle_edges_list_for_legend if G.has_edge(*edge)]
        invalid_cycle_edges = [edge for edge in cycle_edges_list_for_legend if not G.has_edge(*edge)]

        if valid_cycle_edges:
            edge_collection_valid = nx.draw_networkx_edges(
                G, pos,
                edgelist=valid_cycle_edges,
                edge_color='#228B22',
                width=3.5,
                alpha=0.9,
                ax=ax
            )
            if edge_collection_valid:
                for ec_item in edge_collection_valid if isinstance(edge_collection_valid, list) else [edge_collection_valid]:
                    ec_item.set_zorder(2)
        if invalid_cycle_edges:
            for u, v in invalid_cycle_edges:
                if u in pos and v in pos:
                    ax.plot(
                        [pos[u][0], pos[v][0]],
                        [pos[u][1], pos[v][1]],
                        'r--',
                        linewidth=3,
                        alpha=0.8,
                        marker='x',
                        markersize=8,
                        markeredgecolor='red',
                        markerfacecolor='red',
                        zorder=2
                    )

    node_size = max(200, 800 - len(G.nodes()) * 10)
    node_colors_list = ['#87CEEB'] * len(G.nodes())
    if solution:
        cmap_colors = plt.cm.Set3.colors
        num_cmap_colors = len(cmap_colors)
        node_color_map = {
            node_in_sol: cmap_colors[i % num_cmap_colors]
            for i, node_in_sol in enumerate(solution)
        }
        node_colors_list = [node_color_map.get(node, '#E6E6FA') for node in G.nodes()]

    node_collection = nx.draw_networkx_nodes(
        G, pos,
        node_color=node_colors_list,
        node_size=node_size,
        edgecolors=['#333333'] * len(G.nodes()),
        linewidths=2,
        ax=ax
    )
    if node_collection:
        node_collection.set_zorder(3)

    labels_drawn = nx.draw_networkx_labels(G, pos, font_size=max(6, 12 - len(G.nodes()) // 6), font_weight='bold', ax=ax)
    if labels_drawn:
        for label_artist in labels_drawn.values():
            label_artist.set_zorder(4)
    ax.set_title(title, fontsize=18, fontweight='bold', pad=15)
    ax.axis('off')

    if solution:
        legend_elements = []
        if any(G.has_edge(*edge) for edge in cycle_edges_list_for_legend):
            legend_elements.append(
                plt.Line2D([0], [0], color='#228B22', lw=4, label='Aristas válidas del ciclo')
            )
        if any(not G.has_edge(*edge) for edge in cycle_edges_list_for_legend):
            legend_elements.append(
                plt.Line2D([0], [0], color='red', lw=3, ls='--', label='Aristas faltantes propuestas')
            )
        legend_elements.append(
            plt.Line2D([0], [0], color=base_edge_color, lw=base_edge_width, label='Otras aristas del grafo')
        )
        if legend_elements:
            ax.legend(handles=legend_elements, loc='best', frameon=True, fancybox=True, shadow=True, fontsize=10)

    if standalone_plot:
        plt.tight_layout()
        plt.show()
    return pos

def plot_evolution_statistics(solver, graph_n_nodes):
    if not solver.best_fitness_history:
        print("No hay historial de fitness.")
        return
    fig, axes = plt.subplots(2, 2, figsize=(16, 11))
    fig.patch.set_facecolor('white')
    fig.suptitle(
        f'Estadísticas del AG (Grafo de {graph_n_nodes} nodos, Seed: {solver.random_seed})',
        fontsize=18, fontweight='bold'
    )
    gens = range(len(solver.best_fitness_history))

    axes[0, 0].plot(gens, solver.best_fitness_history, 'g-', lw=2.5, label='Mejor Fitness')
    axes[0, 0].plot(gens, solver.avg_fitness_history, 'b--', lw=2, label='Fitness Promedio')
    axes[0, 0].set_xlabel('Generación', fontsize=12)
    axes[0, 0].set_ylabel('Fitness', fontsize=12)
    axes[0, 0].set_title('Evolución del Fitness', fontsize=14, fontweight='bold')
    axes[0, 0].legend(fontsize=11)
    axes[0, 0].grid(True, ls=':', alpha=0.5)

    axes[0, 1].plot(gens, solver.diversity_history, 'r-', lw=2.5)
    axes[0, 1].set_xlabel('Generación', fontsize=12)
    axes[0, 1].set_ylabel('Diversidad (Hamming prom.)', fontsize=12)
    axes[0, 1].set_title('Diversidad de la Población', fontsize=14, fontweight='bold')
    axes[0, 1].grid(True, ls=':', alpha=0.5)
    axes[0, 1].set_ylim(0, 1)

    if solver.generation_times:
        axes[1, 0].hist(
            solver.generation_times,
            bins=max(10, len(gens) // 10 if gens else 10),
            alpha=0.75,
            color='darkorange',
            edgecolor='black'
        )
        axes[1, 0].set_xlabel('Tiempo por Generación (s)', fontsize=12)
        axes[1, 0].set_ylabel('Frecuencia', fontsize=12)
        axes[1, 0].set_title('Distribución de Tiempos de Generación', fontsize=14, fontweight='bold')
        axes[1, 0].grid(True, ls=':', alpha=0.3)
    else:
        axes[1, 0].text(0.5, 0.5, "No hay datos de tiempo", ha='center', va='center', transform=axes[1, 0].transAxes)

    improvements_x, improvements_y, current_best = [], [], float('-inf')
    for i, fit_val in enumerate(solver.best_fitness_history):
        if fit_val > current_best:
            improvements_x.append(i)
            improvements_y.append(fit_val)
            current_best = fit_val
    if improvements_x:
        axes[1, 1].plot(gens, solver.best_fitness_history, 'g-', lw=1, alpha=0.3)  # Línea base
        axes[1, 1].scatter(improvements_x, improvements_y, color='purple', s=40, alpha=0.9, label='Mejoras encontradas', zorder=5)
        axes[1, 1].set_xlabel('Generación', fontsize=12)
        axes[1, 1].set_ylabel('Fitness de la Mejora', fontsize=12)
        axes[1, 1].set_title('Puntos de Mejora del Mejor Fitness', fontsize=14, fontweight='bold')
        axes[1, 1].legend(fontsize=11)
        axes[1, 1].grid(True, ls=':', alpha=0.5)
    else:
        axes[1, 1].text(0.5, 0.5, "No hubo mejoras (o solo al inicio)", ha='center', va='center', transform=axes[1, 1].transAxes)

    plt.tight_layout(rect=[0, 0.03, 1, 0.95])
    plt.show()

# ---------------------------------------------------------------------------
# ANÁLISIS DEL CÓDIGO Y POSIBLES MEJORAS FUTURAS (Actualizado para reflejar cambios)
# ---------------------------------------------------------------------------
"""
Análisis del Código (Versión con Mejoras Implementadas):

El código implementa un algoritmo genético para intentar encontrar un ciclo hamiltoniano.
Incorpora: gestión de semillas aleatorias, verificación de conexidad del grafo, criterio de
terminación por estancamiento, y una función de fitness que bonifica secuencias válidas.

Aspectos Positivos (Resaltando Novedades):
1.  **Robustez Mejorada:**
    *   **Gestión de Semillas:** Permite ejecuciones reproducibles.
    *   **Verificación de Conexidad:** Previene la ejecución en grafos donde un HC es imposible.
2.  **Eficiencia de Búsqueda:**
    *   **Terminación por Estancamiento:** Evita cómputo innecesario si el AG deja de progresar.
3.  **Función de Fitness Refinada:** La bonificación por secuencias de aristas válidas intenta
    guiar mejor la búsqueda hacia caminos más largos y coherentes.
4.  (Se mantienen los demás aspectos positivos de la versión anterior: estructura, visualizaciones,
    configurabilidad, operadores genéticos variados, etc.)

Posibles Áreas de Refinamiento y Expansión Futura (Algunas ya abordadas parcialmente):
1.  **Función de Fitness Avanzada:** Explorar penalizaciones por desconexiones tempranas en
    el ciclo propuesto o heurísticas más complejas de TSP adaptadas.
2.  **Operadores Genéticos Adicionales:**
    *   Cruce: PMX, CX, ERC.
    *   Mutación: Operadores de mejora local como 2-opt (más complejo).
    *   Mutación Adaptativa: Ajustar tasa de mutación dinámicamente.
3.  **Eficiencia y Escalabilidad:**
    *   Cálculo de Diversidad: La versión actual muestrea para poblaciones grandes, lo cual es una
        buena optimización. Se podría investigar más a fondo.
    *   Paralelización para evaluación de fitness.
4.  **Análisis de Resultados Más Profundo:** Análisis estadístico sobre múltiples ejecuciones
    con diferentes semillas.
5.  **Interfaz de Usuario o Configuración Externa:** Cargar parámetros desde archivos.
"""

if __name__ == "__main__":
    NUM_NODES = 15
    SEED = 42  # Semilla para reproducibilidad del grafo y del AG

    # Crear grafo usando la semilla
    G = create_enhanced_graph(n=NUM_NODES, p_additional_edge=0.20, ensure_hamiltonian=False, seed=SEED)
    # G = nx.petersen_graph() # Famoso por NO ser Hamiltoniano
    # NUM_NODES = G.number_of_nodes() # Actualizar si se usa grafo predefinido

    print(f"Grafo con {G.number_of_nodes()} nodos y {G.number_of_edges()} aristas. (Seed Grafo: {SEED})")
    if G.number_of_nodes() == 0:
        exit("Grafo vacío.")
    # La verificación de conexidad ahora está en el constructor del Solver

    POP_SIZE = 150
    ELITE_S = int(0.1 * POP_SIZE)
    MUT_RATE = 0.18  # Ligeramente ajustado
    CROSS_RATE = 0.88  # Ligeramente ajustado
    MAX_GENS = 400
    ANIMATE = True  # True para visualización dinámica
    STAGNATION_CYCLES = 75  # Generaciones sin mejora antes de parar

    # Visualizar grafo inicial
    initial_pos = visualize_graph_and_solution(
        G,
        title=f"Grafo Inicial ({G.number_of_nodes()} Nodos, Seed: {SEED})"
    )
    if ANIMATE:
        # Para evitar que la ventana de animación se cierre inmediatamente si hay un error antes del bucle de evolve
        try:
            plt.show(block=False)
            plt.pause(1)
        except Exception as e:
            print(f"Error al mostrar grafo inicial con animación: {e}")

    try:
        solver = GeneticHamiltonianSolver(
            G,
            population_size=POP_SIZE,
            elite_size=ELITE_S,
            mutation_rate=MUT_RATE,
            crossover_rate=CROSS_RATE,
            max_generations=MAX_GENS,
            animate=ANIMATE,
            stagnation_limit=STAGNATION_CYCLES,
            random_seed=SEED
        )

        print(f"\nIniciando Algoritmo Genético (Seed AG: {SEED})...\n")
        start_time = time.time()
        best_sol, best_fit = solver.evolve(verbose=True)
        total_time = time.time() - start_time

        if solver.best_cycle and solver.is_hamiltonian_cycle(solver.best_cycle):
            reason_for_termination = (
                f"Ciclo Hamiltoniano encontrado en generación {solver.current_generation}."
            )
        elif solver.generations_since_last_improvement >= solver.stagnation_limit:
            reason_for_termination = (
                f"Terminado por estancamiento tras {solver.current_generation + 1} generaciones."
            )
        else:
            reason_for_termination = (
                f"Terminado por alcanzar max_generations ({solver.current_generation + 1})."
            )

        print(f"\nTiempo total: {total_time:.2f} segundos. {reason_for_termination}")

        if best_sol:
            is_hc = solver.is_hamiltonian_cycle(best_sol)
            print(f"\nMejor solución (Fitness: {best_fit:.2f}):")
            print(f"   Camino: {' -> '.join(map(str, best_sol))} -> {best_sol[0]}")
            print(f"   ¿Hamiltoniano?: {'SÍ' if is_hc else 'NO'}")
            if not is_hc:
                valid_e = sum(
                    1 for i in range(len(best_sol))
                    if G.has_edge(best_sol[i], best_sol[(i + 1) % len(best_sol)])
                )
                print(f"   Aristas válidas en ciclo propuesto: {valid_e} de {len(best_sol)}")

            solution_title = (
                f"Mejor Solución (Fitness: {best_fit:.2f})"
                + (" - Ciclo Hamiltoniano!" if is_hc else "")
            )

            # Reutilizar la posición del grafo inicial para la visualización de la solución
            visualize_graph_and_solution(G, best_sol, pos=solver.pos, title=solution_title)
        else:
            print("\nNo se encontró ninguna solución válida.")

        if solver.best_fitness_history:
            plot_evolution_statistics(solver, G.number_of_nodes())

    except ValueError as e:  # Capturar error de grafo no conexo
        print(f"\nError de configuración: {e}")
    except Exception as e:
        print(f"\nOcurrió un error inesperado durante la ejecución: {e}")
        import traceback
        traceback.print_exc()

    # Asegurar que todas las ventanas se muestren al final si no hubo animación activa
    # o si la ventana de animación se cerró prematuramente.
    if not ANIMATE or (solver.fig_dynamic and not plt.fignum_exists(solver.fig_dynamic.number if solver.fig_dynamic else -1)):
        plt.show()  # Muestra todas las figuras pendientes

# Importar las funciones necesarias de IPython para mostrar HTML
from IPython.core.display import display, HTML

# Definir el contenido HTML, CSS y JavaScript como un string multilínea
html_content = """
<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>AG y el Problema del Viajante (TSP)</title>
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet">
  <style>
    /* Definición de variables CSS para temas */
    :root {
      --bg-color: #f9f9f9;
      --text-color: #333;
      --header-color: #2c3e50;
      --header-dark-color: #ecf0f1;
      --accent-color: #c0392b; /* Rojo para TSP, un color "clásico" de problemas difíciles */
      --accent-dark-color: #e74c3c; /* Rojo más claro para modo oscuro */
      --button-bg: #e74c3c; /* Rojo más claro para botones */
      --button-hover-bg: #c0392b; /* Rojo para hover */
      --button-dark-bg: #5499c7; /* Azul para modo oscuro */
      --button-dark-hover-bg: #2980b9; /* Azul oscuro para hover */
      --button-text-color: white;
      --theme-button-bg: #8e44ad;
      --theme-button-dark-bg: #f39c12;
      --content-panel-bg: #fdedec; /* Un rojo muy pálido */
      --content-panel-dark-bg: #4a2320; /* Un rojo oscuro para fondo de panel */
    }

    body {
      font-family: 'Roboto', Arial, sans-serif;
      line-height: 1.8;
      background-color: var(--bg-color);
      color: var(--text-color);
      transition: background-color 0.3s, color 0.3s;
      padding: 20px;
      margin: 0;
    }
    .container {
      max-width: 900px;
      margin: auto;
      padding: 20px;
      position: relative;
      background-color: var(--bg-color);
      border-radius: 8px;
      box-shadow: 0 2px 10px rgba(0,0,0,0.1);
    }
    body.dark-mode .container {
        box-shadow: 0 2px 10px rgba(0,0,0,0.3);
    }
    body.dark-mode {
      --bg-color: #2c3e50; /* Fondo general oscuro */
      --text-color: #ecf0f1;
      --header-color: var(--header-dark-color);
      --accent-color: var(--accent-dark-color);
      --button-bg: var(--button-dark-bg);
      --button-hover-bg: var(--button-dark-hover-bg);
      --content-panel-bg: var(--content-panel-dark-bg);
    }

    h1 { /* Título principal de la página */
      font-size: 2.2em;
      color: var(--header-color);
      text-align: center;
      margin-bottom: 10px;
    }
    h2 { /* Título de las secciones principales colapsables */
      font-size: 1.8em; /* Ligeramente más pequeño que h1 */
      color: var(--button-text-color); /* Para que coincida con el texto del botón */
      margin: 0; /* Quitar margen para que encaje bien en el botón */
      padding: 0;
      font-weight: 700; /* Mantenerlo en negrita */
      text-align: left; /* Para el texto del botón */
    }
     h3 { /* Para subtítulos dentro de los paneles de contenido */
      font-size: 1.5em;
      color: var(--accent-color);
      margin-top: 20px;
      margin-bottom: 10px;
      padding-bottom: 3px;
      border-bottom: 1px solid var(--accent-color);
      text-align: left;
    }


    .content-panel {
      display: none;
      margin-top: 0;
      padding: 20px;
      border-left: 4px solid var(--accent-color);
      background-color: var(--content-panel-bg);
      border-radius: 0 0 5px 5px;
    }
    .content-panel.is-visible {
      display: block;
    }

    .section-toggle-button {
      background-color: var(--button-bg);
      border: none;
      padding: 12px 18px;
      border-radius: 5px;
      cursor: pointer;
      margin-top: 15px;
      transition: background-color 0.3s, border-radius 0.2s;
      width: 100%;
      display: flex; /* Para alinear el h2 dentro */
      align-items: center;
    }
    .section-toggle-button:hover {
      background-color: var(--button-hover-bg);
    }
    .section-toggle-button.is-expanded {
        border-radius: 5px 5px 0 0;
    }

    .theme-toggle {
      background-color: var(--theme-button-bg);
      color: white;
      border: none;
      padding: 8px 12px;
      border-radius: 5px;
      cursor: pointer;
      position: absolute;
      top: 20px;
      right: 20px;
      font-size: 0.9em;
      transition: background-color 0.3s;
      z-index: 10;
    }
    body.dark-mode .theme-toggle {
       background-color: var(--theme-button-dark-bg);
    }

    button:focus, a:focus {
        outline: 2px solid var(--accent-color);
        outline-offset: 2px;
    }
    body.dark-mode button:focus, body.dark-mode a:focus {
         outline-color: var(--accent-dark-color);
    }
    .content-panel p, .content-panel ul {
        margin-bottom: 1.1em;
    }
    .content-panel p:last-child, .content-panel ul:last-child {
        margin-bottom: 0;
    }
    ul {
        padding-left: 30px;
    }
    li {
        margin-bottom: 0.6em;
    }
    strong {
        font-weight: 700;
    }
    .initial-intro-tsp {
      font-size: 1.1em;
      line-height: 1.7;
      margin-bottom: 20px;
      padding: 15px;
      background-color: var(--content-panel-bg);
      border-left: 4px solid var(--accent-color);
      border-radius: 4px;
    }
    .question-style { /* Para el título principal de la pregunta */
        font-size: 1.5em;
        color: var(--header-color);
        margin-bottom: 15px;
        text-align: center;
        font-weight: bold;
    }


  </style>
</head>
<body>
  <div class="container">
    <button id="theme-toggle-btn" class="theme-toggle" onclick="toggleTheme()" title="Cambiar tema de color">Modo Oscuro</button>

    <h1>Aplicabilidad de Algoritmos Genéticos al Problema del Viajante (TSP)</h1>

    <p class="question-style">¿Por qué se puede aplicar un Algoritmo Genético al Problema del Viajante (TSP)?</p>

    <div class="initial-intro-tsp">
      <p>El <strong>Problema del Viajante de Comercio (TSP)</strong> es uno de los problemas clásicos más estudiados en la teoría de la computación y optimización combinatoria. Consiste en encontrar el camino más corto que recorra un conjunto de ciudades exactamente una vez y regrese a la ciudad de origen. Es un problema <strong>NP-hard</strong>, es decir, <strong>no se conoce un algoritmo exacto que lo resuelva eficientemente para un gran número de ciudades</strong>.</p>
      <p>Dado el carácter combinatorial y la complejidad exponencial del TSP, los métodos exactos se vuelven ineficientes para instancias grandes. En este contexto, los <strong>algoritmos genéticos (AG)</strong> ofrecen una poderosa alternativa heurística para encontrar soluciones <strong>aproximadas</strong> de alta calidad.</p>
    </div>

    <!-- Sección: Justificación de la Aplicabilidad -->
    <button class="section-toggle-button" onclick="toggleSection('tsp_justificacion', this)" aria-expanded="false" aria-controls="tsp_justificacion">
      <h2>Justificación de la Aplicabilidad de AG al TSP</h2>
    </button>
    <div id="tsp_justificacion" class="content-panel">
      <h3>1. Estructura del problema adecuada para codificación genética</h3>
      <p>En el TSP, cada solución se representa naturalmente como una <strong>permutación</strong> de nodos (ciudades), lo cual se ajusta perfectamente al esquema de representación de un individuo en un AG.</p>
      <ul>
        <li><strong>Genotipo:</strong> una permutación de nodos.</li>
        <li><strong>Fenotipo:</strong> la ruta resultante que conecta las ciudades.</li>
        <li><strong>Fitness:</strong> distancia total del recorrido (a minimizar).</li>
      </ul>

      <h3>2. Los operadores genéticos pueden preservar características útiles</h3>
      <p>Operadores como:</p>
      <ul>
        <li>Crossover de orden (Order Crossover, OX)</li>
        <li>Crossover de ciclo (Cycle Crossover, CX)</li>
        <li>Mutación por inserción, intercambio o inversión</li>
      </ul>
      <p>…pueden diseñarse para <strong>preservar subrutas eficientes</strong>, mejorar gradualmente la calidad de las soluciones y <strong>evitar soluciones inválidas</strong> (como rutas con ciudades repetidas o faltantes).</p>

      <h3>3. El espacio de búsqueda es inmenso y no estructurado</h3>
      <p>Con <i>n</i> ciudades, el número de rutas posibles es (<i>n</i>-1)!/2, lo que hace <strong>inviable</strong> la búsqueda exhaustiva. Los AG, al ser técnicas de búsqueda estocástica guiadas por fitness, son capaces de <strong>explorar eficazmente grandes espacios de búsqueda</strong> sin requerir derivadas ni continuidad.</p>

      <h3>4. Robustez ante óptimos locales</h3>
      <p>Los AG no dependen de gradientes ni estructuras de convexidad. Al incorporar <strong>variación genética (mutación)</strong> y <strong>diversidad poblacional</strong>, tienen mayor capacidad de <strong>escapar de óptimos locales</strong> en comparación con métodos deterministas.</p>

      <h3>5. Adaptabilidad y flexibilidad</h3>
      <p>Los AG pueden adaptarse fácilmente a variantes del TSP:</p>
      <ul>
        <li>TSP asimétrico (distancias diferentes en cada dirección).</li>
        <li>TSP con ventanas de tiempo.</li>
        <li>Multi-TSP o TSP con restricciones de capacidad (como en el VRP).</li>
        <li>TSP con criterios múltiples (multiobjetivo: distancia, riesgo, costo).</li>
      </ul>
      <p>Esto hace que el AG sea <strong>una herramienta muy versátil para problemas reales de ruteo y logística</strong>.</p>
    </div>

    <!-- Sección: Resultados Esperables -->
    <button class="section-toggle-button" onclick="toggleSection('tsp_resultados', this)" aria-expanded="false" aria-controls="tsp_resultados">
      <h2>Resultados Esperables</h2>
    </button>
    <div id="tsp_resultados" class="content-panel">
      <p>Aunque un algoritmo genético <strong>no garantiza encontrar la solución óptima</strong>, es común obtener <strong>soluciones de alta calidad en tiempos razonables</strong>, especialmente si se:</p>
      <ul>
        <li>Ajustan bien los parámetros (mutación, población, generaciones).</li>
        <li>Se integran mejoras locales (como el algoritmo 2-opt).</li>
        <li>Se mantiene una buena diversidad genética.</li>
      </ul>
    </div>

    <!-- Sección: Conclusión -->
    <button class="section-toggle-button" onclick="toggleSection('tsp_conclusion', this)" aria-expanded="false" aria-controls="tsp_conclusion">
      <h2>Conclusión</h2>
    </button>
    <div id="tsp_conclusion" class="content-panel">
      <p>El <strong>algoritmo genético es aplicable y eficaz para resolver el TSP</strong> debido a:</p>
      <ul>
        <li>La compatibilidad entre la estructura del problema y el marco evolutivo.</li>
        <li>La capacidad de explorar grandes espacios de soluciones.</li>
        <li>La facilidad de adaptar operadores genéticos específicos al TSP.</li>
        <li>Su robustez y adaptabilidad a distintas variantes del problema.</li>
      </ul>
      <p>Por estas razones, el uso de algoritmos genéticos para el TSP es ampliamente respaldado tanto en la literatura científica como en aplicaciones industriales de optimización de rutas, logística y planificación de recorridos.</p>
    </div>


  </div> <!-- Fin de .container -->

  <script>
    // Función para cambiar entre modo claro y oscuro
    function toggleTheme() {
      document.body.classList.toggle("dark-mode");
      let themeButton = document.getElementById('theme-toggle-btn');
      let isDarkMode = document.body.classList.contains("dark-mode");
      localStorage.setItem("theme", isDarkMode ? "dark" : "light");
      if (themeButton) {
          themeButton.textContent = isDarkMode ? "Modo Claro" : "Modo Oscuro";
      }
    }

    // Función para mostrar/ocultar paneles de contenido
    function toggleSection(id, buttonElement) {
      let panel = document.getElementById(id);
      if (panel && buttonElement) {
          panel.classList.toggle('is-visible');
          let isVisible = panel.classList.contains('is-visible');
          buttonElement.setAttribute('aria-expanded', isVisible);
          buttonElement.classList.toggle('is-expanded', isVisible);
      }
    }

    // Función que se ejecuta cuando la página carga
    window.onload = function() {
      let themeButton = document.getElementById('theme-toggle-btn');
      const savedTheme = localStorage.getItem("theme");

      if (savedTheme === "dark") {
        document.body.classList.add("dark-mode");
        if (themeButton) {
            themeButton.textContent = "Modo Claro";
        }
      } else {
        document.body.classList.remove("dark-mode");
        if (themeButton) {
            themeButton.textContent = "Modo Oscuro";
        }
      }

       document.querySelectorAll('.content-panel').forEach(panel => {
         panel.classList.remove('is-visible');
       });
       document.querySelectorAll('.section-toggle-button').forEach(button => {
          button.setAttribute('aria-expanded', 'false');
          button.classList.remove('is-expanded');
       });
    }
  </script>
</body>
</html>
"""

# Mostrar el HTML en la salida de la celda
display(HTML(html_content))

import networkx as nx
import matplotlib.pyplot as plt
import numpy as np
import random
import seaborn as sns
import time
import math
from IPython.display import display, clear_output

# --- Parámetros Globales para Mejoras (Ejemplos) ---
ADAPTIVE_MUT_LOW_DIVERSITY_THRESHOLD = 0.15
MIN_MUTATION_RATE = 0.02
MAX_MUTATION_RATE = 0.60
MUTATION_ADAPT_FACTOR_INCREASE = 1.1
MUTATION_ADAPT_FACTOR_DECREASE = 0.98

STAGNATION_FOR_RESET = 30
RESET_FRACTION = 0.3

APPLY_2OPT_EVERY_N_GENS_IN_EVOLVE = 25
PROB_APPLY_2OPT_TO_ELITE_IN_EVOLVE = 0.3

plt.style.use('default')
plt.rcParams['figure.facecolor'] = 'white'
plt.rcParams['axes.facecolor'] = 'white'
plt.rcParams['savefig.facecolor'] = 'white'
plt.rcParams['font.sans-serif'] = ['DejaVu Sans', 'Verdana', 'Geneva', 'sans-serif']
sns.set_palette("husl")


class GeneticTSPSolver:
    def __init__(self, graph, population_size=100, elite_size=20,
                 initial_mutation_rate=0.15,
                 crossover_rate=0.8, max_generations=500, animate=False,
                 stagnation_limit=50, random_seed=None,
                 use_adaptive_mutation=True,
                 use_population_reset=True,
                 use_simple_local_search_during_evolution=True, # Nombre corregido
                 apply_full_2opt_at_end=True): # Nombre corregido

        self.random_seed = random_seed
        if self.random_seed is not None:
            random.seed(self.random_seed)
            np.random.seed(self.random_seed)

        self.graph = graph
        self.nodes = list(graph.nodes())

        if not self.nodes: raise ValueError("El grafo no puede estar vacío.")
        self.n_nodes = len(self.nodes)
        if self.n_nodes < 2: raise ValueError("TSP requiere al menos 2 nodos.")

        self.pos = nx.get_node_attributes(graph, 'pos')
        if not self.pos:
            k_val = 2 / np.sqrt(self.n_nodes) if self.n_nodes > 0 else 2
            self.pos = nx.spring_layout(graph, seed=self.random_seed if self.random_seed is not None else 42, k=k_val, iterations=100)
            for node_id, p_val in self.pos.items():
                if node_id in self.graph.nodes: self.graph.nodes[node_id]['pos'] = p_val

        if not self._is_graph_complete_and_weighted():
            self._complete_graph_with_weights()

        self.population_size = population_size
        self.elite_size = elite_size
        self.mutation_rate = initial_mutation_rate
        self.initial_mutation_rate = initial_mutation_rate
        self.crossover_rate = crossover_rate
        self.max_generations = max_generations
        self.animate = animate
        self.stagnation_limit = stagnation_limit

        self.use_adaptive_mutation = use_adaptive_mutation
        self.use_population_reset = use_population_reset
        self.use_simple_local_search_during_evolution = use_simple_local_search_during_evolution
        self.apply_full_2opt_at_end = apply_full_2opt_at_end

        self.best_fitness_history = []
        self.avg_fitness_history = []
        self.diversity_history = []
        self.mutation_rate_history = []
        self.generation_times = []

        self.best_tour = None
        self.best_distance = float('inf')
        self.current_generation = 0
        self.generations_since_last_improvement = 0
        self.generations_since_last_reset = 0

        self.fig_dynamic = None
        self.axes_dynamic = None

    def _is_graph_complete_and_weighted(self):
        if self.n_nodes < 2: return True
        expected_edges = self.n_nodes * (self.n_nodes - 1) / 2
        if self.graph.number_of_edges() < expected_edges: return False
        for u, v, data in self.graph.edges(data=True):
            if 'weight' not in data: return False
        return True

    def _complete_graph_with_weights(self):
        nodes_list = list(self.graph.nodes())
        for i in range(len(nodes_list)):
            for j in range(i + 1, len(nodes_list)):
                u, v = nodes_list[i], nodes_list[j]
                if not self.graph.has_edge(u, v) or 'weight' not in self.graph[u][v]:
                    if u in self.pos and v in self.pos:
                        x1, y1 = self.pos[u]; x2, y2 = self.pos[v]
                        distance = math.sqrt((x1 - x2)**2 + (y1 - y2)**2)
                    else: distance = 1.0
                    if self.graph.has_edge(u,v): self.graph[u][v]['weight'] = distance
                    else: self.graph.add_edge(u, v, weight=distance)

    def create_individual(self):
        individual = self.nodes.copy()
        random.shuffle(individual)
        return individual

    def create_population(self):
        population = []
        if self.n_nodes == 0: return []
        num_random = self.population_size // 2
        num_greedy = max(1, self.population_size // 4) if self.population_size >= 4 else 0
        num_nearest_neighbor = self.population_size - num_random - num_greedy
        for _ in range(num_random): population.append(self.create_individual())
        for i in range(min(num_greedy, self.n_nodes)):
            if len(population) < self.population_size:
                population.append(self.create_nearest_neighbor_tour(start_node=self.nodes[i % self.n_nodes]))
        for _ in range(num_nearest_neighbor):
            if len(population) < self.population_size:
                population.append(self.create_nearest_neighbor_tour(randomize_start=True))
        while len(population) < self.population_size: population.append(self.create_individual())
        return population

    def create_nearest_neighbor_tour(self, start_node=None, randomize_start=False):
        if not self.nodes: return []
        unvisited = set(self.nodes)
        if randomize_start: current = random.choice(self.nodes)
        elif start_node is not None: current = start_node
        else: current = self.nodes[0]
        tour = [current]
        unvisited.remove(current)
        while unvisited:
            nearest = min(unvisited, key=lambda node: self.graph[current][node]['weight'])
            tour.append(nearest); unvisited.remove(nearest); current = nearest
        return tour

    def fitness(self, individual):
        if not self.is_valid_tour(individual): return float('-inf')
        total_distance = 0
        for i in range(self.n_nodes):
            total_distance += self.graph[individual[i]][individual[(i + 1) % self.n_nodes]]['weight']
        return -total_distance

    def get_tour_distance(self, individual):
        if not individual: return float('inf')
        return -self.fitness(individual)

    def is_valid_tour(self, individual):
        return (isinstance(individual, list) and len(individual) == self.n_nodes and
                len(set(individual)) == self.n_nodes and all(node in self.nodes for node in individual))

    def selection(self, population, fitnesses):
        selected, pop_size = [], len(population)
        if pop_size == 0: return []
        for _ in range(pop_size):
            actual_tournament_size = min(5, pop_size)
            if actual_tournament_size == 0: continue
            tournament_indices = random.sample(range(pop_size), actual_tournament_size)
            winner_idx = max(tournament_indices, key=lambda i: fitnesses[i])
            selected.append(population[winner_idx])
        return selected

    def crossover(self, parent1, parent2):
        if random.random() > self.crossover_rate or len(parent1) < 3:
            return parent1.copy(), parent2.copy()
        size = len(parent1)
        def order_crossover_op(p1, p2):
            child = [None] * size; start, end = sorted(random.sample(range(size), 2))
            child[start:end+1] = p1[start:end+1]
            child_set = set(child[start:end+1])
            current_child_idx, current_parent2_idx, filled_count = (end + 1) % size, (end + 1) % size, len(child_set)
            while filled_count < size:
                candidate_node = p2[current_parent2_idx]
                if candidate_node not in child_set:
                    child[current_child_idx] = candidate_node; child_set.add(candidate_node)
                    current_child_idx = (current_child_idx + 1) % size; filled_count +=1
                current_parent2_idx = (current_parent2_idx + 1) % size
            return child
        return order_crossover_op(parent1, parent2), order_crossover_op(parent2, parent1)

    def mutate(self, individual):
        if random.random() < self.mutation_rate and len(individual) >= 2:
            mutation_type = random.choice(['swap', 'reverse', 'insert', '2opt_mutate'])
            if mutation_type == 'swap':
                idx1, idx2 = random.sample(range(len(individual)), 2)
                individual[idx1], individual[idx2] = individual[idx2], individual[idx1]
            elif mutation_type == 'reverse' and len(individual) > 2:
                start, end = sorted(random.sample(range(len(individual)), 2))
                if end > start: individual[start:end+1] = individual[start:end+1][::-1]
            elif mutation_type == 'insert' and len(individual) > 1:
                from_idx, to_idx = random.randrange(len(individual)), random.randrange(len(individual))
                if from_idx != to_idx: individual.insert(to_idx, individual.pop(from_idx))
            elif mutation_type == '2opt_mutate' and len(individual) > 3:
                i, j = sorted(random.sample(range(len(individual)), 2))
                if j - i > 1: individual[i:j+1] = individual[i:j+1][::-1]
        return individual

    def calculate_diversity(self, population):
        if not population or len(population) < 2 or not population[0]: return 0.0
        num_comparisons, total_distance, ind_len = 0, 0, len(population[0])
        if ind_len == 0: return 0.0
        sample_size = min(len(population), 50)
        indices_to_compare = random.sample(range(len(population)), sample_size)
        for i in range(len(indices_to_compare)):
            for j in range(i + 1, len(indices_to_compare)):
                idx1, idx2 = indices_to_compare[i], indices_to_compare[j]
                if not self.is_valid_tour(population[idx1]) or not self.is_valid_tour(population[idx2]) or \
                   len(population[idx1]) != ind_len or len(population[idx2]) != ind_len: continue
                dist = sum(1 for k in range(ind_len) if population[idx1][k] != population[idx2][k])
                total_distance += dist / ind_len; num_comparisons += 1
        return total_distance / num_comparisons if num_comparisons > 0 else 0.0

    def simple_2opt_local_search(self, tour):
        current_tour = tour.copy()
        current_distance = self.get_tour_distance(current_tour)
        for _ in range(self.n_nodes):
            i, j = sorted(random.sample(range(self.n_nodes), 2))
            if j - i < 2 : continue
            segment = current_tour[i+1 : j+1]
            new_tour = current_tour[:i+1] + segment[::-1] + current_tour[j+1:]
            new_distance = self.get_tour_distance(new_tour)
            if new_distance < current_distance:
                current_tour = new_tour; current_distance = new_distance
        return current_tour

    def full_2opt_local_search(self, initial_tour):
        best_tour = initial_tour.copy()
        current_best_distance = self.get_tour_distance(best_tour)
        improved = True
        while improved:
            improved = False
            for i in range(self.n_nodes - 1):
                for j in range(i + 2, self.n_nodes):
                    segment_to_reverse = best_tour[i+1 : j+1]
                    new_candidate_tour = best_tour[:i+1] + segment_to_reverse[::-1] + best_tour[j+1:]
                    new_candidate_distance = self.get_tour_distance(new_candidate_tour)
                    if new_candidate_distance < current_best_distance:
                        best_tour = new_candidate_tour[:]
                        current_best_distance = new_candidate_distance
                        improved = True
                        break
                if improved:
                    break
        return best_tour

    def setup_dynamic_visualization(self):
        if not self.animate: return
        if self.fig_dynamic is not None and plt.fignum_exists(self.fig_dynamic.number):
            plt.close(self.fig_dynamic)
        self.fig_dynamic, self.axes_dynamic = plt.subplots(2, 3, figsize=(22, 13))
        self.fig_dynamic.patch.set_facecolor('white')
        titles = ['Mapa Ciudades', 'Mejor Tour', 'Evolución Dist.',
                  'Top 5 Tours', 'Diversidad Pob.', 'Estadísticas']
        for i, ax in enumerate(self.axes_dynamic.flat):
            ax.set_title(titles[i], fontsize=14, fontweight='bold'); ax.set_facecolor('#f0f0f0')
        plt.tight_layout(rect=[0, 0, 1, 0.96])

    def update_dynamic_visualization(self, population, fitnesses):
        if not self.animate or self.axes_dynamic is None or self.fig_dynamic is None: return
        clear_output(wait=True)
        main_title_prefix = "TSP Evolution"
        main_title = f'{main_title_prefix} (Gen {self.current_generation}) - Mejor Dist: {self.best_distance:.2f}'
        if self.generations_since_last_improvement >= self.stagnation_limit:
             main_title = f'ESTANCAMIENTO (Gen {self.current_generation}) - Mejor Dist: {self.best_distance:.2f}'
        self.fig_dynamic.suptitle(main_title, fontsize=16, fontweight='bold')
        for ax_idx, ax in enumerate(self.axes_dynamic.flat):
            ax.clear()
            titles = ['Mapa Ciudades', 'Mejor Tour', 'Evolución Dist.', 'Top 5 Tours', 'Diversidad Pob.', 'Estadísticas']
            if ax_idx < len(titles):
                ax.set_title(titles[ax_idx], fontsize=14, fontweight='bold'); ax.set_facecolor('#f0f0f0')
        self._draw_cities_map(self.axes_dynamic[0, 0])
        if self.best_tour: self._draw_tour_on_axis(self.axes_dynamic[0, 1], self.best_tour, f'Gen {self.current_generation} - Dist: {self.get_tour_distance(self.best_tour):.2f}')
        else: self.axes_dynamic[0, 1].text(0.5, 0.5, 'Calculando...', ha='center', va='center', transform=self.axes_dynamic[0, 1].transAxes)
        if len(self.best_fitness_history) > 1:
            ax_dist = self.axes_dynamic[0, 2]; gens = range(len(self.best_fitness_history))
            ax_dist.plot(gens, [-f for f in self.best_fitness_history], 'g-', lw=2.5, label='Mejor Dist')
            ax_dist.plot(gens, [-f for f in self.avg_fitness_history], 'b--', lw=2, label='Dist Prom')
            ax_dist.set_xlabel('Generación'); ax_dist.set_ylabel('Distancia'); ax_dist.legend(); ax_dist.grid(True, ls=':', alpha=0.7)
        if fitnesses and population:
            ax_top = self.axes_dynamic[1, 0]; sorted_indices = np.argsort(fitnesses)[::-1]; top_n = min(5, len(population))
            top_distances = [-fitnesses[i] for i in sorted_indices[:top_n]]
            bars = ax_top.bar(range(top_n), top_distances, color=sns.color_palette("viridis_r", n_colors=top_n))
            ax_top.set_xticks(range(top_n)); ax_top.set_xticklabels([f'#{i+1}' for i in range(top_n)])
            ax_top.set_xlabel('Ranking'); ax_top.set_ylabel('Distancia'); ax_top.grid(axis='y', ls=':', alpha=0.7)
            for bar_idx, bar in enumerate(bars): ax_top.text(bar.get_x() + bar.get_width()/2., bar.get_height() + 0.01 * max(top_distances, default=1), f'{top_distances[bar_idx]:.1f}', ha='center', va='bottom', fontsize=8, fontweight='bold')
        if len(self.diversity_history) > 1:
            ax_div = self.axes_dynamic[1, 1]
            ax_div.plot(range(len(self.diversity_history)), self.diversity_history, 'r-', lw=2.5, label='Diversidad')
            ax_div.set_xlabel('Generación'); ax_div.set_ylabel('Diversidad'); ax_div.grid(True, ls=':', alpha=0.7); ax_div.set_ylim(0, 1)
        ax_stats = self.axes_dynamic[1, 2]; ax_stats.axis('off')
        if fitnesses and self.best_tour:
            best_dist_val = self.get_tour_distance(self.best_tour); valid_fitnesses = [f for f in fitnesses if f != float('-inf')]; avg_dist_val = -np.mean(valid_fitnesses) if valid_fitnesses else float('inf')
            time_gen_str = f"T/Gen: {self.generation_times[-1]:.3f}s" if self.generation_times else "N/A"; stag_str = f"Estanc: {self.generations_since_last_improvement}/{self.stagnation_limit}"
            current_diversity_val = self.diversity_history[-1] if self.diversity_history else "N/A"
            div_display_str = f"{current_diversity_val:.3f}" if isinstance(current_diversity_val, float) else current_diversity_val
            mut_rate_str = f"MutR: {self.mutation_rate:.3f}" if self.use_adaptive_mutation else ""
            stats_text = (f"Gen: {self.current_generation}/{self.max_generations} ({stag_str})\nPob: {len(population)}\nMejor D: {best_dist_val:.2f}\nProm D: {avg_dist_val:.2f}\nDiv: {div_display_str} {mut_rate_str}\n{time_gen_str}")
        else: stats_text = "Calculando..."
        ax_stats.text(0.05, 0.95, stats_text, transform=ax_stats.transAxes, fontsize=9, va='top', fontfamily='monospace', bbox=dict(boxstyle="round,pad=0.4", fc="#e0f2f7", alpha=0.9))
        plt.tight_layout(rect=[0, 0, 1, 0.96]); display(self.fig_dynamic)

    def _draw_cities_map(self, ax, alpha=1.0):
        if not self.graph.nodes() or not self.pos: ax.text(0.5, 0.5, "Error: Grafo o pos vacías", color='red', ha='center', va='center', transform=ax.transAxes); ax.axis('off'); return
        valid_pos_for_graph = {k: v for k, v in self.pos.items() if k in self.graph}; nodes_to_draw = list(self.graph.nodes())
        if not valid_pos_for_graph or not nodes_to_draw: ax.axis('off'); return
        if self.n_nodes <= 30: nx.draw_networkx_edges(self.graph, valid_pos_for_graph, edge_color='#DDDDDD', width=0.5, alpha=alpha*0.3, ax=ax)
        base_node_color_val = sns.color_palette("Blues", n_colors=max(10, self.n_nodes))[6]
        nx.draw_networkx_nodes(self.graph, valid_pos_for_graph, nodelist=nodes_to_draw, node_color=base_node_color_val, node_size=300, edgecolors='#333333', linewidths=1.5, alpha=alpha, ax=ax)
        nx.draw_networkx_labels(self.graph, valid_pos_for_graph, font_size=9, font_weight='bold', ax=ax); ax.axis('off')

    def _draw_tour_on_axis(self, ax, tour, title):
        self._draw_cities_map(ax, alpha=0.2)
        if tour and self.is_valid_tour(tour):
            valid_pos_for_graph = {k: v for k, v in self.pos.items() if k in self.graph}; missing_pos_in_tour = [node_id for node_id in tour if node_id not in valid_pos_for_graph]
            if missing_pos_in_tour: ax.set_title(f"{title} (Error: pos faltante)", fontsize=10, color='red'); ax.axis('off'); return
            tour_edges = [(tour[i], tour[(i + 1) % len(tour)]) for i in range(len(tour))]; tour_node_colors_list = sns.color_palette("husl", n_colors=len(tour))
            nx.draw_networkx_edges(self.graph, valid_pos_for_graph, edgelist=tour_edges, edge_color='#FF4500', width=2.5, alpha=0.9, ax=ax)
            nx.draw_networkx_nodes(self.graph, valid_pos_for_graph, nodelist=tour, node_color=tour_node_colors_list, node_size=350, edgecolors='black', linewidths=1.5, ax=ax)
            for i, city_node in enumerate(tour):
                if city_node in valid_pos_for_graph: x, y = valid_pos_for_graph[city_node]; ax.text(x, y, str(i+1), ha='center', va='center', fontsize=8, fontweight='bold', color='white', bbox=dict(boxstyle="circle,pad=0.1", fc=tour_node_colors_list[i], ec="none", alpha=0.8))
        ax.set_title(title, fontsize=12, fontweight='bold'); ax.axis('off')

    def evolve(self, verbose=True):
        if self.n_nodes < 2:
            if verbose: print(f"Nodos insuficientes ({self.n_nodes}).")
            if self.n_nodes == 1: return self.nodes.copy(), 0
            return None, float('inf')

        if self.animate: self.setup_dynamic_visualization()

        self.mutation_rate = self.initial_mutation_rate
        population = self.create_population()
        if not population:
            if verbose: print("No se pudo crear población.")
            return None, float('inf')

        fitnesses = [self.fitness(ind) for ind in population]
        initial_max_fit_idx = np.argmax(fitnesses)
        self.best_distance = self.get_tour_distance(population[initial_max_fit_idx])
        self.best_tour = population[initial_max_fit_idx].copy()

        self.best_fitness_history.append(fitnesses[initial_max_fit_idx])
        self.avg_fitness_history.append(np.mean([f for f in fitnesses if f != float('-inf')]))
        self.diversity_history.append(self.calculate_diversity(population))
        if self.use_adaptive_mutation: self.mutation_rate_history.append(self.mutation_rate)
        if verbose: print(f"Población inicial. Mejor dist: {self.best_distance:.2f}. MutRate: {self.mutation_rate:.3f}")

        if self.animate: self.update_dynamic_visualization(population, fitnesses); time.sleep(0.1)

        for generation in range(self.max_generations):
            self.current_generation = generation; start_time_gen = time.time()
            self.generations_since_last_reset += 1

            parents_selected = self.selection(population, fitnesses)
            elite_indices = np.argsort(fitnesses)[-self.elite_size:]
            new_population = [population[i].copy() for i in elite_indices]

            if self.use_simple_local_search_during_evolution and \
               (generation % APPLY_2OPT_EVERY_N_GENS_IN_EVOLVE == 0 or \
                (self.generations_since_last_improvement > self.stagnation_limit // 2 and random.random() < PROB_APPLY_2OPT_TO_ELITE_IN_EVOLVE)):
                if verbose and generation > 0: print(f"  LS: Aplicando 2-opt simple a élite en gen {generation}")
                for i_elite in range(len(new_population)):
                    new_population[i_elite] = self.simple_2opt_local_search(new_population[i_elite])

            children_needed = self.population_size - len(new_population)
            children_created, idx_pair_attempts = 0,0
            max_idx_pair_attempts = len(parents_selected) * 2 if parents_selected else 0
            while children_created < children_needed and idx_pair_attempts < max_idx_pair_attempts :
                if len(parents_selected) >= 2: p1, p2 = random.sample(parents_selected, 2)
                elif len(parents_selected) == 1: p1 = p2 = parents_selected[0]
                else: new_population.append(self.create_individual()); children_created += 1; continue
                c1, c2 = self.crossover(p1, p2)
                new_population.append(self.mutate(c1.copy())); children_created += 1
                if children_created < children_needed: new_population.append(self.mutate(c2.copy())); children_created += 1
                idx_pair_attempts +=1
            while len(new_population) < self.population_size: new_population.append(self.create_individual())
            population = new_population[:self.population_size]
            fitnesses = [self.fitness(ind) for ind in population]

            current_gen_max_fit_idx = np.argmax(fitnesses)
            current_gen_best_distance = self.get_tour_distance(population[current_gen_max_fit_idx])
            if current_gen_best_distance < self.best_distance:
                self.best_distance = current_gen_best_distance; self.best_tour = population[current_gen_max_fit_idx].copy()
                self.generations_since_last_improvement = 0
                if verbose and generation > 0: print(f"✨ Nueva mejor dist gen {generation}: {self.best_distance:.2f}")
            else: self.generations_since_last_improvement += 1

            current_diversity = self.calculate_diversity(population)
            self.diversity_history.append(current_diversity)

            if self.use_adaptive_mutation:
                if current_diversity < ADAPTIVE_MUT_LOW_DIVERSITY_THRESHOLD and self.mutation_rate < MAX_MUTATION_RATE:
                    self.mutation_rate = min(MAX_MUTATION_RATE, self.mutation_rate * MUTATION_ADAPT_FACTOR_INCREASE)
                    if verbose and generation > 0: print(f"  MUT_ADAPT: Div baja ({current_diversity:.3f}), ↑ MutRate a {self.mutation_rate:.3f}")
                elif self.mutation_rate > self.initial_mutation_rate and self.generations_since_last_improvement < 10 :
                    self.mutation_rate = max(self.initial_mutation_rate, self.mutation_rate * MUTATION_ADAPT_FACTOR_DECREASE)
                self.mutation_rate_history.append(self.mutation_rate)

            valid_fitnesses_for_avg = [f for f in fitnesses if f != float('-inf')]; avg_fitness_val = np.mean(valid_fitnesses_for_avg) if valid_fitnesses_for_avg else float('-inf')
            self.best_fitness_history.append(max(fitnesses) if valid_fitnesses_for_avg else float('-inf')); self.avg_fitness_history.append(avg_fitness_val)
            self.generation_times.append(time.time() - start_time_gen)

            if self.use_population_reset and self.generations_since_last_improvement > STAGNATION_FOR_RESET and self.generations_since_last_reset > STAGNATION_FOR_RESET :
                if verbose: print(f"  RESET: Reseteo parcial de población en gen {generation}.")
                num_to_reset = int(self.population_size * RESET_FRACTION); current_elite_indices = np.argsort(fitnesses)[-self.elite_size:]
                preserved_population = [population[i].copy() for i in current_elite_indices]
                for _ in range(num_to_reset):
                    if len(preserved_population) < self.population_size: preserved_population.append(self.create_individual())
                remaining_indices_sorted = [i for i in np.argsort(fitnesses)[::-1] if i not in current_elite_indices]; fill_count = 0
                while len(preserved_population) < self.population_size and fill_count < len(remaining_indices_sorted): preserved_population.append(population[remaining_indices_sorted[fill_count]].copy()); fill_count +=1
                while len(preserved_population) < self.population_size: preserved_population.append(self.create_individual())
                population = preserved_population[:self.population_size]; fitnesses = [self.fitness(ind) for ind in population]
                self.generations_since_last_reset = 0
                self.diversity_history[-1] = self.calculate_diversity(population)
                if self.use_adaptive_mutation: self.mutation_rate = self.initial_mutation_rate; self.mutation_rate_history[-1] = self.mutation_rate

            if self.animate and (generation % 5 == 0 or generation == self.max_generations - 1 or self.generations_since_last_improvement >= self.stagnation_limit-1):
                self.update_dynamic_visualization(population, fitnesses)
            if self.generations_since_last_improvement >= self.stagnation_limit:
                if verbose: print(f"Estancamiento gen {generation}. Sin mejora {self.stagnation_limit} gens.")
                if self.animate and self.fig_dynamic: self.fig_dynamic.suptitle(f'ESTANCAMIENTO (Gen {generation}) - Mejor Dist: {self.best_distance:.2f}', fontsize=16, color='red', fontweight='bold'); display(self.fig_dynamic)
                break
            if verbose and (generation % 25 == 0 or generation == self.max_generations - 1):
                 current_diversity_val = self.diversity_history[-1] if self.diversity_history else "N/A"; div_display_str = f"{current_diversity_val:.3f}" if isinstance(current_diversity_val, float) else current_diversity_val
                 mut_rate_str = f"MutR: {self.mutation_rate:.3f}" if self.use_adaptive_mutation else ""
                 print(f"Gen {generation:4d}/{self.max_generations} (Estanc: {self.generations_since_last_improvement}) | Mejor D: {self.best_distance:7.2f} | Prom D: {-avg_fitness_val:7.2f} | Div: {div_display_str} {mut_rate_str} | T: {self.generation_times[-1]:.3f}s")

        if verbose: print(f"🏆 Mejor tour ANTES de 2-opt final: {self.best_tour}\n📏 Distancia: {self.best_distance:.2f}")
        if self.apply_full_2opt_at_end and self.best_tour is not None:
            if verbose: print("  LS_FINAL: Aplicando 2-opt completo al mejor tour final...")
            final_improved_tour = self.full_2opt_local_search(self.best_tour)
            final_improved_distance = self.get_tour_distance(final_improved_tour)
            if final_improved_distance < self.best_distance:
                if verbose: print(f"✨ 2-opt final mejoró la distancia de {self.best_distance:.2f} a {final_improved_distance:.2f}")
                self.best_tour = final_improved_tour; self.best_distance = final_improved_distance
            elif verbose: print(f"  LS_FINAL: 2-opt final no encontró más mejoras. Distancia se mantiene: {self.best_distance:.2f}")

        if verbose and self.generations_since_last_improvement < self.stagnation_limit:
            print(f"Max generaciones ({self.max_generations}) alcanzado.")
            if self.animate and self.fig_dynamic: self.fig_dynamic.suptitle(f'FINALIZADO (Max Gens: {self.max_generations}) - Mejor Dist: {self.best_distance:.2f}', fontsize=16, color='green', fontweight='bold'); display(self.fig_dynamic)
        if verbose: print(f"🏆 Mejor tour DESPUÉS de 2-opt final: {self.best_tour}\n📏 Distancia: {self.best_distance:.2f}")
        return self.best_tour, self.best_distance

def create_complete_weighted_graph(n_nodes, coord_bounds=(0, 100), seed=None, distance_type='euclidean'):
    if seed is not None: random.seed(seed); np.random.seed(seed)
    G = nx.Graph(); positions = {}
    for i in range(n_nodes):
        x, y = random.uniform(*coord_bounds), random.uniform(*coord_bounds)
        positions[i] = (x, y); G.add_node(i, pos=(x, y))
    node_list = list(G.nodes())
    for i in range(n_nodes):
        for j in range(i + 1, n_nodes):
            u, v = node_list[i], node_list[j]; x1, y1 = positions[u]; x2, y2 = positions[v]
            if distance_type == 'euclidean': dist = math.sqrt((x1 - x2)**2 + (y1 - y2)**2)
            elif distance_type == 'manhattan': dist = abs(x1 - x2) + abs(y1 - y2)
            elif distance_type == 'random': dist = random.uniform(1, coord_bounds[1])
            else: dist = math.sqrt((x1 - x2)**2 + (y1 - y2)**2)
            G.add_edge(u, v, weight=dist)
    return G

def run_single_experiment(num_cities, seed_val, animate_run, params_ga):
    print(f"\n--- Ejecutando experimento con semilla {seed_val} ---")
    graph = create_complete_weighted_graph(num_cities, coord_bounds=(0, 100), seed=42)

    solver = GeneticTSPSolver(graph,
                              population_size=params_ga.get('pop_size', 80),
                              elite_size=params_ga.get('elite_size', 8),
                              initial_mutation_rate=params_ga.get('mut_rate', 0.20),
                              crossover_rate=params_ga.get('cross_rate', 0.85),
                              max_generations=params_ga.get('max_gens', 100),
                              animate=animate_run,
                              stagnation_limit=params_ga.get('stagn_limit', 30),
                              random_seed=seed_val,
                              use_adaptive_mutation=params_ga.get('use_adaptive_mut', True),
                              use_population_reset=params_ga.get('use_pop_reset', True),
                              use_simple_local_search_during_evolution=params_ga.get('use_simple_local_search', True), # CORREGIDO
                              apply_full_2opt_at_end=params_ga.get('apply_full_2opt_final', True) # CORREGIDO
                              )
    print(f"Parámetros AG: Pop={solver.population_size}, Elite={solver.elite_size}, MutIni={solver.initial_mutation_rate}, "
          f"AdaptMut={solver.use_adaptive_mutation}, PopReset={solver.use_population_reset}, SimpleLS={solver.use_simple_local_search_during_evolution}, FullLS_End={solver.apply_full_2opt_at_end}")

    start_time = time.time()
    best_tour, best_distance = solver.evolve(verbose=True)
    exec_time = time.time() - start_time

    print(f"--- Fin experimento semilla {seed_val}: Dist={best_distance:.2f}, Tiempo={exec_time:.2f}s ---")

    if best_tour and animate_run == False:
        fig_final, ax_final = plt.subplots(figsize=(10, 8))
        fig_final.suptitle(f'Mejor Tour TSP ({num_cities} ciudades) - Semilla {seed_val}', fontsize=16, fontweight='bold')
        solver._draw_tour_on_axis(ax_final, best_tour, f'Dist: {best_distance:.2f} - T: {exec_time:.1f}s')
        plt.tight_layout(rect=[0, 0, 1, 0.95]); plt.show()

    return best_distance, exec_time

# --- Configuración de la Ejecución ---
NUM_CITIES_MAIN = 15
RANDOM_SEED_MAIN = 42

ga_parameters = {
    'pop_size': 80,
    'elite_size': 10,
    'mut_rate': 0.10,
    'cross_rate': 0.90,
    'max_gens': 150,
    'stagn_limit': 40,
    'use_adaptive_mut': True,
    'use_pop_reset': True,
    'use_simple_local_search': True,
    'apply_full_2opt_final': True,
    'animate_first_run': True
}

DO_SINGLE_RUN_WITH_ANIMATION = True
# DO_MULTI_RUN = False

if DO_SINGLE_RUN_WITH_ANIMATION:
    print("--- Ejecutando una sola vez con animación (si está activada en parámetros) ---")
    run_single_experiment(NUM_CITIES_MAIN, RANDOM_SEED_MAIN, ga_parameters.get('animate_first_run', True), ga_parameters)

# if DO_MULTI_RUN:
# ... (código para multi-run sin cambios)

print("\nPrograma finalizado.")

# Importar las funciones necesarias de IPython para mostrar HTML
from IPython.core.display import display, HTML

# Definir el contenido HTML, CSS y JavaScript como un string multilínea
html_content = """
<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>AG para Navegación en Laberintos: Teoría y Aplicación</title>
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap" rel="stylesheet">
  <style>
    /* Definición de variables CSS para temas */
    :root {
      --bg-color: #f4f6f8; /* Un gris azulado muy claro */
      --text-color: #2c3e50; /* Azul oscuro/gris para texto */
      --header-color: #2980b9; /* Azul medio */
      --header-dark-color: #a9cce3; /* Azul claro para modo oscuro */
      --accent-color: #27ae60; /* Verde esmeralda */
      --accent-dark-color: #7dcea0; /* Verde más claro para modo oscuro */
      --button-bg: #3498db; /* Azul brillante */
      --button-hover-bg: #2980b9; /* Azul medio */
      --button-dark-bg: #e67e22; /* Naranja zanahoria */
      --button-dark-hover-bg: #d35400; /* Naranja quemado */
      --button-text-color: white;
      --theme-button-bg: #8e44ad; /* Amatista */
      --theme-button-dark-bg: #f1c40f; /* Girasol */
      --content-panel-bg: #eaf2f8; /* Azul cielo pálido */
      --content-panel-dark-bg: #34495e; /* Azul pizarra oscuro */
      --code-block-bg: #ecf0f1; /* Nubes (gris muy claro) */
      --code-block-dark-bg: #566573; /* Gris pizarra */
    }

    body {
      font-family: 'Roboto', Arial, sans-serif;
      line-height: 1.8;
      background-color: var(--bg-color);
      color: var(--text-color);
      transition: background-color 0.3s, color 0.3s;
      padding: 20px;
      margin: 0;
    }
    .container {
      max-width: 950px;
      margin: auto;
      padding: 25px;
      position: relative;
      background-color: var(--bg-color);
      border-radius: 10px;
      box-shadow: 0 5px 15px rgba(0,0,0,0.07);
    }
    body.dark-mode .container {
        box-shadow: 0 5px 15px rgba(0,0,0,0.2);
    }
    body.dark-mode {
      --bg-color: #2c3e50;
      --text-color: #ecf0f1;
      --header-color: var(--header-dark-color);
      --accent-color: var(--accent-dark-color);
      --button-bg: var(--button-dark-bg);
      --button-hover-bg: var(--button-dark-hover-bg);
      --content-panel-bg: var(--content-panel-dark-bg);
      --code-block-bg: var(--code-block-dark-bg);
    }

    h1 { /* Título principal del documento */
      font-size: 2.4em;
      color: var(--header-color);
      text-align: center;
      margin-bottom: 20px;
      padding-bottom: 15px;
      border-bottom: 2px solid var(--header-color);
    }
    /* Título de las secciones principales colapsables */
    .section-toggle-button h2 {
      font-size: 1.6em;
      color: var(--button-text-color);
      margin: 0;
      padding: 0;
      font-weight: 700;
      text-align: left;
    }
     /* Para subtítulos dentro de los paneles de contenido */
     .content-panel h3 {
      font-size: 1.4em;
      color: var(--accent-color);
      margin-top: 20px;
      margin-bottom: 12px;
      padding-bottom: 4px;
      border-bottom: 1px solid var(--accent-color);
      text-align: left;
    }
    .content-panel h4 { /* Para sub-subtítulos como a, b, c */
        font-size: 1.2em;
        color: var(--header-color);
        margin-top: 18px;
        margin-bottom: 8px;
    }

    .content-panel {
      display: none;
      margin-top: 0;
      padding: 22px;
      border-left: 4px solid var(--accent-color);
      background-color: var(--content-panel-bg);
      border-radius: 0 0 8px 8px;
    }
    .content-panel.is-visible {
      display: block;
    }

    .section-toggle-button {
      background-color: var(--button-bg);
      border: none;
      padding: 13px 18px;
      border-radius: 8px;
      cursor: pointer;
      margin-top: 16px;
      transition: background-color 0.3s, border-radius 0.2s;
      width: 100%;
      display: flex;
      align-items: center;
    }
    .section-toggle-button:hover {
      background-color: var(--button-hover-bg);
    }
    .section-toggle-button.is-expanded {
        border-radius: 8px 8px 0 0;
    }

    .theme-toggle {
      background-color: var(--theme-button-bg);
      color: white;
      border: none;
      padding: 9px 14px;
      border-radius: 6px;
      cursor: pointer;
      position: absolute;
      top: 25px;
      right: 25px;
      font-size: 0.9em;
      transition: background-color 0.3s;
      z-index: 10;
    }
    body.dark-mode .theme-toggle {
       background-color: var(--theme-button-dark-bg);
       color: var(--text-color);
    }

    button:focus, a:focus {
        outline: 2px solid var(--accent-color);
        outline-offset: 3px;
    }
    body.dark-mode button:focus, body.dark-mode a:focus {
         outline-color: var(--accent-dark-color);
    }
    .content-panel p, .content-panel ul {
        margin-bottom: 1.1em;
        font-size: 1.03em;
    }
    .content-panel p:last-child, .content-panel ul:last-child {
        margin-bottom: 0;
    }
    ul {
        padding-left: 30px;
    }
    li {
        margin-bottom: 0.6em;
    }
    strong {
        font-weight: 700;
    }
    .code-example {
        background-color: var(--code-block-bg);
        padding: 10px 15px;
        border-radius: 5px;
        font-family: 'Courier New', Courier, monospace;
        margin: 10px 0;
        white-space: pre-wrap; /* Para que respete saltos de línea y espacios */
        font-size: 0.95em;
    }
    hr {
        border: 0;
        height: 1px;
        background-image: linear-gradient(to right, rgba(0, 0, 0, 0), var(--accent-color), rgba(0, 0, 0, 0));
        margin: 25px 0;
    }
  </style>
</head>
<body>
  <div class="container">
    <button id="theme-toggle-btn" class="theme-toggle" onclick="toggleTheme()" title="Cambiar tema de color">Modo Oscuro</button>

    <h1>Algoritmos Genéticos para Navegación en Laberintos: Teoría y Aplicación Práctica</h1>

    <!-- Sección 1: Introducción -->
    <button class="section-toggle-button" onclick="toggleSection('lab_intro', this)" aria-expanded="false" aria-controls="lab_intro">
      <h2>1. Introducción</h2>
    </button>
    <div id="lab_intro" class="content-panel">
      <p>La navegación en laberintos es un problema emblemático en el campo de la inteligencia artificial. El desafío consiste en que un agente encuentre una ruta óptima desde un punto de inicio hasta una meta, sorteando obstáculos y, a menudo, minimizando la longitud del camino o el tiempo empleado. Este tipo de problema se vuelve particularmente complejo en entornos de gran escala, con múltiples caminos sin salida o con una topología intrincada.</p>
      <p>Los <strong>algoritmos genéticos (AG)</strong>, inspirados directamente en los mecanismos de la evolución biológica como la selección natural, la herencia y la mutación, ofrecen un enfoque robusto y adaptable para abordar estos desafíos. Permiten explorar un vasto espacio de posibles soluciones (caminos) de manera paralela y heurística.</p>
      <p>Este documento se adentra en la teoría subyacente de los AG y detalla su aplicación específica a la resolución de laberintos, utilizando como referencia una implementación práctica avanzada desarrollada en Python que incorpora técnicas modernas para mejorar la eficiencia y la calidad de las soluciones encontradas.</p>
    </div>
    <hr>

    <!-- Sección 2: Representación del Laberinto y de los Individuos -->
    <button class="section-toggle-button" onclick="toggleSection('lab_representacion', this)" aria-expanded="false" aria-controls="lab_representacion">
      <h2>2. Representación del Laberinto y de los Individuos</h2>
    </button>
    <div id="lab_representacion" class="content-panel">
      <h4>a. Laberinto como Entorno</h4>
      <p>El entorno del laberinto se modela comúnmente como una <strong>matriz o cuadrícula bidimensional</strong>. En esta representación, cada celda de la matriz tiene un valor que indica su naturaleza:</p>
      <ul>
        <li><strong style="color:var(--accent-color);"><code>0</code> (o un valor similar):</strong> Representa una celda transitable, es decir, un pasillo o camino por donde el agente puede moverse.</li>
        <li><strong style="color:var(--header-color);"><code>1</code> (o un valor diferente):</strong> Representa un obstáculo, como una pared, que el agente no puede atravesar.</li>
      </ul>
      <p>Dentro de esta matriz, se definen claramente una posición de <strong>inicio (start)</strong> y una posición <strong>objetivo (end)</strong>. La navegación válida se restringe, por lo general, a movimientos en las cuatro direcciones cardinales: arriba, abajo, izquierda y derecha, desde una celda transitable a otra adyacente y también transitable.</p>

      <h4>b. Codificación Genética del Individuo (Camino)</h4>
      <p>En el contexto de los AG, cada <strong>individuo</strong> representa una solución candidata al problema. Para la navegación en laberintos, un individuo es un <strong>camino potencial</strong> desde el inicio hasta (idealmente) el final.</p>
      <p>Una codificación efectiva y natural para este problema es representar al individuo como una <strong>secuencia ordenada de posiciones (coordenadas <code>(fila, columna)</code>)</strong> en el laberinto. Por ejemplo:</p>
      <div class="code-example">
Individuo A: [(0,0), (0,1), (1,1), (1,2), (2,2)]  // Un camino potencial
      </div>
      <p>Esta representación es preferible a una secuencia de movimientos (ej. [derecha, abajo, derecha]), ya que facilita la aplicación de operadores genéticos directamente sobre los nodos visitados y simplifica la verificación de la validez del camino. Cada individuo siempre comienza en la posición <code>start</code> y su estructura genética evoluciona en un intento por alcanzar la posición <code>end</code>.</p>
    </div>
    <hr>

    <!-- Sección 3: Función de Evaluación (Fitness) -->
    <button class="section-toggle-button" onclick="toggleSection('lab_fitness', this)" aria-expanded="false" aria-controls="lab_fitness">
      <h2>3. Función de Evaluación (Fitness)</h2>
    </button>
    <div id="lab_fitness" class="content-panel">
      <p>La <strong>función de fitness</strong> es el componente crítico que guía el proceso evolutivo. Cuantifica la "calidad" o "aptitud" de cada individuo (camino) en la población. Una función de fitness bien diseñada es crucial para dirigir la búsqueda hacia soluciones deseables.</p>
      <p>Para el problema de laberintos, una función de fitness robusta podría incorporar varios criterios, ponderados adecuadamente:</p>
      <ul>
        <li><strong>Alcance del Objetivo:</strong> Se otorga una recompensa significativamente alta (o una penalización muy baja) a los individuos que logran alcanzar la celda objetivo <code>(end)</code>. Este es, usualmente, el componente más importante.</li>
        <li><strong>Longitud del Camino:</strong> Se penaliza la longitud excesiva del camino. Caminos más cortos, si alcanzan el objetivo, son preferibles. Esto se puede implementar como una penalización proporcional al número de pasos.</li>
        <li><strong>Penalización por Bucles o Redundancia:</strong> Visitar repetidamente las mismas celdas o segmentos del laberinto es ineficiente. Se pueden introducir penalizaciones si un individuo contiene bucles o revisita celdas innecesariamente.</li>
        <li><strong>Distancia al Objetivo (si no se alcanza):</strong> Para los individuos que no llegan al final, se puede usar una heurística como la distancia de Manhattan o Euclidiana desde la última celda alcanzada por el individuo hasta la celda objetivo. Una menor distancia resulta en una menor penalización (o mayor fitness relativo).</li>
        <li><strong>Validez del Camino:</strong> Implícitamente, los caminos deben ser válidos (no atravesar paredes). Si se permiten caminos inválidos durante la evolución (para luego repararlos), deben ser fuertemente penalizados.</li>
      </ul>
      <p>El objetivo de esta función multifacética es guiar a la población no solo a encontrar *un* camino, sino a encontrar caminos que sean directos, eficientes y que efectivamente resuelvan el laberinto.</p>
    </div>
    <hr>

    <!-- Sección 4: Operadores Genéticos -->
    <button class="section-toggle-button" onclick="toggleSection('lab_operadores', this)" aria-expanded="false" aria-controls="lab_operadores">
      <h2>4. Operadores Genéticos Fundamentales</h2>
    </button>
    <div id="lab_operadores" class="content-panel">
      <p>Los operadores genéticos son los mecanismos que introducen variación y combinan características de los individuos para generar nuevas soluciones (descendencia).</p>
      <h4>a. Selección de Progenitores</h4>
      <p>El proceso de selección determina qué individuos de la población actual serán elegidos para reproducirse. Un método comúnmente utilizado y efectivo es la <strong>selección por torneo estocástico</strong>:</p>
      <ol>
        <li>Se eligen aleatoriamente <i>k</i> individuos de la población (donde <i>k</i> es el tamaño del torneo, típicamente un valor pequeño como 2 o 3).</li>
        <li>De estos <i>k</i> individuos, el que tenga el mejor fitness es seleccionado como progenitor.</li>
        <li>Este proceso se repite hasta obtener el número deseado de progenitores.</li>
      </ol>
      <p>Este método equilibra la presión selectiva (favoreciendo a los mejores) con el mantenimiento de la diversidad genética (dando oportunidad a individuos no tan buenos de ser seleccionados ocasionalmente).</p>

      <h4>b. Cruzamiento (Crossover)</h4>
      <p>El cruzamiento combina la información genética de dos individuos progenitores para crear uno o dos descendientes. Para caminos representados como secuencias de posiciones:</p>
      <ul>
        <li><strong>Crossover por Punto de Corte Único/Múltiple:</strong> Se elige uno o más puntos de corte aleatorios en los caminos de los padres. Los segmentos resultantes se intercambian para formar los caminos de los hijos.</li>
        <li><strong>Reparación del Camino:</strong> Después del cruzamiento, es muy probable que el camino resultante sea topológicamente inválido (las celdas consecutivas podrían no ser adyacentes en el laberinto). Por lo tanto, es crucial aplicar un **mecanismo de reparación**. Esto podría implicar:
            <ul>
                <li>Eliminar nodos inválidos.</li>
                <li>Insertar nodos intermedios para conectar segmentos desconectados (usando, por ejemplo, una búsqueda A* o BFS corta entre los puntos de ruptura).</li>
                <li>Descartar al descendiente si la reparación es demasiado compleja o inviable.</li>
            </ul>
        </li>
      </ul>
      <p>El objetivo es que los descendientes hereden sub-caminos "buenos" de ambos padres.</p>

      <h4>c. Mutación</h4>
      <p>La mutación introduce pequeños cambios aleatorios en un individuo, fomentando la exploración de nuevas áreas del espacio de soluciones y evitando la convergencia prematura a óptimos locales. Para la navegación en laberintos, se pueden implementar diversos tipos de mutación:</p>
      <ul>
        <li><strong>Añadir/Eliminar Paso:</strong> Insertar una nueva celda válida en una posición aleatoria del camino, o eliminar una celda existente (siempre que el camino resultante pueda ser reparado para mantener la conectividad).</li>
        <li><strong>Reemplazar Segmento:</strong> Seleccionar un segmento aleatorio del camino y reemplazarlo por un nuevo segmento generado aleatoriamente (pero válido) entre los puntos de inicio y fin del segmento original.</li>
        <li><strong>Mutación Guiada por Obstáculos:</strong> Si un camino está cerca de una pared, intentar una mutación que lo aleje o lo redirija.</li>
        <li><strong>Optimización Local de un Tramo:</strong> Seleccionar un pequeño segmento del camino y aplicar una búsqueda local simple (como una BFS de pocos pasos o un algoritmo de acortamiento) para encontrar una ruta mejor dentro de ese tramo.</li>
      </ul>
      <p>La diversidad de operadores de mutación enriquece la capacidad del AG para adaptarse dinámicamente a la estructura específica del laberinto.</p>
    </div>
    <hr>

    <!-- Sección 5: Mecanismos Avanzados -->
    <button class="section-toggle-button" onclick="toggleSection('lab_avanzados', this)" aria-expanded="false" aria-controls="lab_avanzados">
      <h2>5. Mecanismos Avanzados en la Implementación</h2>
    </button>
    <div id="lab_avanzados" class="content-panel">
      <p>Una implementación robusta de AG para laberintos a menudo incluye técnicas más sofisticadas que van más allá de los operadores básicos, mejorando significativamente el rendimiento y la capacidad de encontrar soluciones óptimas.</p>
      <h4>a. Mutación Adaptativa</h4>
      <p>La tasa de mutación (la probabilidad de que un individuo mute) es un parámetro crítico. Una tasa fija puede no ser óptima durante todo el proceso evolutivo. La <strong>mutación adaptativa</strong> ajusta esta tasa dinámicamente:</p>
      <ul>
        <li>Si la <strong>diversidad de la población</strong> (medida, por ejemplo, por la distancia promedio entre individuos o la varianza del fitness) cae por debajo de un umbral, la tasa de mutación se incrementa. Esto ayuda a introducir nueva variabilidad genética y a escapar de posibles estancamientos.</li>
        <li>Si la población está mostrando una mejora constante y buena diversidad, la tasa de mutación puede reducirse para permitir una explotación más fina de las regiones prometedoras del espacio de soluciones (convergencia).</li>
      </ul>
      <p>Este mecanismo ayuda a balancear la exploración y la explotación de manera más inteligente.</p>

      <h4>b. Reseteo Parcial de Población (o Mecanismos de Diversificación)</h4>
      <p>Cuando el algoritmo se estanca (es decir, no hay mejoras significativas en el mejor fitness durante un número considerable de generaciones), puede ser una señal de que la población ha convergido prematuramente a un óptimo local. Para contrarrestar esto:</p>
      <ul>
        <li>Se puede realizar un <strong>reseteo parcial de la población</strong>: una porción de la población (excluyendo quizás a los mejores individuos, la "élite") se reemplaza por nuevos individuos generados aleatoriamente.</li>
        <li>Alternativamente, se pueden aplicar operadores de mutación más agresivos o introducir individuos de "nichos" diferentes.</li>
      </ul>
      <p>El objetivo es reintroducir diversidad para permitir al algoritmo explorar otras regiones del espacio de búsqueda.</p>

      <h4>c. Búsqueda Local Híbrida (Memética)</h4>
      <p>Los algoritmos genéticos son buenos explorando globalmente el espacio de soluciones, pero pueden no ser tan eficientes en la explotación fina (encontrar el óptimo exacto dentro de una región prometedora). La hibridación con técnicas de búsqueda local puede ser muy efectiva (a esto se le conoce como <strong>algoritmos meméticos</strong>):</p>
      <ul>
        <li>Periódicamente (cada cierto número de generaciones) o cuando se detecta estancamiento.</li>
        <li>Sobre los individuos más prometedores de la población (la élite).</li>
        <li>Se aplica un algoritmo de <strong>búsqueda local</strong> sobre estos individuos. Para laberintos, esto podría implicar:
            <ul>
                <li>Algoritmos de acortamiento de caminos (ej. eliminar nodos redundantes si se puede trazar una línea recta entre dos nodos no consecutivos del camino).</li>
                <li>Intentar reemplazar pequeños segmentos del camino por rutas alternativas más cortas encontradas mediante una BFS o A* limitada.</li>
                <li>Eliminación de bucles evidentes.</li>
            </ul>
        </li>
      </ul>
      <p>Esta técnica permite que cada individuo "aprenda" o se "refine" durante su vida, combinando la exploración global del AG con la explotación local.</p>
    </div>
    <hr>

    <!-- Sección 6: Visualización Dinámica -->
    <button class="section-toggle-button" onclick="toggleSection('lab_visualizacion', this)" aria-expanded="false" aria-controls="lab_visualizacion">
      <h2>6. Visualización Dinámica del Proceso Evolutivo</h2>
    </button>
    <div id="lab_visualizacion" class="content-panel">
      <p>La visualización es una herramienta invaluable para entender el comportamiento de un algoritmo genético y para depurar su implementación. Una buena visualización dinámica puede mostrar en tiempo real (o por generación):</p>
      <ul>
        <li><strong>Evolución del Fitness:</strong> Gráficos que muestren el mejor fitness y el fitness promedio de la población a lo largo de las generaciones. Esto indica si el algoritmo está convergiendo y mejorando.</li>
        <li><strong>Diversidad Genética:</strong> Métricas de diversidad, como la distancia promedio de Jaccard entre los caminos de los individuos, o la entropía de la población. Una caída drástica en la diversidad puede señalar convergencia prematura.</li>
        <li><strong>Estadísticas Clave:</strong> Información como la tasa de mutación actual (si es adaptativa), el número de veces que se ha activado el reseteo de población, la longitud promedio de los caminos, etc.</li>
        <li><strong>Visualización del Laberinto y el Mejor Camino:</strong> Una representación gráfica del laberinto mostrando el camino encontrado por el mejor individuo de la generación actual. Esto permite observar visualmente cómo evolucionan las estrategias de navegación.</li>
        <li><strong>Histograma de Fitness:</strong> Para ver la distribución de la calidad de las soluciones en la población actual.</li>
      </ul>
      <p>Estas visualizaciones no solo son útiles para el análisis post-ejecución, sino que también pueden ayudar a ajustar los parámetros del AG durante el desarrollo para optimizar su rendimiento.</p>
    </div>
    <hr>

    <!-- Sección 7: Resultados Esperados -->
    <button class="section-toggle-button" onclick="toggleSection('lab_resultados', this)" aria-expanded="false" aria-controls="lab_resultados">
      <h2>7. Resultados Esperados y Comportamiento Típico</h2>
    </button>
    <div id="lab_resultados" class="content-panel">
      <p>Al aplicar un algoritmo genético bien configurado, como el descrito, a un problema de laberinto, se espera observar un patrón evolutivo característico:</p>
      <ul>
        <li><strong>Fase Inicial (Exploración):</strong> En las primeras generaciones, los individuos suelen ser caminos aleatorios y de baja calidad. El fitness promedio es bajo, y el mejor individuo podría estar lejos del objetivo. La diversidad es generalmente alta.</li>
        <li><strong>Fase de Convergencia Rápida:</strong> A medida que la selección y los operadores genéticos comienzan a actuar, emergen individuos que se acercan progresivamente al objetivo. El mejor fitness y el fitness promedio suelen mejorar rápidamente. Pueden aparecer los primeros caminos que alcanzan la meta, aunque no sean óptimos.</li>
        <li><strong>Fase de Refinamiento (Explotación):</strong> Una vez que muchos individuos alcanzan el objetivo, la presión selectiva se enfoca en optimizar otros criterios, como la longitud del camino. Los operadores de mutación más finos y la búsqueda local (si está presente) juegan un papel importante aquí. La mejora del fitness puede volverse más lenta y gradual.</li>
        <li><strong>Convergencia o Estabilización:</strong> Eventualmente, el algoritmo puede converger a una solución de alta calidad (posiblemente la óptima o cercana a ella) o estabilizarse si no se encuentran mejoras significativas. En este punto, la diversidad de la población puede ser baja si no se maneja adecuadamente.</li>
      </ul>
      <p>Se espera la aparición de caminos que no solo sean válidos (sin atravesar paredes y conectando inicio y fin), sino también optimizados en términos de longitud y sin ciclos o movimientos redundantes.</p>
    </div>
    <hr>

    <!-- Sección 8: Conclusión -->
    <button class="section-toggle-button" onclick="toggleSection('lab_conclusion', this)" aria-expanded="false" aria-controls="lab_conclusion">
      <h2>8. Conclusión e Implicaciones Futuras</h2>
    </button>
    <div id="lab_conclusion" class="content-panel">
      <p>La aplicación de algoritmos genéticos para la resolución de laberintos demuestra ser un enfoque <strong>robusto, adaptativo y inherentemente exploratorio</strong>. Se adapta de forma natural a la naturaleza discreta de los entornos de cuadrícula y a la presencia de múltiples obstáculos y caminos posibles.</p>
      <p>La implementación avanzada descrita, que combina los mecanismos evolutivos clásicos con técnicas modernas como la búsqueda local híbrida y la mutación adaptativa, constituye un <strong>sistema híbrido y eficiente</strong>. Este tipo de sistema no solo es capaz de resolver eficazmente laberintos estáticos, sino que también sienta las bases para abordar problemas más complejos:</p>
      <ul>
        <li>Navegación en entornos dinámicos (con obstáculos móviles).</li>
        <li>Laberintos con múltiples agentes.</li>
        <li>Mapas con características especiales como portales, llaves, o diferentes costos de terreno.</li>
        <li>Optimización multiobjetivo (ej. minimizar distancia y exposición a riesgos).</li>
      </ul>
      <p>Además, este enfoque abre el camino hacia la integración con paradigmas de aprendizaje más sofisticados. La combinación de la exploración evolutiva con políticas de decisión aprendidas mediante <strong>aprendizaje por refuerzo (RL)</strong>, como se propone en trabajos como <em>AlphaEvolve</em>, promete la creación de algoritmos de navegación y resolución de problemas aún más inteligentes y autónomos, capaces de aprender estrategias complejas y adaptarse a una variedad aún mayor de desafíos.</p>
    </div>

  </div> <!-- Fin de .container -->

  <script>
    // Función para cambiar entre modo claro y oscuro
    function toggleTheme() {
      document.body.classList.toggle("dark-mode");
      let themeButton = document.getElementById('theme-toggle-btn');
      let isDarkMode = document.body.classList.contains("dark-mode");
      localStorage.setItem("theme", isDarkMode ? "dark" : "light");
      if (themeButton) {
          themeButton.textContent = isDarkMode ? "Modo Claro" : "Modo Oscuro";
      }
    }

    // Función para mostrar/ocultar paneles de contenido
    function toggleSection(id, buttonElement) {
      let panel = document.getElementById(id);
      if (panel && buttonElement) {
          panel.classList.toggle('is-visible');
          let isVisible = panel.classList.contains('is-visible');
          buttonElement.setAttribute('aria-expanded', isVisible);
          buttonElement.classList.toggle('is-expanded', isVisible);
      }
    }

    // Función que se ejecuta cuando la página carga
    window.onload = function() {
      let themeButton = document.getElementById('theme-toggle-btn');
      const savedTheme = localStorage.getItem("theme");

      if (savedTheme === "dark") {
        document.body.classList.add("dark-mode");
        if (themeButton) {
            themeButton.textContent = "Modo Claro";
        }
      } else {
        document.body.classList.remove("dark-mode");
        if (themeButton) {
            themeButton.textContent = "Modo Oscuro";
        }
      }

       document.querySelectorAll('.content-panel').forEach(panel => {
         panel.classList.remove('is-visible');
       });
       document.querySelectorAll('.section-toggle-button').forEach(button => {
          button.setAttribute('aria-expanded', 'false');
          button.classList.remove('is-expanded');
       });
    }
  </script>
</body>
</html>
"""

# Mostrar el HTML en la salida de la celda
display(HTML(html_content))

"""1,2   3,5   distancia manhatan  3-1= 2  5-2=3 cinco  , distancia euclidia 2-1=2 4  5-2=3 9 4+9 13 raiz"""

import numpy as np
import matplotlib.pyplot as plt
import matplotlib.patches as patches # Para dibujar el laberinto
import random
import seaborn as sns
import time
import math
from collections import deque
from IPython.display import display, clear_output

# --- Parámetros Globales para Mejoras (Ajusta según necesidad) ---
ADAPTIVE_MUT_LOW_DIVERSITY_THRESHOLD = 0.20 # Si la diversidad baja de esto
MIN_MUTATION_RATE = 0.05
MAX_MUTATION_RATE = 0.50
MUTATION_ADAPT_FACTOR_INCREASE = 1.1
MUTATION_ADAPT_FACTOR_DECREASE = 0.98

STAGNATION_FOR_RESET = 25
RESET_FRACTION = 0.3

APPLY_LOCAL_SEARCH_EVERY_N_GENS = 10
PROB_APPLY_LOCAL_SEARCH_TO_ELITE = 0.5

# Configuración visual
plt.style.use('default')
plt.rcParams['figure.facecolor'] = 'white'
plt.rcParams['axes.facecolor'] = 'white'
plt.rcParams['savefig.facecolor'] = 'white'
plt.rcParams['font.sans-serif'] = ['DejaVu Sans', 'Verdana', 'Geneva', 'sans-serif']
sns.set_palette("husl")

class MazeEnvironment:
    """Representa el entorno del laberinto"""

    def __init__(self, maze_matrix, start_pos, end_pos):
        self.maze = np.array(maze_matrix)
        self.height, self.width = self.maze.shape
        self.start_pos = tuple(start_pos)
        self.end_pos = tuple(end_pos)

        if not (0 <= self.start_pos[0] < self.height and 0 <= self.start_pos[1] < self.width):
            raise ValueError(f"Posición de inicio {self.start_pos} fuera de los límites del laberinto {self.maze.shape}")
        if not (0 <= self.end_pos[0] < self.height and 0 <= self.end_pos[1] < self.width):
            raise ValueError(f"Posición de fin {self.end_pos} fuera de los límites del laberinto {self.maze.shape}")

        if self.maze[self.start_pos] == 1 or self.maze[self.end_pos] == 1:
            raise ValueError("Las posiciones de inicio o fin están en paredes")

    def is_valid_position(self, pos):
        row, col = pos
        return (0 <= row < self.height and
                0 <= col < self.width and
                self.maze[row, col] == 0) # 0 es camino

    def get_neighbors(self, pos):
        row, col = pos; neighbors = []
        for dr, dc in [(-1, 0), (1, 0), (0, -1), (0, 1)]: # Arriba, Abajo, Izquierda, Derecha
            new_pos = (row + dr, col + dc)
            # No es necesario chequear is_valid_position aquí, se hará donde se use
            if 0 <= new_pos[0] < self.height and 0 <= new_pos[1] < self.width:
                 neighbors.append(new_pos)
        return neighbors # Devuelve vecinos dentro de los límites, pueden ser pared o camino

    def manhattan_distance(self, pos1, pos2):
        return abs(pos1[0] - pos2[0]) + abs(pos1[1] - pos2[1])

    def euclidean_distance(self, pos1, pos2):
        return math.sqrt((pos1[0] - pos2[0])**2 + (pos1[1] - pos2[1])**2)

class GeneticMazeSolver:
    def __init__(self, maze_env, population_size=100, elite_size=20,
                 initial_mutation_rate=0.15, crossover_rate=0.8,
                 max_generations=500, animate=False, stagnation_limit=50,
                 random_seed=None, use_adaptive_mutation=True,
                 use_population_reset=True, use_local_search=True,
                 max_path_len_factor=1.5): # Factor para max_path_length

        self.random_seed = random_seed
        if self.random_seed is not None:
            random.seed(self.random_seed)
            np.random.seed(self.random_seed)

        self.maze_env = maze_env
        self.population_size = population_size
        self.elite_size = elite_size
        self.mutation_rate = initial_mutation_rate
        self.initial_mutation_rate = initial_mutation_rate
        self.crossover_rate = crossover_rate
        self.max_generations = max_generations
        self.animate = animate
        self.stagnation_limit = stagnation_limit

        self.use_adaptive_mutation = use_adaptive_mutation
        self.use_population_reset = use_population_reset
        self.use_local_search = use_local_search

        # Longitud máxima heurística para un camino
        self.max_path_length = int(maze_env.width * maze_env.height * max_path_len_factor)

        self.best_fitness_history = []
        self.avg_fitness_history = []
        self.diversity_history = []
        self.mutation_rate_history = []
        self.generation_times = []

        self.best_path = None
        self.best_fitness = float('-inf') # Maximizar fitness
        self.current_generation = 0
        self.generations_since_last_improvement = 0
        self.generations_since_last_reset = 0

        self.fig_dynamic = None
        self.axes_dynamic = None

    def create_individual(self):
        """Crea un individuo (camino) aleatorio, intentando ir hacia el objetivo."""
        path = [self.maze_env.start_pos]
        current_pos = self.maze_env.start_pos
        # No permitir visitar la misma celda consecutivamente en la creación inicial
        # (excepto si es la única opción para no quedarse atascado)
        # Un set de visitados simple para la creación del individuo actual
        current_path_visited_for_creation = {current_pos}

        for _ in range(self.max_path_length -1): # -1 porque start_pos ya está
            if current_pos == self.maze_env.end_pos:
                break

            potential_next_moves = []
            for neighbor_pos in self.maze_env.get_neighbors(current_pos):
                if self.maze_env.maze[neighbor_pos] == 0: # Si es camino
                    if neighbor_pos not in current_path_visited_for_creation or neighbor_pos == self.maze_env.end_pos :
                        potential_next_moves.append(neighbor_pos)

            if not potential_next_moves:
                 # Intentar retroceder si está atascado (simplificado)
                if len(path) > 1 and path[-2] not in current_path_visited_for_creation : # Evitar oscilaciones simples
                    next_pos = path[-2] # Retroceder un paso
                else: # No hay a dónde ir o se quedaría oscilando
                    break # Terminar camino
            else:
                # Selección de siguiente movimiento con sesgo
                if random.random() < 0.8 and self.maze_env.end_pos not in potential_next_moves : # 80% heurística
                    distances = [self.maze_env.manhattan_distance(pos, self.maze_env.end_pos) for pos in potential_next_moves]
                    min_dist = min(distances)
                    best_options = [pos for i, pos in enumerate(potential_next_moves) if distances[i] == min_dist]
                    next_pos = random.choice(best_options)
                else: # 20% aleatorio
                    next_pos = random.choice(potential_next_moves)

            path.append(next_pos)
            current_path_visited_for_creation.add(next_pos) # Añadir al set de visitados de este camino
            current_pos = next_pos
            if len(path) >= self.max_path_length: break
        return path

    def create_population(self):
        population = [self.create_individual() for _ in range(self.population_size)]
        # Añadir una porción de individuos creados con A* o BFS si es muy difícil
        # num_heuristic = self.population_size // 10
        # for _ in range(num_heuristic):
        #     population[random.randint(0, self.population_size-1)] = self.create_a_star_individual() # Necesitarías implementar esto
        return population

    def is_valid_path(self, path):
        if not path or path[0] != self.maze_env.start_pos: return False
        for i in range(len(path)):
            if self.maze_env.maze[path[i]] == 1: return False # Está en una pared
            if i > 0:
                if self.maze_env.manhattan_distance(path[i-1], path[i]) != 1:
                    return False # No son adyacentes
        return True

    def fitness(self, path):
        if not path or len(path) == 0 or not self.is_valid_path(path):
            return -100000 # Penalización muy alta para inválidos

        path_len = len(path)
        unique_cells = len(set(path))

        # Penalización por longitud excesiva
        length_penalty = 0
        if path_len > self.max_path_length:
             length_penalty = (path_len - self.max_path_length) * 50

        # Penalización por bucles (visitar la misma celda muchas veces)
        loop_penalty = (path_len - unique_cells) * 20

        # Distancia al objetivo desde el último punto del camino
        last_pos = path[-1]
        dist_to_goal = self.maze_env.manhattan_distance(last_pos, self.maze_env.end_pos)

        # Fitness base
        # Queremos maximizar, así que valores más altos son mejores.
        # Damos una gran recompensa por alcanzar el objetivo.
        # Penalizamos la distancia al objetivo y la longitud del camino.

        fitness_score = 10000.0 # Base alta

        if last_pos == self.maze_env.end_pos:
            fitness_score += 50000 # Gran recompensa por llegar
            # Si llega, la longitud del camino es el factor principal de desempate (menor es mejor)
            fitness_score -= path_len * 10 # Penalizar caminos más largos
        else:
            # Si no llega, penalizar fuertemente la distancia al objetivo
            fitness_score -= dist_to_goal * 100
            fitness_score -= path_len # Penalizar también la longitud

        fitness_score -= loop_penalty
        fitness_score -= length_penalty

        # Evitar que el fitness sea demasiado negativo si las penalizaciones son enormes
        return max(fitness_score, -90000)


    def selection(self, population, fitnesses): # Torneo
        selected = []
        pop_size = len(population)
        for _ in range(pop_size):
            tournament_size = min(5, pop_size)
            if tournament_size == 0: continue
            tournament_indices = random.sample(range(pop_size), tournament_size)
            winner_idx = max(tournament_indices, key=lambda i: fitnesses[i])
            selected.append(population[winner_idx][:]) # Copia del camino
        return selected

    def crossover(self, parent1, parent2):
        """Crossover de un punto para caminos, intentando mantener la validez."""
        if random.random() > self.crossover_rate or min(len(parent1), len(parent2)) < 2:
            return parent1[:], parent2[:]

        # Intentar encontrar un punto de cruce común si es posible
        # Esto es más complejo para caminos que para permutaciones
        # Por simplicidad, usaremos un cruce de un punto y luego reparamos.

        len1, len2 = len(parent1), len(parent2)

        # Punto de cruce aleatorio en el padre más corto
        cx_point1 = random.randint(1, len1 -1) if len1 > 1 else 0
        cx_point2 = random.randint(1, len2 -1) if len2 > 1 else 0

        child1 = parent1[:cx_point1] + parent2[cx_point2:]
        child2 = parent2[:cx_point2] + parent1[cx_point1:]

        child1 = self.repair_path_simple(child1)
        child2 = self.repair_path_simple(child2)

        return child1, child2

    def repair_path_simple(self, path):
        """Reparación simple: asegurar que empieza bien y eliminar pasos inválidos."""
        if not path or path[0] != self.maze_env.start_pos:
            return self.create_individual() # Si es muy malo, generar uno nuevo

        repaired_path = [self.maze_env.start_pos]
        for i in range(1, len(path)):
            if len(repaired_path) >= self.max_path_length: break

            current_node = path[i]
            prev_node = repaired_path[-1]

            if self.maze_env.maze[current_node] == 0 and \
               self.maze_env.manhattan_distance(prev_node, current_node) == 1:
                repaired_path.append(current_node)
            else:
                # Si el paso es inválido, intentar conectar desde el último válido
                # al siguiente válido del camino original, o simplemente terminar
                # Para esta reparación simple, podemos simplemente truncar o intentar
                # encontrar un vecino válido del último punto válido.
                # Por ahora, si es inválido, no lo añadimos.
                # Si el camino se vuelve demasiado corto, create_individual lo arreglará.
                pass

        # Si el camino resultante es demasiado corto o no válido, generar uno nuevo
        if len(repaired_path) < 2 or not self.is_valid_path(repaired_path):
            return self.create_individual()

        return repaired_path


    def mutate(self, path): # Mutación adaptada para caminos
        if random.random() > self.mutation_rate or len(path) < 2:
            return path[:]

        mutated_path = path[:]
        mutation_type = random.choice(['add_step', 'remove_step', 'change_segment', 'optimize_segment_simple'])

        if mutation_type == 'add_step' and len(mutated_path) < self.max_path_length:
            # Añadir un paso aleatorio en un punto aleatorio
            if len(mutated_path) > 1:
                idx = random.randint(0, len(mutated_path) - 2) # Punto antes del cual insertar
                node_before = mutated_path[idx]
                potential_next_steps = [n for n in self.maze_env.get_neighbors(node_before) if self.maze_env.maze[n] == 0]
                if potential_next_steps:
                    new_step = random.choice(potential_next_steps)
                    # Verificar si el nuevo paso conecta con el siguiente
                    node_after = mutated_path[idx+1]
                    if self.maze_env.manhattan_distance(new_step, node_after) == 1:
                         mutated_path.insert(idx + 1, new_step)

        elif mutation_type == 'remove_step' and len(mutated_path) > 2:
            # Eliminar un paso aleatorio (que no sea inicio o fin si ya llegó)
            idx_to_remove = random.randint(1, len(mutated_path) - 2)
            node_before = mutated_path[idx_to_remove-1]
            node_after = mutated_path[idx_to_remove+1]
            # Si al quitar el nodo, el anterior y el siguiente son adyacentes, se puede quitar
            if self.maze_env.manhattan_distance(node_before, node_after) == 1:
                mutated_path.pop(idx_to_remove)

        elif mutation_type == 'change_segment' and len(mutated_path) > 3:
            # Reemplazar un pequeño segmento por uno nuevo aleatorio
            start_idx = random.randint(1, len(mutated_path) - 3)
            end_idx = min(start_idx + random.randint(1,3), len(mutated_path) -1)

            segment_start_node = mutated_path[start_idx-1]
            segment_end_node = mutated_path[end_idx]

            # Generar un nuevo segmento corto
            temp_current = segment_start_node
            new_segment_part = []
            visited_in_segment = {temp_current}
            for _ in range(random.randint(1,5)): # Longitud del nuevo segmento
                if temp_current == segment_end_node: break
                potential_next = [n for n in self.maze_env.get_neighbors(temp_current) if self.maze_env.maze[n]==0 and n not in visited_in_segment]
                if not potential_next: break
                next_node = random.choice(potential_next)
                new_segment_part.append(next_node)
                visited_in_segment.add(next_node)
                temp_current = next_node

            # Solo reemplazar si el nuevo segmento conecta con el final del segmento original
            if new_segment_part and new_segment_part[-1] == segment_end_node:
                 mutated_path = mutated_path[:start_idx] + new_segment_part + mutated_path[end_idx+1:]
            elif new_segment_part and self.maze_env.manhattan_distance(new_segment_part[-1], segment_end_node) == 1:
                 mutated_path = mutated_path[:start_idx] + new_segment_part + [segment_end_node] + mutated_path[end_idx+1:]


        elif mutation_type == 'optimize_segment_simple' and len(mutated_path) > 3:
            # Intenta acortar un segmento si es posible (BFS simple)
             idx1 = random.randint(0, len(mutated_path) - 3)
             idx2 = random.randint(idx1 + 2, len(mutated_path) -1)
             node1, node2 = mutated_path[idx1], mutated_path[idx2]

             q = deque([(node1, [node1])])
             visited_bfs = {node1}
             shortest_subpath = None

             while q:
                 curr, p = q.popleft()
                 if len(p) > (idx2 - idx1) + 2 : continue # No buscar caminos mucho más largos
                 if curr == node2:
                     if shortest_subpath is None or len(p) < len(shortest_subpath):
                         shortest_subpath = p
                     # No break, buscar todos los caminos de esta longitud

                 for neighbor in self.maze_env.get_neighbors(curr):
                     if self.maze_env.maze[neighbor] == 0 and neighbor not in visited_bfs:
                         visited_bfs.add(neighbor)
                         q.append((neighbor, p + [neighbor]))

             if shortest_subpath and len(shortest_subpath) < (idx2 - idx1 + 1):
                 mutated_path = mutated_path[:idx1] + shortest_subpath + mutated_path[idx2+1:]

        return self.repair_path_simple(mutated_path)


    def local_search(self, path): # Búsqueda local simple
        """Intenta pequeñas mejoras en el camino."""
        # Esta es una versión muy simplificada. Podrías usar A* o BFS para optimizar segmentos.
        # Por ahora, intentaremos eliminar redundancias.
        if not path: return path

        # Eliminar loops simples
        new_path = [path[0]]
        visited_in_ls = {path[0]}
        for i in range(1, len(path)):
            node = path[i]
            # Si el nodo ya fue visitado Y no es el paso anterior (evitar quitar zig-zags válidos)
            # Y si al quitarlo el anterior y el siguiente siguen conectados
            if node in visited_in_ls and node != new_path[-1]:
                # Intentar encontrar un camino más corto si se forma un loop
                # Esto es complejo. Por ahora, solo evitar añadir si crea un loop inmediato.
                # O si el último nodo es el mismo que el actual, estamos en un loop de 2.
                # Simplificación: si el nodo ya está y no es el anterior, es un loop.
                # No, esto es muy agresivo.
                # Vamos a buscar si A -> B -> C -> B -> D se puede convertir en A -> B -> D

                # La forma más simple de quitar loops es iterar y si path[i] == path[j] con i < j,
                # quitar path[i+1...j]. Haremos esto en una función separada.
                pass # Placeholder, remove_redundant_segments lo hará mejor

            if self.maze_env.manhattan_distance(new_path[-1], node) == 1 and self.maze_env.maze[node]==0 :
                 new_path.append(node)
                 visited_in_ls.add(node)
            # Si no, el camino se rompe. No hacer nada aquí, repair se encargará.

        return self.remove_redundant_segments_robust(new_path)


    def remove_redundant_segments_robust(self, path):
        if len(path) < 3: return path

        made_change = True
        while made_change:
            made_change = False
            i = 0
            temp_path = path[:] # Trabajar sobre una copia en cada iteración del while

            while i < len(temp_path) -1:
                current_node_scan = temp_path[i]
                # Buscar si current_node_scan aparece más adelante
                try:
                    # find a j > i such that temp_path[j] == current_node_scan
                    future_occurrence_idx = temp_path.index(current_node_scan, i + 1)
                    # Si se encuentra, tenemos un loop: temp_path[i...future_occurrence_idx]
                    # El segmento a eliminar es temp_path[i+1...future_occurrence_idx]
                    temp_path = temp_path[:i+1] + temp_path[future_occurrence_idx+1:]
                    made_change = True
                    # No incrementar i, ya que el path ha cambiado, re-escanear desde este punto
                    # o mejor, romper y reiniciar el while externo si hubo cambio.
                    break # Romper el bucle while i < ...
                except ValueError:
                    # No se encontró más adelante, avanzar i
                    i += 1

            path = temp_path # Actualizar el path principal
            if made_change: # Si hubo un cambio, el bucle while externo se repetirá
                continue

        return path


    def calculate_diversity(self, population): # Mantenemos tu Jaccard, es buena idea
        if not population or len(population) < 2: return 0.0
        sample_size = min(len(population), 30)
        sample_indices = random.sample(range(len(population)), sample_size)
        total_distance, num_comparisons = 0, 0
        for i in range(len(sample_indices)):
            for j in range(i + 1, len(sample_indices)):
                s1, s2 = set(population[sample_indices[i]]), set(population[sample_indices[j]])
                intersection, union = len(s1.intersection(s2)), len(s1.union(s2))
                total_distance += (1.0 - (intersection / union)) if union > 0 else 0.0
                num_comparisons += 1
        return total_distance / num_comparisons if num_comparisons > 0 else 0.0

    def draw_maze(self, ax):
        ax.imshow(self.maze_env.maze, cmap='binary', origin='lower', interpolation='nearest')
        # Dibujar inicio y fin
        start_patch = patches.Rectangle((self.maze_env.start_pos[1]-0.5, self.maze_env.start_pos[0]-0.5), 1, 1, linewidth=2, edgecolor='g', facecolor='lightgreen', alpha=0.7)
        end_patch = patches.Rectangle((self.maze_env.end_pos[1]-0.5, self.maze_env.end_pos[0]-0.5), 1, 1, linewidth=2, edgecolor='r', facecolor='salmon', alpha=0.7)
        ax.add_patch(start_patch)
        ax.add_patch(end_patch)
        ax.set_xticks(np.arange(-.5, self.maze_env.width, 1), minor=True)
        ax.set_yticks(np.arange(-.5, self.maze_env.height, 1), minor=True)
        ax.grid(which="minor", color="grey", linestyle='-', linewidth=0.5, alpha=0.3)
        ax.tick_params(which="minor", size=0)
        ax.set_xticks([])
        ax.set_yticks([])

    def draw_path(self, ax, path, color='blue', lw=2, alpha=0.8):
        self.draw_maze(ax) # Dibujar el laberinto base
        if not path: return

        path_y = [p[0] for p in path] # Filas son Y
        path_x = [p[1] for p in path] # Columnas son X
        ax.plot(path_x, path_y, color=color, linewidth=lw, alpha=alpha, marker='o', markersize=lw*2)
        # Marcar el inicio y fin del camino dibujado
        if path:
            ax.plot(path_x[0], path_y[0], 'go', markersize=lw*3, label='Path Start') # Verde para inicio del camino
            ax.plot(path_x[-1], path_y[-1], 'ro', markersize=lw*3, label='Path End') # Rojo para fin del camino

    def setup_dynamic_visualization(self): # Tu implementación es buena
        if not self.animate: return
        if self.fig_dynamic is not None and plt.fignum_exists(self.fig_dynamic.number): plt.close(self.fig_dynamic)
        self.fig_dynamic, self.axes_dynamic = plt.subplots(2, 3, figsize=(20, 12)) # Ajustado
        self.fig_dynamic.patch.set_facecolor('white')
        titles = ['Laberinto Base', 'Mejor Camino Actual', 'Evolución Fitness', 'Top 5 Fitness', 'Diversidad', 'Estadísticas']
        for i, ax in enumerate(self.axes_dynamic.flat):
            ax.set_title(titles[i], fontsize=12, fontweight='bold'); ax.set_facecolor('#f8f8f8')
        plt.tight_layout(rect=[0, 0, 1, 0.95])

    def update_dynamic_visualization(self, population, fitnesses): # COMPLETADO
        if not self.animate or self.axes_dynamic is None or self.fig_dynamic is None: return
        clear_output(wait=True)

        title_suffix = ""
        if self.best_path and self.best_path[-1] == self.maze_env.end_pos:
            title_suffix = f" - SOLUCIONADO! (Len: {len(self.best_path)})"
        main_title = f'Maze Solver (Gen {self.current_generation}{title_suffix})'
        self.fig_dynamic.suptitle(main_title, fontsize=14, fontweight='bold')

        for ax_idx, ax in enumerate(self.axes_dynamic.flat):
            ax.clear()
            titles = ['Laberinto Base', 'Mejor Camino Actual', 'Evolución Fitness', 'Top 5 Fitness', 'Diversidad', 'Estadísticas']
            if ax_idx < len(titles): ax.set_title(titles[ax_idx], fontsize=12, fontweight='bold'); ax.set_facecolor('#f8f8f8')

        self.draw_maze(self.axes_dynamic[0,0]) # Laberinto base
        if self.best_path: self.draw_path(self.axes_dynamic[0,1], self.best_path, color='dodgerblue', lw=2.5) # Mejor camino
        else: self.draw_maze(self.axes_dynamic[0,1]); self.axes_dynamic[0,1].text(0.5,0.5,"Buscando...", ha='center', va='center', transform=self.axes_dynamic[0,1].transAxes)

        if len(self.best_fitness_history) > 1: # Evolución Fitness
            ax_fit = self.axes_dynamic[0,2]; gens = range(len(self.best_fitness_history))
            ax_fit.plot(gens, self.best_fitness_history, 'g-', lw=2, label='Mejor Fitness')
            ax_fit.plot(gens, self.avg_fitness_history, 'b--', lw=1.5, label='Fitness Prom.')
            ax_fit.set_xlabel('Generación'); ax_fit.set_ylabel('Fitness'); ax_fit.legend(); ax_fit.grid(True, ls=':', alpha=0.7)

        if fitnesses and population: # Top 5 Fitness
            ax_top = self.axes_dynamic[1,0]; sorted_indices = np.argsort(fitnesses)[::-1]; top_n = min(5, len(population))
            top_fits = [fitnesses[i] for i in sorted_indices[:top_n]]
            paths_lens = [len(population[i]) for i in sorted_indices[:top_n]]
            bar_labels = [f'#{i+1}\n(L:{paths_lens[i]})' for i in range(top_n)]
            bars = ax_top.bar(range(top_n), top_fits, color=sns.color_palette("coolwarm", n_colors=top_n))
            ax_top.set_xticks(range(top_n)); ax_top.set_xticklabels(bar_labels, fontsize=8)
            ax_top.set_xlabel('Ranking (Longitud)'); ax_top.set_ylabel('Fitness'); ax_top.grid(axis='y', ls=':', alpha=0.7)
            for bar_idx, bar in enumerate(bars): ax_top.text(bar.get_x() + bar.get_width()/2., bar.get_height(), f'{top_fits[bar_idx]:.0f}', ha='center', va='bottom', fontsize=8)

        if len(self.diversity_history) > 1: # Diversidad
            ax_div = self.axes_dynamic[1,1]; ax_div.plot(range(len(self.diversity_history)), self.diversity_history, 'r-', lw=2, label='Diversidad')
            ax_div.set_xlabel('Generación'); ax_div.set_ylabel('Diversidad (Jaccard)'); ax_div.grid(True, ls=':', alpha=0.7); ax_div.set_ylim(0, 1)
            if self.use_adaptive_mutation and len(self.mutation_rate_history) > 1:
                ax_mut = ax_div.twinx(); ax_mut.plot(range(len(self.mutation_rate_history)), self.mutation_rate_history, 'm:', lw=1.5, label='Tasa Mut.')
                ax_mut.set_ylabel('Tasa Mutación', color='m'); ax_mut.tick_params(axis='y', labelcolor='m')
                lines, labels = ax_div.get_legend_handles_labels(); lines2, labels2 = ax_mut.get_legend_handles_labels()
                ax_div.legend(lines + lines2, labels + labels2, loc='best', fontsize='small')

        ax_stats = self.axes_dynamic[1,2]; ax_stats.axis('off') # Estadísticas
        if fitnesses and population:
            time_gen_str = f"T/Gen: {self.generation_times[-1]:.3f}s" if self.generation_times else "N/A"; stag_str = f"Estanc: {self.generations_since_last_improvement}/{self.stagnation_limit}"
            current_diversity_val = self.diversity_history[-1] if self.diversity_history else "N/A"; div_display_str = f"{current_diversity_val:.3f}" if isinstance(current_diversity_val, float) else current_diversity_val
            mut_rate_str = f"MutR: {self.mutation_rate:.3f}" if self.use_adaptive_mutation else ""
            best_path_len_str = f"Mejor L: {len(self.best_path)}" if self.best_path else "N/A"
            stats_text = (f"Gen: {self.current_generation}/{self.max_generations} ({stag_str})\nPob: {len(population)}\nMejor Fit: {self.best_fitness:.0f}\n{best_path_len_str}\nDiv: {div_display_str} {mut_rate_str}\n{time_gen_str}")
        else: stats_text = "Calculando..."
        ax_stats.text(0.05, 0.95, stats_text, transform=ax_stats.transAxes, fontsize=9, va='top', fontfamily='monospace', bbox=dict(boxstyle="round,pad=0.3", fc="#eef", alpha=0.8))

        plt.tight_layout(rect=[0, 0, 1, 0.95]); display(self.fig_dynamic)

    def evolve(self, verbose=True): # MÉTODO EVOLVE PRINCIPAL
        if self.animate: self.setup_dynamic_visualization()

        self.mutation_rate = self.initial_mutation_rate
        population = self.create_population()
        fitnesses = [self.fitness(ind) for ind in population]

        best_idx_current_gen = np.argmax(fitnesses)
        self.best_fitness = fitnesses[best_idx_current_gen]
        self.best_path = population[best_idx_current_gen][:]

        self.best_fitness_history.append(self.best_fitness)
        self.avg_fitness_history.append(np.mean([f for f in fitnesses if f > -100000])) # Evitar inválidos en promedio
        self.diversity_history.append(self.calculate_diversity(population))
        if self.use_adaptive_mutation: self.mutation_rate_history.append(self.mutation_rate)
        if verbose: print(f"Gen 0: MejorFit={self.best_fitness:.0f}, Len={len(self.best_path)}, MutR={self.mutation_rate:.3f}")

        if self.animate: self.update_dynamic_visualization(population, fitnesses); time.sleep(0.1)

        for generation in range(1, self.max_generations + 1):
            self.current_generation = generation; start_time_gen = time.time()
            self.generations_since_last_reset += 1

            parents = self.selection(population, fitnesses)

            elite_indices = np.argsort(fitnesses)[-self.elite_size:]
            next_population = [population[i][:] for i in elite_indices]

            if self.use_local_search and \
               (generation % APPLY_LOCAL_SEARCH_EVERY_N_GENS == 0 or \
                (self.generations_since_last_improvement > self.stagnation_limit // 2 and \
                 random.random() < PROB_APPLY_LOCAL_SEARCH_TO_ELITE)):
                if verbose and generation > 0: print(f"  LS: Aplicando búsqueda local a élite gen {generation}")
                for i in range(len(next_population)):
                    next_population[i] = self.local_search(next_population[i]) # Usar local_search

            children_needed = self.population_size - len(next_population)
            children_created = 0
            while children_created < children_needed :
                p1, p2 = random.sample(parents, 2)
                c1, c2 = self.crossover(p1, p2)
                next_population.append(self.mutate(c1)); children_created +=1
                if children_created < children_needed:
                    next_population.append(self.mutate(c2)); children_created +=1

            population = next_population[:self.population_size]
            fitnesses = [self.fitness(ind) for ind in population]

            best_idx_current_gen = np.argmax(fitnesses)
            current_gen_best_fitness = fitnesses[best_idx_current_gen]

            if current_gen_best_fitness > self.best_fitness:
                self.best_fitness = current_gen_best_fitness
                self.best_path = population[best_idx_current_gen][:]
                self.generations_since_last_improvement = 0
                if verbose: print(f"✨ Gen {generation}: MejorFit={self.best_fitness:.0f}, Len={len(self.best_path)}")
                if self.best_path[-1] == self.maze_env.end_pos: # Solución encontrada
                    if verbose: print(f"🎉 SOLUCIÓN ENCONTRADA en gen {generation}!")
                    if self.animate: self.update_dynamic_visualization(population, fitnesses)
                    # Podrías añadir un criterio de parada aquí si se encuentra la solución
                    # return self.best_path, self.best_fitness
            else:
                self.generations_since_last_improvement += 1

            current_diversity = self.calculate_diversity(population)
            self.diversity_history.append(current_diversity)

            if self.use_adaptive_mutation:
                if current_diversity < ADAPTIVE_MUT_LOW_DIVERSITY_THRESHOLD and self.mutation_rate < MAX_MUTATION_RATE:
                    self.mutation_rate = min(MAX_MUTATION_RATE, self.mutation_rate * MUTATION_ADAPT_FACTOR_INCREASE)
                elif self.mutation_rate > self.initial_mutation_rate and self.generations_since_last_improvement < 10:
                    self.mutation_rate = max(self.initial_mutation_rate, self.mutation_rate * MUTATION_ADAPT_FACTOR_DECREASE)
                self.mutation_rate_history.append(self.mutation_rate)

            self.best_fitness_history.append(self.best_fitness)
            self.avg_fitness_history.append(np.mean([f for f in fitnesses if f > -100000]))
            self.generation_times.append(time.time() - start_time_gen)

            if self.use_population_reset and \
               self.generations_since_last_improvement > STAGNATION_FOR_RESET and \
               self.generations_since_last_reset > STAGNATION_FOR_RESET :
                if verbose: print(f"  RESET: Reseteo parcial gen {generation}.")
                num_to_reset = int(self.population_size * RESET_FRACTION)
                elite_now = [population[i][:] for i in np.argsort(fitnesses)[-self.elite_size:]]
                reset_pop = elite_now
                for _ in range(self.population_size - len(reset_pop)): # Rellenar
                    reset_pop.append(self.create_individual())
                population = reset_pop[:self.population_size]
                fitnesses = [self.fitness(ind) for ind in population]
                self.generations_since_last_reset = 0
                self.diversity_history[-1] = self.calculate_diversity(population)
                if self.use_adaptive_mutation: self.mutation_rate = self.initial_mutation_rate; self.mutation_rate_history[-1] = self.mutation_rate

            if self.animate and (generation % 2 == 0 or generation == self.max_generations or self.generations_since_last_improvement >= self.stagnation_limit-1 or (self.best_path and self.best_path[-1] == self.maze_env.end_pos)):
                self.update_dynamic_visualization(population, fitnesses)

            if self.best_path and self.best_path[-1] == self.maze_env.end_pos and self.generations_since_last_improvement > 10: # Si encontró solución y no mejora más
                if verbose: print(f"Solución encontrada y estable. Terminando en gen {generation}.")
                break

            if self.generations_since_last_improvement >= self.stagnation_limit:
                if verbose: print(f"Estancamiento gen {generation}. Sin mejora {self.stagnation_limit} gens.")
                if self.animate and self.fig_dynamic: self.fig_dynamic.suptitle(f'ESTANCAMIENTO (Gen {generation})', fontsize=16, color='red', fontweight='bold'); display(self.fig_dynamic)
                break

            if verbose and (generation % 10 == 0 or generation == self.max_generations):
                 div_str = f"{self.diversity_history[-1]:.3f}" if self.diversity_history else "N/A"
                 mut_str = f"MutR:{self.mutation_rate:.3f}" if self.use_adaptive_mutation else ""
                 print(f"Gen {generation:3d}: BestFit={self.best_fitness:.0f} (L:{len(self.best_path) if self.best_path else 'N/A'}) AvgFit={self.avg_fitness_history[-1]:.0f} Div={div_str} {mut_str} Stagn={self.generations_since_last_improvement}")

        if verbose: print(f"Evolución finalizada. Mejor Fitness: {self.best_fitness:.2f}, Longitud del camino: {len(self.best_path) if self.best_path else 'N/A'}")
        return self.best_path, self.best_fitness

# --- Ejemplo de Uso ---
if __name__ == '__main__': # Para ejecutar como script, o quitar para celda de Colab
    # Definir un laberinto (0 = camino, 1 = pared)
    maze_data = [
        [0, 1, 0, 0, 0, 1, 0, 0, 0, 0],
        [0, 1, 0, 1, 0, 1, 0, 1, 1, 0],
        [0, 0, 0, 1, 0, 0, 0, 1, 0, 0],
        [0, 1, 1, 1, 1, 1, 0, 1, 0, 1],
        [0, 0, 0, 0, 0, 1, 0, 0, 0, 0],
        [1, 1, 1, 1, 0, 1, 1, 1, 1, 0],
        [0, 0, 0, 1, 0, 0, 0, 0, 1, 0],
        [0, 1, 0, 1, 0, 1, 0, 1, 1, 0],
        [0, 1, 0, 0, 0, 1, 0, 0, 0, 0],
        [0, 0, 0, 1, 1, 1, 1, 1, 1, 0]
    ]
    start = (0,0)
    end = (9,9)

    # maze_data = [ # Laberinto más pequeño
    #     [0,0,0,1,0],
    #     [0,1,0,0,0],
    #     [0,1,1,1,0],
    #     [0,0,0,0,0],
    # ]
    # start = (0,0)
    # end = (3,4)


    maze_env = MazeEnvironment(maze_data, start, end)

    # Parámetros del AG
    ga_params = {
        'population_size': 150,
        'elite_size': 25,
        'initial_mutation_rate': 0.10,
        'crossover_rate': 0.85,
        'max_generations': 100, # Reducir para pruebas rápidas
        'animate': True,
        'stagnation_limit': 30,
        'random_seed': 42,
        'use_adaptive_mutation': True,
        'use_population_reset': True,
        'use_local_search': True,
        'max_path_len_factor': 2.0 # Permitir caminos más largos inicialmente
    }

    solver = GeneticMazeSolver(maze_env, **ga_params)

    print("Iniciando solucionador genético de laberintos...")
    best_path_found, best_fitness_found = solver.evolve(verbose=True)

    if best_path_found:
        print(f"\nMejor camino encontrado (Fitness: {best_fitness_found:.2f}):")
        # print(best_path_found)
        print(f"Longitud del camino: {len(best_path_found)}")
        if best_path_found[-1] == maze_env.end_pos:
            print("¡El camino LLEGA al objetivo!")
        else:
            print("El camino NO LLEGA al objetivo.")
            print(f"Última posición: {best_path_found[-1]}, Objetivo: {maze_env.end_pos}")


        # Visualización final estática si no hubo animación o para tenerla aparte
        if not ga_params['animate'] or (solver.fig_dynamic is None):
            fig_final, ax_final = plt.subplots(figsize=(8,8))
            solver.draw_path(ax_final, best_path_found, color='red', lw=3)
            ax_final.set_title(f"Mejor Camino Encontrado (Fitness: {best_fitness_found:.0f}, Longitud: {len(best_path_found)})")
            plt.show()
    else:
        print("No se encontró ningún camino.")



# Importar las funciones necesarias de IPython para mostrar HTML
from IPython.core.display import display, HTML

# Definir el contenido HTML, CSS y JavaScript como un string multilínea
html_content = """
<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>AlphaEvolve: Descubrimiento Científico y Algorítmico</title>
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&family=Lora:ital,wght@0,400;0,700&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg-color: #f8f9fa;
      --text-color: #343a40;
      --header-color: #0056b3;
      --header-dark-color: #90c5ff;
      --accent-color: #28a745;
      --accent-dark-color: #73c888;
      --button-bg: #007bff;
      --button-hover-bg: #0056b3;
      --button-dark-bg: #ff8c00;
      --button-dark-hover-bg: #cc7000;
      --button-text-color: white;
      --theme-button-bg: #6c757d;
      --theme-button-dark-bg: #ffc107;
      --content-panel-bg: #e9ecef;
      --content-panel-dark-bg: #495057;
      --section-title-color: var(--header-color);
      --section-title-dark-color: var(--header-dark-color);
      --panel-label-color: var(--accent-color);
      --panel-label-dark-color: var(--accent-dark-color);
      --icon-color: var(--accent-color);
      --icon-dark-color: var(--accent-dark-color);
    }

    body {
      font-family: 'Lora', 'Roboto', serif;
      line-height: 1.8;
      background-color: var(--bg-color);
      color: var(--text-color);
      transition: background-color 0.3s, color 0.3s;
      padding: 20px;
      margin: 0;
    }
    .container {
      max-width: 1000px;
      margin: auto;
      padding: 25px;
      position: relative;
      background-color: var(--bg-color); /* Hereda del body para transiciones */
      border-radius: 8px;
      box-shadow: 0 3px 8px rgba(0,0,0,0.06);
    }
    body.dark-mode .container {
        box-shadow: 0 3px 10px rgba(0,0,0,0.2);
    }
    body.dark-mode {
      --bg-color: #343a40;
      --text-color: #f8f9fa;
      --header-color: var(--header-dark-color);
      --accent-color: var(--accent-dark-color);
      --button-bg: var(--button-dark-bg);
      --button-hover-bg: var(--button-dark-hover-bg);
      --content-panel-bg: var(--content-panel-dark-bg);
      --section-title-color: var(--section-title-dark-color);
      --panel-label-color: var(--panel-label-dark-color);
      --icon-color: var(--icon-dark-color);
    }

    h1 {
      font-family: 'Roboto', sans-serif;
      font-size: 2.4em;
      color: var(--header-color);
      text-align: center;
      margin-bottom: 30px;
    }
    h2.section-group-title {
        font-family: 'Roboto', sans-serif;
        font-size: 1.6em;
        color: var(--accent-color);
        margin-top: 35px;
        margin-bottom: 10px;
        border-bottom: 2px solid var(--accent-color);
        padding-bottom: 5px;
    }

    .content-panel {
      max-height: 0;
      overflow: hidden;
      transition: max-height 0.4s ease-out, padding 0.4s ease-out;
      margin-top: 0;
      padding: 0 25px; /* Se aplica cuando está visible */
      border-left: 4px solid var(--accent-color);
      background-color: var(--content-panel-bg);
      border-radius: 0 0 6px 6px;
    }
    .content-panel.is-visible {
      max-height: 5000px; /* Un valor grande para acomodar contenido variable */
      padding: 20px 25px;
    }
    .content-panel p, .content-panel ul, .content-panel ol {
        margin-bottom: 1.2em;
        font-size: 1.0em;
    }
    .content-panel strong.panel-label {
        color: var(--panel-label-color);
        font-family: 'Roboto', sans-serif;
        font-size: 1.1em;
        display: block;
        margin-bottom: 0.5em;
    }
    .content-panel h3 {
        font-family: 'Roboto', sans-serif;
        color: var(--section-title-color);
        font-size: 1.3em;
        margin-top: 1.5em;
        margin-bottom: 0.7em;
    }


    .section-toggle-button {
      background-color: var(--button-bg);
      color: var(--button-text-color);
      border: none;
      padding: 14px 20px;
      border-radius: 6px;
      cursor: pointer;
      margin-top: 10px;
      transition: background-color 0.3s, border-radius 0.2s;
      width: 100%;
      text-align: left;
      font-family: 'Roboto', sans-serif;
      font-size: 1.1em;
      font-weight: 700;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }
    .section-toggle-button:hover {
      background-color: var(--button-hover-bg);
    }
    .section-toggle-button.is-expanded {
        border-radius: 6px 6px 0 0;
    }
    .section-toggle-button .icon {
        margin-right: 10px;
        font-size: 0.9em;
        color: var(--button-text-color); /* Ajustado para contraste con botón */
        transition: transform 0.3s ease-out;
    }
    .section-toggle-button.is-expanded .icon {
        transform: rotate(90deg);
    }


    .theme-toggle {
      background-color: var(--theme-button-bg);
      color: white;
      border: none;
      padding: 10px 15px;
      border-radius: 6px;
      cursor: pointer;
      position: absolute;
      top: 25px;
      right: 25px;
      font-size: 0.9em;
      font-family: 'Roboto', sans-serif;
      transition: background-color 0.3s;
      z-index: 10;
    }
    body.dark-mode .theme-toggle {
       background-color: var(--theme-button-dark-bg);
       color: var(--text-color); /* Para contraste en modo oscuro */
    }

    button:focus, a:focus {
        outline: 2px solid var(--accent-color);
        outline-offset: 3px;
    }
    body.dark-mode button:focus, body.dark-mode a:focus {
         outline-color: var(--accent-dark-color);
    }
    ul, ol {
        padding-left: 30px;
    }
    li {
        margin-bottom: 0.7em;
    }
    strong {
        font-weight: 700;
    }
    code {
      background-color: rgba(0,0,0,0.05);
      padding: 2px 5px;
      border-radius: 4px;
      font-family: 'Courier New', Courier, monospace;
    }
    body.dark-mode code {
      background-color: rgba(255,255,255,0.1);
    }
  </style>
</head>
<body>
  <div class="container">
    <button id="theme-toggle-btn" class="theme-toggle" onclick="toggleTheme()" title="Cambiar tema de color">Modo Oscuro</button>

    <h1>AlphaEvolve: Un Agente de Evolución de Código para el Descubrimiento Científico y Algorítmico</h1>

    <!-- Introducción -->
    <button class="section-toggle-button" onclick="toggleSection('s0', this)" aria-expanded="false" aria-controls="s0">
      <span>Introducción</span><span class="icon">►</span>
    </button>
    <div id="s0" class="content-panel">
      <p>El desarrollo de nuevos conocimientos científicos y la creación de algoritmos cada vez más eficientes representan desafíos cruciales y persistentes en la computación moderna y la investigación científica. AlphaEvolve, una innovadora propuesta de Google DeepMind, emerge como una herramienta de vanguardia que marca un avance significativo en este campo. Su poder reside en la <strong>sinergia entre modelos de lenguaje de gran escala (LLMs) de última generación y robustas técnicas de computación evolutiva</strong>, orientadas a la automatización de la mejora y el descubrimiento de código. Este sistema no solo refina algoritmos existentes, sino que tiene la capacidad de generar soluciones algorítmicas novedosas, posicionándose como un agente de descubrimiento con un potencial transformador. AlphaEvolve está específicamente diseñado para acometer tareas de una complejidad excepcional, que abarcan desde la optimización de componentes críticos en infraestructuras computacionales a gran escala hasta la resolución de problemas abiertos y de larga data en las matemáticas puras y las ciencias computacionales aplicadas.</p>
    </div>

    <h2 class="section-group-title">Metodología de AlphaEvolve: Un Ecosistema de Inteligencia Artificial</h2>
    <p>La arquitectura de AlphaEvolve es un sofisticado entramado de módulos que operan de forma coordinada y, crucialmente, asincrónica, permitiendo un alto rendimiento y paralelización. Su núcleo metodológico se fundamenta en un algoritmo evolutivo que, a través de un proceso iterativo de generaciones, busca y refina programas para una tarea específica, partiendo de un código inicial que puede ser incluso rudimentario.</p>

    <button class="section-toggle-button" onclick="toggleSection('s1', this)" aria-expanded="false" aria-controls="s1">
      <span>1. Estructura del Sistema y Flujo Evolutivo</span><span class="icon">►</span>
    </button>
    <div id="s1" class="content-panel">
      <p><strong class="panel-label">Detalle:</strong></p>
      <p>AlphaEvolve opera como un ecosistema autónomo. El proceso inicia con un programa base proporcionado por el usuario, junto con criterios de evaluación. Los componentes clave incluyen:</p>
      <ul>
        <li><strong>Controlador Distribuido:</strong> Orquesta el bucle evolutivo, gestionando la comunicación entre los diferentes módulos.</li>
        <li><strong>Muestreador de Prompts (Prompt Sampler):</strong> Construye prompts ricos y contextualizados para los LLMs, utilizando programas de la base de datos y otras informaciones relevantes.</li>
        <li><strong>Ensamblaje de LLMs (LLMs Ensemble):</strong> Un conjunto de modelos de lenguaje (como Gemini 2.0 Pro y Gemini 2.0 Flash) que generan modificaciones de código (diffs).</li>
        <li><strong>Aplicador de Diffs:</strong> Integra las modificaciones propuestas en nuevas versiones del código.</li>
        <li><strong>Grupo de Evaluadores (Evaluators Pool):</strong> Ejecuta una función <code>evaluate</code> definida por el usuario. Esta función, típicamente implementada en Python, asigna una o varias puntuaciones escalares a la solución generada, cuantificando su calidad.</li>
        <li><strong>Base de Datos de Programas (Program Database):</strong> Almacena las soluciones prometedoras junto con sus puntuaciones y otros metadatos, sirviendo como memoria evolutiva.</li>
      </ul>
      <p>El ciclo evolutivo es continuo: se seleccionan programas "padre", se generan prompts, los LLMs proponen cambios, se crean programas "hijo", se evalúan, y los mejores se reincorporan a la base de datos, fomentando una mejora iterativa.</p>
    </div>

    <button class="section-toggle-button" onclick="toggleSection('s2', this)" aria-expanded="false" aria-controls="s2">
      <span>2. Evolución del Código a Gran Escala y Flexibilidad Lingüística</span><span class="icon">►</span>
    </button>
    <div id="s2" class="content-panel">
      <p><strong class="panel-label">Detalle:</strong></p>
      <p>A diferencia de sistemas evolutivos anteriores como FunSearch, que se centraban en la evolución de funciones pequeñas y aisladas (usualmente en Python y de pocas líneas), AlphaEvolve está diseñado para operar sobre <strong>archivos de código completos</strong> y puede trabajar con <strong>diversos lenguajes de programación</strong>. El usuario puede anotar bloques específicos de código mediante comentarios especiales (<code># EVOLVE-BLOCK-START</code> y <code># EVOLVE-BLOCK-END</code>), indicando las secciones que el sistema debe intentar mejorar. Esto permite una integración flexible con bases de código existentes. Además, AlphaEvolve ofrece flexibilidad en la <em>abstracción</em> de la solución: puede evolucionar representaciones de cadenas crudas, funciones constructoras (útiles para soluciones simétricas), algoritmos de búsqueda a medida, o incluso co-evolucionar soluciones intermedias junto con los algoritmos que las encuentran.</p>
    </div>

    <button class="section-toggle-button" onclick="toggleSection('s3', this)" aria-expanded="false" aria-controls="s3">
      <span>3. Generación de Código Inteligente y Evaluación Multifacética</span><span class="icon">►</span>
    </button>
    <div id="s3" class="content-panel">
      <p><strong class="panel-label">Detalle:</strong></p>
      <p>La generación de código es impulsada por un ensamblaje de LLMs, donde modelos más rápidos como Gemini 2.0 Flash permiten una alta tasa de generación de candidatos, mientras que modelos más potentes como Gemini 2.0 Pro aportan sugerencias de mayor calidad que pueden conducir a avances significativos. Los LLMs proponen cambios en un formato de "diff" (ej. <code><<<<<<< SEARCH ... ======= ... >>>>>>> REPLACE</code>), lo que permite actualizaciones específicas y dirigidas, aunque también pueden reescribir bloques enteros si es necesario.</p>
      <p>La evaluación es automática y altamente configurable:</p>
      <ul>
        <li><strong>Métricas Múltiples:</strong> AlphaEvolve puede optimizar simultáneamente varias métricas (eficiencia, simplicidad, rendimiento bajo diferentes escenarios). Esto es crucial, ya que programas que sobresalen en diferentes criterios a menudo poseen estructuras lógicas distintas, enriqueciendo la diversidad de la población evolutiva.</li>
        <li><strong>Cascada de Evaluación (Pruebas de Hipótesis):</strong> Se pueden especificar conjuntos de casos de prueba de dificultad creciente. Las nuevas soluciones solo avanzan a la siguiente etapa si superan las anteriores, podando rápidamente las ramas menos prometedoras y ahorrando recursos computacionales.</li>
        <li><strong>Retroalimentación Generada por LLM:</strong> Para características deseables difíciles de capturar en una función de evaluación programática (ej. simplicidad del código), se pueden usar LLMs adicionales para calificar estos aspectos.</li>
        <li><strong>Evaluación Paralelizada:</strong> El sistema puede distribuir la evaluación de soluciones a través de un clúster, vital cuando la función <code>evaluate</code> es computacionalmente costosa.</li>
      </ul>
    </div>

    <button class="section-toggle-button" onclick="toggleSection('s4', this)" aria-expanded="false" aria-controls="s4">
      <span>4. Aprovechamiento Avanzado del Contexto y Meta-Prompts Dinámicos</span><span class="icon">►</span>
    </button>
    <div id="s4" class="content-panel">
      <p><strong class="panel-label">Detalle:</strong></p>
      <p>La efectividad de los LLMs SOTA (State-Of-The-Art) se ve potenciada por la calidad y riqueza del contexto proporcionado. AlphaEvolve sobresale en esto mediante:</p>
      <ul>
        <li><strong>Contexto Explícito:</strong> Incorpora en los prompts detalles sobre el problema, instrucciones humanas, ecuaciones relevantes, fragmentos de código ejemplares, e incluso literatura científica (ej. archivos PDF).</li>
        <li><strong>Formato Estocástico:</strong> Utiliza plantillas con alternativas proporcionadas por humanos, instanciadas probabilísticamente para aumentar la diversidad de los prompts.</li>
        <li><strong>Resultados de Evaluación Renderizados:</strong> Incluye en el prompt el código de soluciones previas exitosas y sus puntuaciones, permitiendo al LLM "aprender" de los éxitos y fracasos pasados.</li>
        <li><strong>Evolución de Meta-Prompts:</strong> De forma notable, AlphaEvolve puede co-evolucionar las propias instrucciones y el contexto que se proporciona a los LLMs. Estas "meta-instrucciones" se almacenan y evolucionan en una base de datos separada, permitiendo que el sistema aprenda a "pedir mejor" con el tiempo.</li>
      </ul>
    </div>

    <button class="section-toggle-button" onclick="toggleSection('s5', this)" aria-expanded="false" aria-controls="s5">
      <span>5. Base de Datos Evolutiva y Estrategias de Selección Avanzadas</span><span class="icon">►</span>
    </button>
    <div id="s5" class="content-panel">
      <p><strong class="panel-label">Detalle:</strong></p>
      <p>Las soluciones generadas y evaluadas se almacenan en una base de datos evolutiva. El objetivo principal de esta base de datos es <strong>resurgir óptimamente ideas exploradas previamente</strong> para guiar las generaciones futuras. Un desafío clave es equilibrar la <em>explotación</em> (refinar las mejores soluciones conocidas) y la <em>exploración</em> (mantener la diversidad para descubrir nuevas regiones del espacio de búsqueda). AlphaEvolve implementa un algoritmo de base de datos inspirado en una combinación del algoritmo MAP-Elites (que mapea soluciones a un espacio de características para mantener la diversidad) y modelos de población basados en islas (que fomentan la evolución de nichos especializados).</p>
    </div>

    <h2 class="section-group-title">Aplicaciones y Resultados Transformadores</h2>
    <p>AlphaEvolve ha demostrado su capacidad en una variedad de dominios, produciendo resultados que no solo igualan sino que superan el estado del arte.</p>

    <button class="section-toggle-button" onclick="toggleSection('s6', this)" aria-expanded="false" aria-controls="s6">
      <span>1. Descubrimiento de Algoritmos de Multiplicación de Matrices</span><span class="icon">►</span>
    </button>
    <div id="s6" class="content-panel">
      <p><strong class="panel-label">Detalle:</strong></p>
      <p>En el fundamental problema de encontrar algoritmos rápidos para la multiplicación de matrices, AlphaEvolve logró un hito histórico. Para la multiplicación de matrices 4×4 de valores complejos, descubrió un algoritmo que requiere solo <strong>48 multiplicaciones escalares</strong>. Esto representa la primera mejora sobre el algoritmo recursivo de Strassen (que necesita 49 en este caso) en más de 50 años para este tipo de matrices. Mejoró el estado del arte para 14 tamaños de matrices diferentes. El sistema fue guiado para encontrar soluciones exactas mediante la inclusión de un paso de redondeo en la evaluación y una solicitud en lenguaje natural en el prompt para generar soluciones casi enteras.</p>
    </div>

    <button class="section-toggle-button" onclick="toggleSection('s7', this)" aria-expanded="false" aria-controls="s7">
      <span>2. Resolución de Problemas Matemáticos Abiertos</span><span class="icon">►</span>
    </button>
    <div id="s7" class="content-panel">
      <p><strong class="panel-label">Detalle:</strong></p>
      <p>Aplicado a más de 50 problemas abiertos en cinco ramas distintas de las matemáticas puras (análisis, combinatoria, teoría de números, geometría), AlphaEvolve demostró ser una herramienta de investigación polifacética:</p>
      <ul>
        <li>Igualó las mejores construcciones conocidas en aproximadamente el 75% de los casos.</li>
        <li>Descubrió <strong>nuevas construcciones, demostrablemente mejores</strong>, que superan el estado del arte en el 20% de los problemas.</li>
        <li>Entre los éxitos se incluyen mejoras en el problema del Número Besador (Kissing Numbers) en 11 dimensiones (encontrando una configuración de 593 esferas), el problema de mínimo solapamiento de Erdős, desigualdades de autocorrelación y principios de incertidumbre, y diversos problemas de empaquetamiento geométrico (como variantes del problema de Heilbronn y empaquetamiento de hexágonos).</li>
        <li>Notablemente, para muchos de estos problemas, AlphaEvolve evolucionó <em>algoritmos de búsqueda heurística</em> en lugar de las construcciones directamente, demostrando una capacidad de meta-aprendizaje.</li>
      </ul>
    </div>

    <button class="section-toggle-button" onclick="toggleSection('s8', this)" aria-expanded="false" aria-controls="s8">
      <span>3. Optimización de Infraestructura Computacional Crítica en Google</span><span class="icon">►</span>
    </button>
    <div id="s8" class="content-panel">
      <p><strong class="panel-label">Detalle:</strong></p>
      <p>AlphaEvolve ha generado un impacto práctico tangible en los sistemas de Google:</p>
      <ul>
        <li><strong>Mejora de Scheduling en Centros de Datos (Borg):</strong> Descubrió una función heurística simple pero efectiva para asignar trabajos a máquinas, logrando una <strong>recuperación promedio del 0.7% de los recursos computacionales</strong> a lo largo de toda la flota de Google, que de otro modo quedarían varados. Esta solución fue preferida sobre enfoques de aprendizaje profundo (DRL) por su interpretabilidad, depurabilidad y facilidad de despliegue.</li>
        <li><strong>Aceleración de Kernels de Entrenamiento para Gemini (JAX/Pallas):</strong> Optimizó las heurísticas de "tiling" (división de cómputo en bloques) para un kernel de multiplicación de matrices crucial en el entrenamiento del modelo Gemini. Esto resultó en una <strong>reducción promedio del 23% en el tiempo de ejecución del kernel</strong> y una disminución del 1% en el tiempo total de entrenamiento de Gemini, reduciendo además el tiempo de optimización del kernel de meses a días. Un caso de IA optimizándose a sí misma.</li>
        <li><strong>Optimización de Diseño de Circuitos de Hardware (TPUs):</strong> Se utilizó para refinar una implementación en Verilog de un circuito aritmético clave en la unidad de multiplicación de matrices de las TPUs. Propuso una reescritura de código simple que eliminaba bits innecesarios, reduciendo área y consumo energético. Aunque esta mejora específica también fue detectada por herramientas de síntesis posteriores, la contribución de AlphaEvolve en la etapa de RTL (Register-Transfer Level) demuestra su potencial para optimizaciones tempranas en el flujo de diseño.</li>
        <li><strong>Refinamiento de Código Compilado (XLA IR para FlashAttention):</strong> Optimizó directamente las Representaciones Intermedias (IRs) generadas por el compilador XLA para el kernel de FlashAttention. A pesar de que este código ya está altamente optimizado y el IR está diseñado para depuración más que para edición directa, AlphaEvolve logró una <strong>aceleración del 32% en el kernel de FlashAttention</strong> y una mejora del 15% en el código de pre y post-procesamiento asociado.</li>
      </ul>
    </div>

    <h2 class="section-group-title">Comparación y Perspectivas</h2>

    <button class="section-toggle-button" onclick="toggleSection('s9', this)" aria-expanded="false" aria-controls="s9">
      <span>Comparación con Enfoques Anteriores (FunSearch)</span><span class="icon">►</span>
    </button>
    <div id="s9" class="content-panel">
      <p><strong class="panel-label">Detalle:</strong></p>
      <p>AlphaEvolve se basa en el legado de FunSearch pero lo expande significativamente:</p>
      <ul>
        <li><strong>Escala y Lenguaje:</strong> FunSearch evolucionaba una única función Python de pocas líneas; AlphaEvolve maneja archivos de código completos en múltiples lenguajes.</li>
        <li><strong>Modelos y Contexto:</strong> FunSearch usaba LLMs más pequeños y un contexto mínimo; AlphaEvolve emplea SOTA LLMs (Gemini Pro/Flash) con un contexto rico y dinámico, incluyendo meta-prompts.</li>
        <li><strong>Objetivos:</strong> FunSearch optimizaba una única métrica; AlphaEvolve maneja optimización multiobjetivo.</li>
        <li><strong>Generalidad:</strong> Estas extensiones permiten a AlphaEvolve abordar problemas mucho más desafiantes y de mayor impacto que no eran factibles para FunSearch.</li>
      </ul>
    </div>

    <button class="section-toggle-button" onclick="toggleSection('s10', this)" aria-expanded="false" aria-controls="s10">
      <span>Limitaciones y Discusión Futura</span><span class="icon">►</span>
    </button>
    <div id="s10" class="content-panel">
      <p><strong class="panel-label">Detalle:</strong></p>
      <p>La principal limitación actual de AlphaEvolve es su <strong>dependencia de un evaluador automático robusto</strong>. Si bien esto es común en matemáticas y ciencias de la computación, dominios como las ciencias naturales a menudo requieren experimentación física. Aunque el sistema permite la evaluación de ideas proporcionada por LLMs, este no es su modo optimizado.</p>
      <p>El futuro de AlphaEvolve es prometedor:</p>
      <ul>
        <li><strong>Destilación:</strong> Se explorará la posibilidad de destilar el rendimiento mejorado de AlphaEvolve de nuevo en las futuras generaciones de los modelos LLM base.</li>
        <li><strong>Expansión de Entornos:</strong> Aumentar el número de problemas (entornos) con funciones de evaluación robustas impulsará más descubrimientos de alto valor.</li>
        <li><strong>Integración con Razonamiento de Alto Nivel:</strong> Se contempla la posibilidad de conectar AlphaEvolve con sistemas que proporcionen retroalimentación de alto nivel (como un "AI Co-Scientist") antes de la etapa de implementación y evaluación de código, combinando el razonamiento abstracto con la optimización concreta.</li>
      </ul>
    </div>

    <button class="section-toggle-button" onclick="toggleSection('s11', this)" aria-expanded="false" aria-controls="s11">
      <span>Conclusión</span><span class="icon">►</span>
    </button>
    <div id="s11" class="content-panel">
      <p><strong class="panel-label">Detalle:</strong></p>
      <p>AlphaEvolve no es simplemente una herramienta de optimización de código; es un <strong>agente de descubrimiento algorítmico y científico</strong>. Al combinar de manera ingeniosa la capacidad de generación de los LLMs con la búsqueda dirigida de los algoritmos evolutivos, ha demostrado una sorprendente capacidad para realizar descubrimientos en problemas matemáticos de larga data y para ofrecer mejoras prácticas y significativas en sistemas computacionales complejos. Su arquitectura flexible, su sofisticado manejo del contexto y su capacidad para aprender y adaptarse lo posicionan como un sistema con el potencial de acelerar drásticamente el ritmo de la innovación científica y la ingeniería algorítmica en los años venideros. Representa un paso firme hacia una nueva era donde la IA colabora activamente en la expansión de las fronteras del conocimiento.</p>
    </div>

  </div> <!-- Fin de .container -->

  <script>
    function toggleTheme() {
      document.body.classList.toggle("dark-mode");
      let themeButton = document.getElementById('theme-toggle-btn');
      let isDarkMode = document.body.classList.contains("dark-mode");
      localStorage.setItem("theme", isDarkMode ? "dark" : "light");
      if (themeButton) {
          themeButton.textContent = isDarkMode ? "Modo Claro" : "Modo Oscuro";
      }
    }

    function toggleSection(id, buttonElement) {
      let panel = document.getElementById(id);
      let icon = buttonElement.querySelector('.icon');
      if (panel && buttonElement) {
          panel.classList.toggle('is-visible');
          let isVisible = panel.classList.contains('is-visible');
          buttonElement.setAttribute('aria-expanded', isVisible);
          buttonElement.classList.toggle('is-expanded', isVisible);
          if (icon) {
              icon.textContent = isVisible ? '▼' : '►';
          }
      }
    }

    window.onload = function() {
      let themeButton = document.getElementById('theme-toggle-btn');
      const savedTheme = localStorage.getItem("theme");

      if (savedTheme === "dark") {
        document.body.classList.add("dark-mode");
        if (themeButton) {
            themeButton.textContent = "Modo Claro";
        }
      } else {
        document.body.classList.remove("dark-mode");
        if (themeButton) {
            themeButton.textContent = "Modo Oscuro";
        }
      }

       document.querySelectorAll('.content-panel').forEach(panel => {
         panel.classList.remove('is-visible');
         panel.style.maxHeight = '0'; // Asegurar que la animación empiece desde 0
       });
       document.querySelectorAll('.section-toggle-button').forEach(button => {
          button.setAttribute('aria-expanded', 'false');
          button.classList.remove('is-expanded');
          let icon = button.querySelector('.icon');
          if (icon) {
              icon.textContent = '►';
          }
       });
    }
  </script>
</body>
</html>
"""

# Mostrar el HTML en la salida de la celda
display(HTML(html_content))

# Importar las funciones necesarias de IPython para mostrar HTML
from IPython.core.display import display, HTML

# Definir el contenido HTML, CSS y JavaScript como un string multilínea
html_content = """
<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>FAQ: Algoritmos Genéticos y Aplicaciones Conceptuales</title>
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&family=Lora:ital,wght@0,400;0,700&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg-color: #f8f9fa;
      --text-color: #343a40;
      --header-color: #0056b3; /* Azul oscuro para títulos */
      --header-dark-color: #90c5ff; /* Azul claro para títulos en modo oscuro */
      --accent-color: #28a745; /* Verde para acentos */
      --accent-dark-color: #73c888; /* Verde claro para acentos en modo oscuro */
      --button-bg: #007bff; /* Azul primario */
      --button-hover-bg: #0056b3; /* Azul más oscuro */
      --button-dark-bg: #ff8c00; /* Naranja oscuro para modo oscuro */
      --button-dark-hover-bg: #cc7000; /* Naranja más oscuro */
      --button-text-color: white;
      --theme-button-bg: #6c757d; /* Gris secundario */
      --theme-button-dark-bg: #ffc107; /* Amarillo */
      --content-panel-bg: #e9ecef; /* Gris muy claro para paneles */
      --content-panel-dark-bg: #495057; /* Gris más oscuro para paneles */
      --panel-label-color: var(--accent-color);
      --panel-label-dark-color: var(--accent-dark-color);
      --icon-color: var(--button-text-color); /* Icono del mismo color que el texto del botón */
    }

    body {
      font-family: 'Lora', 'Roboto', serif;
      line-height: 1.8;
      background-color: var(--bg-color);
      color: var(--text-color);
      transition: background-color 0.3s, color 0.3s;
      padding: 20px;
      margin: 0;
    }
    .faq-container { /* Contenedor específico para estas FAQs */
      max-width: 950px;
      margin: auto;
      padding: 25px;
      position: relative;
      background-color: var(--bg-color);
      border-radius: 8px;
      box-shadow: 0 3px 10px rgba(0,0,0,0.07);
    }
    body.dark-mode .faq-container {
        box-shadow: 0 3px 12px rgba(0,0,0,0.25);
    }
    body.dark-mode {
      --bg-color: #2c3e50; /* Un azul oscuro más profundo para el fondo */
      --text-color: #ecf0f1; /* Un blanco grisáceo suave */
      --header-color: var(--header-dark-color);
      --accent-color: var(--accent-dark-color);
      --button-bg: var(--button-dark-bg);
      --button-hover-bg: var(--button-dark-hover-bg);
      --content-panel-bg: var(--content-panel-dark-bg);
      --panel-label-color: var(--panel-label-dark-color);
    }

    .faq-container h1 {
      font-family: 'Roboto', sans-serif;
      font-size: 2.3em;
      color: var(--header-color);
      text-align: center;
      margin-bottom: 25px;
      padding-bottom: 10px;
      border-bottom: 2px solid var(--accent-color);
    }
     .faq-container h2.section-group-title { /* Título para agrupar preguntas */
        font-family: 'Roboto', sans-serif;
        font-size: 1.6em;
        color: var(--accent-color);
        margin-top: 30px;
        margin-bottom: 5px;
        padding-bottom: 5px;
    }


    .content-panel {
      max-height: 0;
      overflow: hidden;
      transition: max-height 0.35s ease-in-out, padding-top 0.35s ease-in-out, padding-bottom 0.35s ease-in-out;
      margin-top: 0;
      padding: 0 22px; /* Se aplica cuando está visible, ajustado */
      border-left: 4px solid var(--accent-color);
      background-color: var(--content-panel-bg);
      border-radius: 0 0 6px 6px;
    }
    .content-panel.is-visible {
      max-height: 3500px; /* Ajustar según el contenido más largo esperado */
      padding-top: 18px;
      padding-bottom: 18px;
    }
    .content-panel p, .content-panel ul, .content-panel ol {
        margin-bottom: 1.1em;
        font-size: 1.0em; /* Ligeramente más pequeño para densidad */
    }
    .content-panel p:last-child, .content-panel ul:last-child, .content-panel ol:last-child {
        margin-bottom: 0;
    }
    .content-panel strong.panel-label {
        color: var(--panel-label-color);
        font-family: 'Roboto', sans-serif;
        font-size: 1.05em;
        display: block;
        margin-bottom: 0.6em;
    }


    .section-toggle-button {
      background-color: var(--button-bg);
      color: var(--button-text-color);
      border: none;
      padding: 13px 18px; /* Ligeramente ajustado */
      border-radius: 6px;
      cursor: pointer;
      margin-top: 8px; /* Más juntas las preguntas */
      transition: background-color 0.3s, border-radius 0.2s;
      width: 100%;
      text-align: left;
      font-family: 'Roboto', sans-serif;
      font-size: 1.05em; /* Ligeramente ajustado */
      font-weight: 700;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }
    .section-toggle-button:hover {
      background-color: var(--button-hover-bg);
    }
    .section-toggle-button.is-expanded {
        border-radius: 6px 6px 0 0;
    }
    .section-toggle-button .icon {
        margin-left: 10px;
        font-size: 0.85em;
        color: var(--icon-color);
        transition: transform 0.3s ease-out;
    }
    .section-toggle-button.is-expanded .icon {
        transform: rotate(90deg);
    }


    .theme-toggle-faq {
      background-color: var(--theme-button-bg);
      color: white;
      border: none;
      padding: 9px 14px;
      border-radius: 6px;
      cursor: pointer;
      position: absolute;
      top: 28px; /* Ajustado */
      right: 25px;
      font-size: 0.85em;
      font-family: 'Roboto', sans-serif;
      transition: background-color 0.3s;
      z-index: 100; /* Asegurar que esté encima */
    }
    body.dark-mode .theme-toggle-faq {
       background-color: var(--theme-button-dark-bg);
       color: var(--text-color);
    }

    button:focus, a:focus {
        outline: 2px solid var(--accent-color);
        outline-offset: 3px;
    }
    body.dark-mode button:focus, body.dark-mode a:focus {
         outline-color: var(--accent-dark-color);
    }
    ul, ol {
        padding-left: 25px; /* Ligeramente reducido */
    }
    li {
        margin-bottom: 0.6em;
    }
    strong {
        font-weight: 700;
    }
    code {
      background-color: rgba(0,0,0,0.04);
      padding: 2px 4px;
      border-radius: 3px;
      font-family: 'Courier New', Courier, monospace;
      font-size: 0.9em;
    }
    body.dark-mode code {
      background-color: rgba(255,255,255,0.08);
    }
  </style>
</head>
<body>
  <div class="faq-container">
    <button id="theme-toggle-faq-btn" class="theme-toggle-faq" onclick="toggleFaqTheme()" title="Cambiar tema de color">Modo Oscuro</button>

    <h1>Preguntas Frecuentes: Algoritmos Genéticos y Aplicaciones Conceptuales</h1>

    <h2 class="section-group-title">Fundamentos de Algoritmos Genéticos (AG)</h2>

    <!-- Pregunta 1 -->
    <button class="section-toggle-button" onclick="toggleSection('faq_ga_1', this)" aria-expanded="false" aria-controls="faq_ga_1">
      <span>1. ¿Qué es un Algoritmo Genético y en qué principios se inspira?</span><span class="icon">►</span>
    </button>
    <div id="faq_ga_1" class="content-panel">
      <p><strong class="panel-label">Respuesta Detallada:</strong></p>
      <p>Un Algoritmo Genético (AG) es una técnica de búsqueda y optimización metaheurística inspirada directamente en los principios de la evolución biológica y la selección natural propuestos por Charles Darwin. Forma parte del campo más amplio de la computación evolutiva y la inteligencia artificial. Los AG simulan el proceso de "supervivencia del más apto" sobre una población de soluciones candidatas a un problema. A través de generaciones sucesivas, la población evoluciona hacia soluciones cada vez mejores mediante la aplicación de operadores genéticos como la selección, el cruzamiento (recombinación) y la mutación. Su fortaleza radica en la capacidad de explorar eficientemente grandes y complejos espacios de soluciones donde los métodos de optimización clásicos (basados en gradientes o exhaustivos) pueden ser ineficaces o inviables debido a la dimensionalidad, la no linealidad o la presencia de múltiples óptimos locales.</p>
    </div>

    <!-- Pregunta 2 -->
    <button class="section-toggle-button" onclick="toggleSection('faq_ga_2', this)" aria-expanded="false" aria-controls="faq_ga_2">
      <span>2. ¿Cuáles son los componentes y pasos fundamentales en el ciclo de un Algoritmo Genético?</span><span class="icon">►</span>
    </button>
    <div id="faq_ga_2" class="content-panel">
      <p><strong class="panel-label">Respuesta Detallada:</strong></p>
      <p>El ciclo de un Algoritmo Genético típicamente involucra los siguientes componentes y pasos fundamentales:</p>
      <ol>
        <li><strong>Inicialización:</strong> Se crea una población inicial de individuos (soluciones candidatas). Cada individuo es un "cromosoma" que codifica una posible solución. Esta población inicial suele generarse aleatoriamente, aunque también pueden incorporarse soluciones heurísticas o conocidas.</li>
        <li><strong>Evaluación (Función de Fitness):</strong> Cada individuo de la población es evaluado mediante una función de fitness (o aptitud). Esta función asigna un valor numérico que cuantifica qué tan "buena" es la solución que representa el individuo con respecto al objetivo del problema.</li>
        <li><strong>Selección:</strong> Se seleccionan individuos de la población actual para ser "progenitores" de la siguiente generación. La selección es probabilística y sesgada hacia los individuos con mejor fitness (los más aptos tienen mayor probabilidad de ser seleccionados). Métodos comunes incluyen la selección por ruleta, por torneo y el elitismo.</li>
        <li><strong>Cruzamiento (Crossover):</strong> Los progenitores seleccionados se emparejan y se aplica un operador de cruzamiento para combinar su material genético y crear uno o más "descendientes". El objetivo es que los descendientes hereden características deseables de ambos padres.</li>
        <li><strong>Mutación:</strong> Se aplica un operador de mutación a los descendientes (y a veces a otros individuos) con una baja probabilidad. La mutación introduce pequeños cambios aleatorios en el material genético, ayudando a mantener la diversidad en la población y a explorar nuevas áreas del espacio de soluciones, evitando la convergencia prematura.</li>
        <li><strong>Reemplazo:</strong> La nueva población de descendientes reemplaza total o parcialmente a la población anterior. Estrategias comunes incluyen el reemplazo generacional completo o el reemplazo de los peores individuos.</li>
        <li><strong>Criterio de Parada:</strong> El ciclo se repite (pasos 2-6) hasta que se cumple un criterio de parada. Esto puede ser un número máximo de generaciones, alcanzar un nivel de fitness satisfactorio, un tiempo límite, o cuando la mejora en el fitness se estanca.</li>
      </ol>
    </div>

    <!-- Pregunta 3 -->
    <button class="section-toggle-button" onclick="toggleSection('faq_ga_3', this)" aria-expanded="false" aria-controls="faq_ga_3">
      <span>3. ¿Qué es la "representación genética" o "codificación" en un AG y por qué es crucial? De ejemplos.</span><span class="icon">►</span>
    </button>
    <div id="faq_ga_3" class="content-panel">
      <p><strong class="panel-label">Respuesta Detallada:</strong></p>
      <p>La representación genética, también llamada codificación, es la forma en que una solución candidata al problema se traduce en un "cromosoma" o "genotipo" que el AG puede manipular. Es un paso crucial porque la elección de la representación afecta directamente la eficiencia y efectividad del AG, así como la facilidad para diseñar operadores genéticos significativos.</p>
      <p>Una buena representación debe:</p>
      <ul>
        <li>Ser capaz de representar todas las soluciones posibles (o al menos un subconjunto prometedor).</li>
        <li>Facilitar la aplicación de operadores genéticos (cruce y mutación) de manera que generen soluciones válidas o fácilmente reparables.</li>
        <li>Permitir una decodificación eficiente para evaluar el fitness de la solución fenotípica.</li>
      </ul>
      <p>Ejemplos comunes de codificación incluyen:</p>
      <ul>
        <li><strong>Binaria:</strong> La solución se representa como una cadena de 0s y 1s. Útil para problemas de selección de características o donde las variables son inherentemente binarias.</li>
        <li><strong>Entera o Real:</strong> La solución se representa como un vector de números enteros o de punto flotante. Común para problemas de optimización de parámetros.</li>
        <li><strong>Permutaciones:</strong> La solución es una secuencia ordenada de elementos. Fundamental para problemas de ordenamiento como el Problema del Viajante (TSP), donde la permutación representa el orden de visita de las ciudades.</li>
        <li><strong>Árboles:</strong> La solución se representa como una estructura de árbol. Usada en Programación Genética para evolucionar programas o expresiones matemáticas.</li>
        <li><strong>Representación Directa de Código (como en AlphaEvolve):</strong> La solución es directamente el código fuente de un programa o función. Los operadores genéticos son aplicados por un LLM que entiende la sintaxis y semántica del lenguaje.</li>
      </ul>
    </div>

    <!-- Pregunta 4 -->
    <button class="section-toggle-button" onclick="toggleSection('faq_ga_4', this)" aria-expanded="false" aria-controls="faq_ga_4">
      <span>4. Explique la función de los operadores de cruzamiento y mutación en un AG.</span><span class="icon">►</span>
    </button>
    <div id="faq_ga_4" class="content-panel">
      <p><strong class="panel-label">Respuesta Detallada:</strong></p>
      <p>Los operadores de cruzamiento y mutación son los motores principales de la exploración y explotación en un Algoritmo Genético:</p>
      <ul>
        <li><strong>Cruzamiento (Crossover):</strong>
          <ul>
            <li><strong>Función Principal:</strong> Explotación e intensificación. Combina información genética de dos (o más) individuos progenitores para crear nuevos individuos descendientes. La idea es que al combinar "bloques constructivos" (buenas sub-soluciones) de padres aptos, se puedan generar descendientes aún mejores.</li>
            <li><strong>Ejemplos:</strong> Cruce de un punto, cruce de múltiples puntos (para representaciones binarias/reales); Order Crossover (OX), Partially Mapped Crossover (PMX), Cycle Crossover (CX) (para permutaciones).</li>
            <li><strong>Impacto:</strong> Permite la convergencia hacia regiones prometedoras del espacio de búsqueda al propagar y recombinar características exitosas.</li>
          </ul>
        </li>
        <li><strong>Mutación:</strong>
          <ul>
            <li><strong>Función Principal:</strong> Exploración y mantenimiento de la diversidad. Introduce pequeños cambios aleatorios en el material genético de un individuo.</li>
            <li><strong>Ejemplos:</strong> Inversión de bit (para binario); reemplazo por un valor aleatorio, ajuste pequeño (para real); swap, insert, reverse/inversion (para permutaciones).</li>
            <li><strong>Impacto:</strong> Previene la convergencia prematura a óptimos locales al introducir nueva variabilidad genética en la población. Permite al AG escapar de picos locales y explorar nuevas regiones del espacio de soluciones que podrían no ser accesibles solo mediante cruzamiento. Se aplica con una probabilidad mucho menor que el cruzamiento.</li>
          </ul>
        </li>
      </ul>
      <p>Un equilibrio adecuado entre la explotación del cruzamiento y la exploración de la mutación es crucial para el buen rendimiento de un AG.</p>
    </div>

    <!-- Pregunta 5 -->
    <button class="section-toggle-button" onclick="toggleSection('faq_ga_5', this)" aria-expanded="false" aria-controls="faq_ga_5">
      <span>5. ¿Qué es el elitismo en los Algoritmos Genéticos y por qué es importante?</span><span class="icon">►</span>
    </button>
    <div id="faq_ga_5" class="content-panel">
      <p><strong class="panel-label">Respuesta Detallada:</strong></p>
      <p>El elitismo es una estrategia utilizada en los Algoritmos Genéticos que consiste en **preservar directamente uno o más de los mejores individuos de la población actual para que pasen sin cambios a la siguiente generación**. Es decir, los individuos "élite" no están sujetos a los operadores de cruzamiento o mutación y se copian tal cual.</p>
      <p><strong>Importancia del Elitismo:</strong></p>
      <ul>
        <li><strong>Prevención de Pérdida de Buenas Soluciones:</strong> La principal ventaja es que garantiza que la mejor solución encontrada hasta el momento no se pierda debido a la naturaleza estocástica de la selección, el cruzamiento o la mutación. Sin elitismo, es posible que una solución excelente sea descartada o degradada accidentalmente.</li>
        <li><strong>Convergencia Monotónica (del Mejor Individuo):</strong> Asegura que el fitness del mejor individuo de la población sea no decreciente (o no creciente, si se minimiza) a lo largo de las generaciones. Esto puede acelerar la convergencia hacia buenas soluciones.</li>
        <li><strong>Punto de Referencia:</strong> Los individuos élite sirven como un punto de referencia constante contra el cual se pueden comparar las nuevas soluciones generadas.</li>
      </ul>
      <p>Sin embargo, un elitismo excesivo (preservar demasiados individuos) puede reducir la diversidad de la población y llevar a una convergencia prematura. Por lo tanto, el número de individuos élite suele ser pequeño, típicamente uno o un porcentaje bajo de la población total.</p>
    </div>

    <h2 class="section-group-title">Algoritmos Genéticos Aplicados (TSP, Laberintos)</h2>

    <!-- Pregunta 6 -->
    <button class="section-toggle-button" onclick="toggleSection('faq_tsp_1', this)" aria-expanded="false" aria-controls="faq_tsp_1">
      <span>6. ¿Por qué los Algoritmos Genéticos son adecuados para el Problema del Viajante (TSP)?</span><span class="icon">►</span>
    </button>
    <div id="faq_tsp_1" class="content-panel">
      <p><strong class="panel-label">Respuesta Detallada:</strong></p>
      <p>Los Algoritmos Genéticos son particularmente adecuados para el Problema del Viajante (TSP) por varias razones clave:</p>
      <ol>
        <li><strong>Representación Natural:</strong> Una solución al TSP (una ruta que visita cada ciudad una vez) se puede representar de forma natural e intuitiva como una permutación de ciudades. Esta codificación es directamente compatible con operadores genéticos diseñados para permutaciones.</li>
        <li><strong>Espacio de Búsqueda Vasto y Complejo:</strong> El TSP es un problema NP-hard, lo que significa que el número de posibles rutas crece factorialmente con el número de ciudades. Para instancias grandes, la búsqueda exhaustiva es inviable. Los AG son eficaces para explorar estos grandes espacios de búsqueda de manera heurística.</li>
        <li><strong>Robustez ante Óptimos Locales:</strong> El espacio de soluciones del TSP está plagado de óptimos locales (rutas que son buenas pero no las mejores globalmente). Los AG, mediante la mutación y el mantenimiento de la diversidad poblacional, tienen la capacidad de escapar de estos óptimos locales.</li>
        <li><strong>Adaptabilidad a Variantes:</strong> Los AG pueden adaptarse fácilmente a diversas variantes del TSP, como el TSP asimétrico, TSP con ventanas de tiempo, o problemas de ruteo de vehículos (VRP) que generalizan el TSP, simplemente ajustando la función de fitness y, a veces, los operadores.</li>
        <li><strong>Operadores Genéticos Específicos:</strong> Se han desarrollado operadores de cruzamiento (ej. Order Crossover OX, Partially Mapped Crossover PMX) y mutación (ej. swap, inversion, insertion) específicamente diseñados para trabajar con representaciones de permutación, preservando la validez de las rutas o facilitando su reparación.</li>
        <li><strong>Paralelización:</strong> Muchas partes de un AG (como la evaluación del fitness de los individuos) son inherentemente paralelizables, lo que puede acelerar la búsqueda en hardware moderno.</li>
      </ol>
      <p>Aunque no garantizan encontrar la solución óptima global, los AG suelen encontrar soluciones de muy alta calidad para el TSP en un tiempo razonable.</p>
    </div>

    <!-- Pregunta 7 -->
    <button class="section-toggle-button" onclick="toggleSection('faq_tsp_2', this)" aria-expanded="false" aria-controls="faq_tsp_2">
      <span>7. ¿Cómo se define típicamente la función de fitness para el Problema del Viajante (TSP)?</span><span class="icon">►</span>
    </button>
    <div id="faq_tsp_2" class="content-panel">
      <p><strong class="panel-label">Respuesta Detallada:</strong></p>
      <p>En el Problema del Viajante (TSP), el objetivo es encontrar la ruta más corta posible. Dado que los Algoritmos Genéticos están diseñados convencionalmente para maximizar el fitness, la función de fitness debe transformar la medida de "costo" (distancia) en una medida de "calidad" (aptitud).</p>
      <p>Las formas más comunes de definir la función de fitness para el TSP son:</p>
      <ol>
        <li><strong>Inverso de la Distancia Total:</strong>
          <p><code>Fitness(ruta) = 1 / DistanciaTotal(ruta)</code></p>
          <p>En este caso, una distancia total menor resultará en un valor de fitness mayor. Es importante manejar el caso de distancia cero si es teóricamente posible (ej. añadiendo una pequeña constante épsilon al denominador o asegurando que las distancias sean siempre positivas).</p>
        </li>
        <li><strong>Negativo de la Distancia Total:</strong>
          <p><code>Fitness(ruta) = -DistanciaTotal(ruta)</code></p>
          <p>Aquí, maximizar el fitness equivale a minimizar la distancia (ya que un número negativo mayor está más cerca de cero). Alternativamente, si el algoritmo de selección busca minimizar, se puede usar directamente <code>DistanciaTotal(ruta)</code>.</p>
        </li>
        <li><strong>Escalado:</strong>
          <p><code>Fitness(ruta) = C_max - DistanciaTotal(ruta)</code></p>
          <p>Donde <code>C_max</code> es una constante suficientemente grande (por ejemplo, una estimación del peor recorrido posible o una suma de las distancias máximas). Esto asegura que el fitness sea positivo y que rutas más cortas tengan mayor fitness.</p>
        </li>
      </ol>
      <p>La elección exacta puede depender de la implementación específica del AG y de las características del problema, pero el principio fundamental es que el fitness debe reflejar inversamente la longitud de la ruta para guiar la evolución hacia soluciones más cortas.</p>
    </div>

    <!-- Pregunta 8 -->
    <button class="section-toggle-button" onclick="toggleSection('faq_tsp_3', this)" aria-expanded="false" aria-controls="faq_tsp_3">
      <span>8. Describa un operador de cruzamiento y uno de mutación comúnmente usados para el TSP.</span><span class="icon">►</span>
    </button>
    <div id="faq_tsp_3" class="content-panel">
      <p><strong class="panel-label">Respuesta Detallada:</strong></p>
      <p>Para el Problema del Viajante (TSP), donde las soluciones son permutaciones de ciudades, se utilizan operadores genéticos específicos:</p>
      <ul>
        <li><strong>Operador de Cruzamiento Común: Order Crossover (OX1)</strong>
          <ol>
            <li>Se eligen dos puntos de corte aleatorios en el primer progenitor (P1).</li>
            <li>El segmento de P1 entre estos puntos de corte se copia directamente al descendiente (H1) en las mismas posiciones.</li>
            <li>Los elementos restantes se toman del segundo progenitor (P2) en el orden en que aparecen en P2, omitiendo aquellos que ya están presentes en H1 (provenientes del segmento de P1).</li>
            <li>Estos elementos de P2 se insertan en las posiciones vacías de H1, comenzando después del segundo punto de corte y continuando cíclicamente desde el inicio si es necesario.</li>
          </ol>
          <p><em>Ejemplo:</em> P1 = [1,2,3,<strong>4,5,6</strong>,7,8], P2 = [8,6,4,2,1,3,5,7]. Puntos de corte en P1 después de la pos 3 y 6 (segmento 4,5,6).</p>
          <p>H1 = [_,_,_,<strong>4,5,6</strong>,_,_]. Elementos de P2 en orden, omitiendo 4,5,6: [8,2,1,3,7].</p>
          <p>H1 = [2,1,3,<strong>4,5,6</strong>,8,7] (llenando desde la pos 7, luego 1, 2, 3).</p>
          <p>OX1 tiende a preservar el orden relativo y las posiciones absolutas de un segmento del primer padre, complementado con el orden relativo del segundo.</p>
        </li>
        <li><strong>Operador de Mutación Común: Swap (Intercambio)</strong>
          <ol>
            <li>Se eligen dos posiciones aleatorias distintas en el cromosoma (la permutación de ciudades).</li>
            <li>Las ciudades en estas dos posiciones se intercambian.</li>
          </ol>
          <p><em>Ejemplo:</em> Individuo = [1,2,<strong>3</strong>,4,5,<strong>6</strong>,7,8]. Posiciones aleatorias 3 y 6 (valores 3 y 6).</p>
          <p>Individuo Mutado = [1,2,<strong>6</strong>,4,5,<strong>3</strong>,7,8].</p>
          <p>Swap es un operador simple pero efectivo para introducir pequeñas perturbaciones y explorar vecindarios cercanos de la solución actual.</p>
        </li>
      </ul>
    </div>

    <!-- Pregunta 9 -->
    <button class="section-toggle-button" onclick="toggleSection('faq_lab_1', this)" aria-expanded="false" aria-controls="faq_lab_1">
      <span>9. ¿Cómo se puede representar una solución (un camino) en un AG para el problema de navegación en laberintos?</span><span class="icon">►</span>
    </button>
    <div id="faq_lab_1" class="content-panel">
      <p><strong class="panel-label">Respuesta Detallada:</strong></p>
      <p>Para el problema de navegación en laberintos, una solución candidata (un camino) se puede representar genéticamente de varias maneras. Una de las más efectivas y naturales es como una **secuencia ordenada de posiciones (coordenadas) en la cuadrícula del laberinto**.</p>
      <p>Por ejemplo, si el laberinto es una matriz 2D, cada posición puede ser una tupla <code>(fila, columna)</code>. Un individuo (camino) sería una lista de estas tuplas:</p>
      <p><code>Camino = [(start_fila, start_col), (fila1, col1), (fila2, col2), ..., (end_fila, end_col)]</code></p>
      <p><strong>Características y Ventajas de esta Representación:</strong></p>
      <ul>
        <li><strong>Claridad:</strong> Representa directamente la trayectoria del agente.</li>
        <li><strong>Validez de Pasos:</strong> Se puede verificar fácilmente si cada paso de una posición a la siguiente es válido (adyacente y no a través de una pared).</li>
        <li><strong>Operadores Genéticos:</strong>
          <ul>
            <li><strong>Cruzamiento:</strong> Se pueden aplicar operadores como el cruce de un punto, donde dos caminos padres intercambian sus segmentos después de un punto de corte. Es crucial implementar un mecanismo de "reparación" para asegurar que el camino resultante sea topológicamente válido (conectado) después del cruce, ya que los segmentos podrían no unirse correctamente.</li>
            <li><strong>Mutación:</strong> Se pueden añadir/eliminar/modificar pasos en el camino, por ejemplo, insertando una nueva celda válida, eliminando una celda (si las adyacentes se pueden conectar), o reemplazando un sub-segmento del camino por otro.</li>
          </ul>
        </li>
        <li><strong>Flexibilidad en Longitud:</strong> Los caminos pueden tener longitudes variables, lo que es natural para este problema.</li>
      </ul>
      <p>Alternativamente, se podría codificar como una secuencia de movimientos (ej. "arriba", "abajo", "izquierda", "derecha"), pero esto puede ser más difícil de manejar con operadores genéticos para asegurar la validez y evitar bucles innecesarios sin mecanismos de reparación más complejos. La secuencia de posiciones suele ser más directa para la evaluación y manipulación genética en el contexto de laberintos.</p>
    </div>

    <!-- Pregunta 10 -->
    <button class="section-toggle-button" onclick="toggleSection('faq_lab_2', this)" aria-expanded="false" aria-controls="faq_lab_2">
      <span>10. Describa algunos criterios que podrían incluirse en una función de fitness para un AG que resuelve laberintos.</span><span class="icon">►</span>
    </button>
    <div id="faq_lab_2" class="content-panel">
      <p><strong class="panel-label">Respuesta Detallada:</strong></p>
      <p>Una función de fitness robusta para un AG que resuelve laberintos es multifacética y debe guiar la evolución hacia caminos válidos, eficientes y que alcancen el objetivo. Algunos criterios clave incluyen:</p>
      <ol>
        <li><strong>Alcance del Objetivo:</strong>
          <ul>
            <li>Se otorga una recompensa significativamente alta (o una penalización muy baja) si el camino alcanza la celda objetivo (fin del laberinto). Este suele ser el componente más importante del fitness.</li>
          </ul>
        </li>
        <li><strong>Longitud del Camino:</strong>
          <ul>
            <li>Se penaliza la longitud excesiva del camino. Caminos más cortos, especialmente si alcanzan el objetivo, son preferibles. La penalización puede ser proporcional al número de pasos.</li>
          </ul>
        </li>
        <li><strong>Distancia al Objetivo (si no se alcanza):</strong>
          <ul>
            <li>Para caminos que no llegan al final, se puede usar una heurística como la distancia de Manhattan o Euclidiana desde la última celda del camino hasta la celda objetivo. Una menor distancia resulta en una menor penalización (o mayor fitness relativo), guiando la búsqueda.</li>
          </ul>
        </li>
        <li><strong>Penalización por Bucles o Redundancia:</strong>
          <ul>
            <li>Visitar repetidamente las mismas celdas o segmentos del laberinto es ineficiente. Se puede penalizar la diferencia entre la longitud total del camino y el número de celdas únicas visitadas.</li>
          </ul>
        </li>
        <li><strong>Validez del Camino (Implícita o Explícita):</strong>
          <ul>
            <li>Implícitamente, los operadores genéticos y la generación de individuos deberían intentar producir caminos válidos (sin atravesar paredes, movimientos adyacentes). Si se permiten caminos inválidos durante la evolución (para luego repararlos), deben ser fuertemente penalizados.</li>
            <li>Un camino que no comienza en la celda de inicio también debe ser penalizado severamente.</li>
          </ul>
        </li>
        <li><strong>Penalización por Pasos Inválidos (si se permiten temporalmente):</strong>
          <ul>
            <li>Si un camino contiene movimientos no válidos (ej. a través de paredes o diagonales si no están permitidas), cada paso inválido debe incurrir en una penalización.</li>
          </ul>
        </li>
      </ol>
      <p>El diseño exacto y la ponderación de estos criterios son cruciales. Por ejemplo, se podría usar una base alta de fitness, sustraer penalizaciones por longitud y distancia al objetivo, y añadir una gran bonificación si se alcanza el final. El objetivo es crear un gradiente de fitness que guíe a la población de manera efectiva.</p>
    </div>

    <h2 class="section-group-title">Conceptos Avanzados y AlphaEvolve</h2>

    <!-- Pregunta 11 -->
    <button class="section-toggle-button" onclick="toggleSection('faq_ag_adv_1', this)" aria-expanded="false" aria-controls="faq_ag_adv_1">
      <span>11. ¿Qué es la mutación adaptativa en los Algoritmos Genéticos y cómo funciona?</span><span class="icon">►</span>
    </button>
    <div id="faq_ag_adv_1" class="content-panel">
      <p><strong class="panel-label">Respuesta Detallada:</strong></p>
      <p>La mutación adaptativa es una técnica avanzada en Algoritmos Genéticos donde la **tasa de mutación (la probabilidad de que un gen o individuo mute) no es fija, sino que se ajusta dinámicamente** durante el proceso evolutivo. El objetivo es balancear mejor la exploración y la explotación según el estado actual de la población.</p>
      <p><strong>Funcionamiento Típico:</strong></p>
      <p>La tasa de mutación se ajusta basándose en alguna medida del progreso o diversidad de la población:</p>
      <ul>
        <li><strong>Basada en Diversidad:</strong>
          <ul>
            <li>Si la <strong>diversidad de la población es baja</strong> (lo que indica posible convergencia prematura o estancamiento), la tasa de mutación se incrementa. Esto introduce más variabilidad, ayudando a la población a escapar de óptimos locales y explorar nuevas áreas.</li>
            <li>Si la <strong>diversidad es alta y/o la población está mejorando consistentemente</strong>, la tasa de mutación puede disminuirse. Esto permite una explotación más fina de las regiones prometedoras encontradas.</li>
            <li>La diversidad puede medirse, por ejemplo, por la distancia promedio (ej. Hamming) entre los individuos o la varianza del fitness.</li>
          </ul>
        </li>
        <li><strong>Basada en el Progreso del Fitness:</strong>
          <ul>
            <li>Si no ha habido mejora en el mejor fitness durante varias generaciones (estancamiento), la tasa de mutación podría aumentarse.</li>
            <li>Si el fitness está mejorando rápidamente, la tasa podría mantenerse baja o reducirse.</li>
          </ul>
        </li>
      </ul>
      <p>Generalmente, se establecen límites mínimos y máximos para la tasa de mutación para evitar valores extremos. La mutación adaptativa hace al AG más robusto a la elección inicial de la tasa de mutación y puede mejorar su rendimiento en una variedad de problemas.</p>
    </div>

    <!-- Pregunta 12 -->
    <button class="section-toggle-button" onclick="toggleSection('faq_ag_adv_2', this)" aria-expanded="false" aria-controls="faq_ag_adv_2">
      <span>12. Explique el concepto de "reseteo parcial de población" y su utilidad.</span><span class="icon">►</span>
    </button>
    <div id="faq_ag_adv_2" class="content-panel">
      <p><strong class="panel-label">Respuesta Detallada:</strong></p>
      <p>El reseteo parcial de población es un mecanismo de diversificación utilizado en Algoritmos Genéticos para combatir el estancamiento y la convergencia prematura. Ocurre cuando el algoritmo detecta que no ha habido una mejora significativa en el mejor fitness de la población durante un número determinado de generaciones (definido por un umbral de estancamiento).</p>
      <p><strong>Funcionamiento:</strong></p>
      <p>Cuando se activa el reseteo parcial:</p>
      <ol>
        <li>Una **porción de la población actual es reemplazada** por nuevos individuos generados aleatoriamente (o mediante alguna heurística de inicialización).</li>
        <li>Generalmente, los **mejores individuos (la élite)** de la población actual se preservan y se copian a la nueva población para no perder las mejores soluciones encontradas hasta el momento.</li>
        <li>El resto de la población "reemplazada" puede ser una fracción significativa.</li>
      </ol>
      <p><strong>Utilidad:</strong></p>
      <ul>
        <li><strong>Reintroducción de Diversidad:</strong> El principal objetivo es inyectar nueva diversidad genética en una población que puede haberse vuelto demasiado homogénea y convergido a un óptimo local.</li>
        <li><strong>Escape de Óptimos Locales:</strong> Al introducir soluciones radicalmente diferentes, se le da al AG una nueva oportunidad de explorar otras regiones del espacio de soluciones que podrían contener mejores óptimos.</li>
        <li><strong>Revitalización de la Búsqueda:</strong> Puede "sacudir" al algoritmo de un estado de estancamiento y reiniciar la búsqueda efectiva.</li>
      </ul>
      <p>Es importante que este mecanismo no sea demasiado frecuente ni reemplace a toda la población (a menos que sea una estrategia específica), para no perder por completo el progreso evolutivo acumulado. El reseteo parcial, junto con la preservación de la élite, busca un equilibrio entre mantener lo bueno y explorar lo nuevo cuando la búsqueda se atasca.</p>
    </div>

    <!-- Pregunta 13 -->
    <button class="section-toggle-button" onclick="toggleSection('faq_ag_adv_3', this)" aria-expanded="false" aria-controls="faq_ag_adv_3">
      <span>13. ¿Qué es un algoritmo memético o búsqueda local híbrida en el contexto de los AG?</span><span class="icon">►</span>
    </button>
    <div id="faq_ag_adv_3" class="content-panel">
      <p><strong class="panel-label">Respuesta Detallada:</strong></p>
      <p>Un algoritmo memético, también conocido como Algoritmo Genético Híbrido o Búsqueda Local Híbrida, combina la **exploración global de un Algoritmo Genético con la capacidad de explotación fina de una técnica de búsqueda local (o mejora local)**.</p>
      <p>La idea fundamental es que los AG son buenos para explorar ampliamente el espacio de soluciones e identificar regiones prometedoras, pero pueden no ser tan eficientes para encontrar el óptimo exacto dentro de una región una vez localizada. Las técnicas de búsqueda local, por otro lado, son expertas en refinar una solución existente moviéndose hacia los mejores vecinos en su vecindad inmediata.</p>
      <p><strong>Funcionamiento Típico:</strong></p>
      <ol>
        <li>El AG opera de manera estándar (selección, cruce, mutación) para generar nuevos individuos.</li>
        <li>En ciertos puntos del proceso evolutivo, se aplica un procedimiento de búsqueda local a algunos o todos los individuos de la población. Esto puede ocurrir:
            <ul>
              <li>A cada nuevo individuo generado.</li>
              <li>Solo a los mejores individuos (la élite).</li>
              <li>Periódicamente, cada cierto número de generaciones.</li>
              <li>Cuando se detecta estancamiento.</li>
            </ul>
        </li>
        <li>El individuo resultante de la búsqueda local (que es una versión mejorada del original dentro de su vecindario) reemplaza al individuo original en la población.</li>
      </ol>
      <p><strong>Ventajas:</strong></p>
      <ul>
        <li><strong>Mejora de la Calidad de la Solución:</strong> Suelen encontrar soluciones de mayor calidad que un AG puro.</li>
        <li><strong>Convergencia Más Rápida:</strong> Pueden converger más rápidamente a buenas soluciones al refinar eficientemente las soluciones prometedoras.</li>
      </ul>
      <p>El término "memético" se refiere a la idea de "memes" como unidades de cultura o aprendizaje que se transmiten y refinan, análogamente a cómo la búsqueda local refina las soluciones ("genes") generadas por el AG.</p>
    </div>

    <!-- Pregunta 14 -->
    <button class="section-toggle-button" onclick="toggleSection('faq_ae_1', this)" aria-expanded="false" aria-controls="faq_ae_1">
      <span>14. ¿Cómo difiere AlphaEvolve de enfoques evolutivos anteriores como FunSearch en términos de escala y capacidades?</span><span class="icon">►</span>
    </button>
    <div id="faq_ae_1" class="content-panel">
      <p><strong class="panel-label">Respuesta Detallada:</strong></p>
      <p>AlphaEvolve representa una evolución significativa sobre sistemas anteriores como FunSearch, ampliando considerablemente la escala y las capacidades de la evolución de código guiada por LLMs:</p>
      <ol>
        <li><strong>Escala de Evolución del Código:</strong>
          <ul>
            <li><strong>FunSearch:</strong> Se enfocaba en evolucionar funciones pequeñas y aisladas, típicamente escritas en Python y de pocas líneas de código. El objetivo era descubrir heurísticas o funciones matemáticas concisas.</li>
            <li><strong>AlphaEvolve:</strong> Está diseñado para operar sobre **archivos de código completos** y puede modificar **bloques de código extensos** (cientos de líneas). Puede integrarse con bases de código existentes mediante la anotación de "bloques de evolución".</li>
          </ul>
        </li>
        <li><strong>Flexibilidad Lingüística:</strong>
          <ul>
            <li><strong>FunSearch:</strong> Principalmente orientado a Python.</li>
            <li><strong>AlphaEvolve:</strong> Puede trabajar con **diversos lenguajes de programación**, como se demostró con Verilog para diseño de hardware o IRs de compiladores.</li>
          </ul>
        </li>
        <li><strong>Modelos de Lenguaje y Contexto:</strong>
          <ul>
            <li><strong>FunSearch:</strong> Utilizaba LLMs más pequeños y un contexto de prompt relativamente simple.</li>
            <li><strong>AlphaEvolve:</strong> Emplea un **ensamblaje de LLMs de última generación (SOTA)** como Gemini 2.0 Pro y Flash. Utiliza un **contexto de prompt mucho más rico y dinámico**, que puede incluir soluciones previas, resultados de evaluación, documentación externa (PDFs), e incluso **meta-prompts** que son evolucionados por el propio sistema para mejorar la forma en que interactúa con los LLMs.</li>
          </ul>
        </li>
        <li><strong>Objetivos de Optimización:</strong>
          <ul>
            <li><strong>FunSearch:</strong> Generalmente optimizaba una única métrica o función objetivo.</li>
            <li><strong>AlphaEvolve:</strong> Soporta la **optimización multiobjetivo**, permitiendo evolucionar soluciones que balanceen diferentes criterios (ej. eficiencia, simplicidad, rendimiento bajo diversas condiciones).</li>
          </ul>
        </li>
        <li><strong>Formato de Modificación de Código:</strong>
          <ul>
            <li><strong>AlphaEvolve:</strong> Utiliza un formato de "diff" (diferencias) para proponer cambios específicos y dirigidos al código, aunque también puede reescribir bloques enteros. Esto es más adecuado para trabajar con código extenso y existente.</li>
          </ul>
        </li>
        <li><strong>Capacidad de Aplicación:</strong>
          <ul>
            <li>Debido a las mejoras anteriores, AlphaEvolve puede abordar problemas mucho más complejos y de mayor impacto práctico, como la optimización de infraestructuras computacionales críticas o el diseño de algoritmos para problemas científicos fundamentales, tareas que estaban fuera del alcance de FunSearch.</li>
          </ul>
        </li>
      </ol>
      <p>En esencia, AlphaEvolve lleva la idea de la evolución de código guiada por LLMs a un nivel de madurez y aplicabilidad industrial y científica mucho mayor.</p>
    </div>

    <!-- Pregunta 15 -->
    <button class="section-toggle-button" onclick="toggleSection('faq_ae_2', this)" aria-expanded="false" aria-controls="faq_ae_2">
      <span>15. ¿Qué papel juega el "Prompt Sampler" y la "Base de Datos de Programas" en el funcionamiento de AlphaEvolve?</span><span class="icon">►</span>
    </button>
    <div id="faq_ae_2" class="content-panel">
      <p><strong class="panel-label">Respuesta Detallada:</strong></p>
      <p>El "Prompt Sampler" y la "Base de Datos de Programas" son componentes cruciales en el bucle evolutivo de AlphaEvolve, trabajando conjuntamente para guiar la generación de nuevas soluciones de código:</p>
      <ul>
        <li><strong>Base de Datos de Programas (Program Database):</strong>
          <ul>
            <li><strong>Función:</strong> Actúa como la "memoria" del proceso evolutivo. Almacena todas las soluciones (programas o fragmentos de código) que han sido generadas y evaluadas, junto con sus puntuaciones de fitness, resultados de evaluación, y otros metadatos relevantes.</li>
            <li><strong>Importancia:</strong>
              <ul>
                <li><strong>Preservación del Conocimiento:</strong> Asegura que las buenas soluciones encontradas no se pierdan y puedan ser reutilizadas o servir de inspiración.</li>
                <li><strong>Guía para la Evolución:</strong> Proporciona el material base para la selección de "progenitores" y para la construcción de prompts informativos.</li>
                <li><strong>Mantenimiento de Diversidad:</strong> Implementa estrategias (inspiradas en MAP-Elites y modelos de islas) para equilibrar la exploración y la explotación, almacenando no solo las mejores soluciones absolutas sino también soluciones diversas que destacan en diferentes aspectos o nichos.</li>
              </ul>
            </li>
          </ul>
        </li>
        <li><strong>Muestreador de Prompts (Prompt Sampler):</strong>
          <ul>
            <li><strong>Función:</strong> Es responsable de construir los prompts que se envían a los LLMs para generar nuevas modificaciones de código. Para ello, extrae información de la Base de Datos de Programas y de otras fuentes.</li>
            <li><strong>Construcción de Prompts Ricos:</strong>
              <ul>
                <li><strong>Selección de Ejemplos:</strong> Muestrea programas "padre" o soluciones previas exitosas de la base de datos para incluirlos en el prompt como ejemplos de buen rendimiento o como base para la modificación.</li>
                <li><strong>Contexto Explícito:</strong> Incorpora detalles sobre el problema, instrucciones específicas proporcionadas por el usuario, documentación relevante, e incluso los resultados de evaluación de los programas muestreados.</li>
                <li><strong>Meta-Prompts:</strong> Puede utilizar "meta-instrucciones" (que también pueden ser evolucionadas) para refinar la tarea que se le pide al LLM (ej. "sugiere una modificación que mejore la eficiencia manteniendo la legibilidad").</li>
                <li><strong>Formato Estocástico:</strong> Puede usar plantillas con alternativas para variar la estructura del prompt y fomentar la diversidad en las respuestas del LLM.</li>
              </ul>
            </li>
            <li><strong>Importancia:</strong> La calidad del prompt es determinante para la calidad de las sugerencias del LLM. Un buen Prompt Sampler asegura que los LLMs reciban la información más útil y relevante para proponer cambios que realmente mejoren el código según los objetivos definidos.</li>
          </ul>
        </li>
      </ul>
      <p>En conjunto, la Base de Datos de Programas provee la "experiencia acumulada" y el Prompt Sampler la traduce en "instrucciones efectivas" para que los LLMs impulsen la evolución del código de manera inteligente.</p>
    </div>

    <!-- Pregunta 16 -->
    <button class="section-toggle-button" onclick="toggleSection('faq_ae_3', this)" aria-expanded="false" aria-controls="faq_ae_3">
      <span>16. ¿Cómo maneja AlphaEvolve la evaluación de las soluciones generadas, especialmente cuando hay múltiples criterios?</span><span class="icon">►</span>
    </button>
    <div id="faq_ae_3" class="content-panel">
      <p><strong class="panel-label">Respuesta Detallada:</strong></p>
      <p>AlphaEvolve cuenta con un sistema de evaluación flexible y potente para calificar las soluciones de código generadas, capaz de manejar múltiples criterios y optimizar la eficiencia del proceso:</p>
      <ol>
        <li><strong>Función de Evaluación Definida por el Usuario (<code>evaluate</code>):</strong>
          <ul>
            <li>El usuario proporciona una función (típicamente en Python) que toma una solución generada (código) como entrada y devuelve un conjunto de métricas escalares que cuantifican su rendimiento. Estas métricas se maximizan por convención.</li>
          </ul>
        </li>
        <li><strong>Optimización Multiobjetivo:</strong>
          <ul>
            <li>AlphaEvolve puede optimizar simultáneamente **múltiples métricas de evaluación**. Por ejemplo, podría buscar un código que no solo sea rápido (métrica 1) sino también eficiente en memoria (métrica 2) y simple o legible (métrica 3).</li>
            <li>Esto es valioso porque programas que sobresalen en diferentes criterios a menudo poseen estructuras distintas. Al incorporar ejemplos diversos y de alto rendimiento (según diferentes definiciones de "bueno") en los prompts, se estimula la generación de soluciones más variadas y se aumentan las posibilidades de encontrar enfoques novedosos y efectivos, incluso si el interés final es una única métrica.</li>
          </ul>
        </li>
        <li><strong>Cascada de Evaluación (Pruebas de Hipótesis):</strong>
          <ul>
            <li>Para problemas complejos o cuando la evaluación es costosa, el usuario puede definir una **secuencia de conjuntos de pruebas de dificultad creciente**.</li>
            <li>Las nuevas soluciones se evalúan primero en los casos más simples o a pequeña escala. Solo si alcanzan resultados prometedores en una etapa, avanzan a la siguiente etapa más difícil.</li>
            <li>Esto ayuda a **podar rápidamente las soluciones menos prometedoras**, ahorrando recursos computacionales y tiempo, y filtrando programas defectuosos tempranamente.</li>
          </ul>
        </li>
        <li><strong>Evaluación Paralelizada:</strong>
          <ul>
            <li>La evaluación de cada nueva solución puede ser computacionalmente intensiva (ej. ejecutar simulaciones, compilar y correr benchmarks). AlphaEvolve está diseñado para **distribuir este trabajo de evaluación de forma asíncrona** a través de un clúster de evaluación. Esto es crucial para mantener un alto rendimiento (throughput) del sistema, permitiendo evaluar muchas ideas en paralelo.</li>
          </ul>
        </li>
        <li><strong>Retroalimentación Generada por LLM para Métricas Cualitativas:</strong>
          <ul>
            <li>Para características deseables que son difíciles de cuantificar programáticamente (ej. simplicidad del código, legibilidad, mantenibilidad), AlphaEvolve puede utilizar **LLMs separados para calificar estos aspectos**. Estas puntuaciones cualitativas pueden añadirse al diccionario de métricas para guiar la evolución o usarse para descartar soluciones que no cumplan ciertos criterios cualitativos.</li>
          </ul>
        </li>
      </ol>
      <p>Este sistema de evaluación multifacético permite a AlphaEvolve abordar problemas complejos con requisitos diversos y hacerlo de manera eficiente.</p>
    </div>

    <h2 class="section-group-title">Consideraciones Conceptuales Adicionales</h2>

    <!-- Pregunta 17 (Nueva) -->
    <button class="section-toggle-button" onclick="toggleSection('faq_concept_1', this)" aria-expanded="false" aria-controls="faq_concept_1">
      <span>17. ¿Cuál es el papel de la diversidad en una población de un AG y qué mecanismos se usan para mantenerla?</span><span class="icon">►</span>
    </button>
    <div id="faq_concept_1" class="content-panel">
      <p><strong class="panel-label">Respuesta Detallada:</strong></p>
      <p>La diversidad genética dentro de la población de un Algoritmo Genético es fundamental para su éxito a largo plazo. Se refiere a la variedad de soluciones (cromosomas) presentes en la población en un momento dado.</p>
      <p><strong>Papel de la Diversidad:</strong></p>
      <ul>
        <li><strong>Prevención de Convergencia Prematura:</strong> Si la población se vuelve demasiado homogénea (baja diversidad), el AG puede converger rápidamente a un óptimo local, que podría no ser el óptimo global. Una población diversa asegura que se exploren diferentes regiones del espacio de soluciones.</li>
        <li><strong>Exploración Continua:</strong> La diversidad proporciona el "material crudo" para que los operadores de cruzamiento y mutación generen nuevas soluciones potencialmente mejores. Sin ella, la evolución se estanca.</li>
        <li><strong>Robustez:</strong> Una población diversa puede adaptarse mejor a paisajes de fitness complejos y rugosos.</li>
      </ul>
      <p><strong>Mecanismos para Mantener la Diversidad:</strong></p>
      <ul>
        <li><strong>Mutación:</strong> Es el principal mecanismo para introducir nueva información genética y mantener la diversidad. Una tasa de mutación adecuada es crucial.</li>
        <li><strong>Tasas de Cruzamiento Altas:</strong> Fomentan la recombinación de diferentes genes, aunque por sí solas no garantizan diversidad si los padres son muy similares.</li>
        <li><strong>Selección Menos Agresiva:</strong> Métodos de selección como el torneo (con un tamaño de torneo pequeño) o la ruleta pueden dar más oportunidades a individuos menos aptos pero diferentes, preservando la diversidad.</li>
        <li><strong>Mutación Adaptativa:</strong> Incrementar la tasa de mutación cuando la diversidad es baja.</li>
        <li><strong>Reseteo Parcial de Población:</strong> Reintroducir individuos aleatorios cuando se detecta estancamiento.</li>
        <li><strong>Mecanismos de Nicho (Niching):</strong> Fomentar la formación de subpoblaciones que se especializan en diferentes regiones del espacio de soluciones (ej. fitness sharing, crowding).</li>
        <li><strong>Tamaño de Población Adecuado:</strong> Poblaciones muy pequeñas tienden a perder diversidad rápidamente debido a la deriva genética.</li>
        <li><strong>Evitar Duplicados Excesivos:</strong> Algunas estrategias penalizan o evitan la presencia de demasiados individuos idénticos en la población.</li>
      </ul>
      <p>Un equilibrio entre la presión selectiva (que tiende a reducir la diversidad) y los mecanismos de mantenimiento de diversidad es esencial para un AG efectivo.</p>
    </div>

    <!-- Pregunta 18 (Nueva) -->
    <button class="section-toggle-button" onclick="toggleSection('faq_concept_2', this)" aria-expanded="false" aria-controls="faq_concept_2">
      <span>18. Compare la exploración y la explotación en el contexto de los AG. ¿Cómo se equilibran estos dos aspectos?</span><span class="icon">►</span>
    </button>
    <div id="faq_concept_2" class="content-panel">
      <p><strong class="panel-label">Respuesta Detallada:</strong></p>
      <p>La exploración y la explotación son dos fuerzas fundamentales y a menudo contrapuestas que deben equilibrarse cuidadosamente en cualquier algoritmo de búsqueda heurística, incluidos los Algoritmos Genéticos.</p>
      <ul>
        <li><strong>Exploración (Exploration):</strong>
          <ul>
            <li><strong>Definición:</strong> Se refiere al proceso de investigar regiones desconocidas o poco visitadas del espacio de soluciones. El objetivo es descubrir nuevas áreas que potencialmente podrían contener soluciones de alta calidad.</li>
            <li><strong>Mecanismos en AG:</strong> Principalmente la <strong>mutación</strong>, que introduce variabilidad aleatoria. También contribuyen la inicialización diversa de la población y, en cierta medida, el cruzamiento cuando combina padres genéticamente distantes.</li>
            <li><strong>Importancia:</strong> Evita quedar atrapado en óptimos locales y aumenta la probabilidad de encontrar el óptimo global.</li>
          </ul>
        </li>
        <li><strong>Explotación (Exploitation):</strong>
          <ul>
            <li><strong>Definición:</strong> Se refiere al proceso de refinar y mejorar las soluciones ya conocidas que han demostrado ser prometedoras. El objetivo es converger hacia el mejor punto dentro de una región ya identificada.</li>
            <li><strong>Mecanismos en AG:</strong> Principalmente la <strong>selección</strong> (que favorece a los individuos más aptos) y el <strong>cruzamiento</strong> (que combina los "bloques constructivos" de individuos aptos). El elitismo también es una forma fuerte de explotación.</li>
            <li><strong>Importancia:</strong> Permite que el algoritmo converja hacia soluciones de alta calidad una vez que se han encontrado regiones prometedoras.</li>
          </ul>
        </li>
      </ul>
      <p><strong>Equilibrio entre Exploración y Explotación:</strong></p>
      <p>El rendimiento de un AG depende críticamente del equilibrio adecuado entre estas dos fuerzas:</p>
      <ul>
        <li><strong>Demasiada Exploración (poca explotación):</strong> El algoritmo puede vagar por el espacio de soluciones sin converger nunca a una solución buena. La búsqueda se vuelve demasiado aleatoria.</li>
        <li><strong>Demasiada Explotación (poca exploración):</strong> El algoritmo puede converger prematuramente a un óptimo local, perdiendo la oportunidad de encontrar mejores soluciones en otras partes del espacio.</li>
      </ul>
      <p>Los AG intentan equilibrar esto a través de:</p>
      <ul>
        <li><strong>Fases de Búsqueda:</strong> A menudo, la exploración domina en las primeras generaciones (cuando la diversidad es alta), y la explotación se vuelve más prominente en etapas posteriores a medida que la población converge.</li>
        <li><strong>Parámetros del Algoritmo:</strong> La tasa de mutación (principalmente exploración), la tasa de cruzamiento (principalmente explotación/recombinación), la presión selectiva (explotación), y el tamaño de la población influyen en este equilibrio.</li>
        <li><strong>Mecanismos Avanzados:</strong> Técnicas como la mutación adaptativa, el reseteo parcial, y los algoritmos meméticos (con búsqueda local) están diseñadas explícitamente para gestionar mejor este equilibrio dinámicamente.</li>
      </ul>
      <p>Lograr el equilibrio óptimo suele ser dependiente del problema y a menudo requiere experimentación y ajuste de parámetros.</p>
    </div>

    <!-- Pregunta 19 (Nueva) -->
    <button class="section-toggle-button" onclick="toggleSection('faq_concept_3', this)" aria-expanded="false" aria-controls="faq_concept_3">
      <span>19. ¿Cuáles son las principales ventajas y desventajas de utilizar Algoritmos Genéticos para la optimización?</span><span class="icon">►</span>
    </button>
    <div id="faq_concept_3" class="content-panel">
      <p><strong class="panel-label">Respuesta Detallada:</strong></p>
      <p>Los Algoritmos Genéticos ofrecen un enfoque potente y flexible para la optimización, pero también tienen sus limitaciones.</p>
      <p><strong>Ventajas:</strong></p>
      <ol>
        <li><strong>Robustez en Paisajes Complejos:</strong> Son eficaces en espacios de búsqueda grandes, complejos, multimodales (con muchos óptimos locales) y no diferenciables, donde los métodos basados en gradiente fallarían.</li>
        <li><strong>Exploración Global:</strong> Su naturaleza poblacional y el operador de mutación les permiten explorar una amplia gama de soluciones, reduciendo la probabilidad de quedar atrapados en óptimos locales de baja calidad.</li>
        <li><strong>Paralelización Inherente:</strong> La evaluación del fitness de los individuos de la población se puede realizar en paralelo, lo que los hace adecuados para arquitecturas de cómputo modernas.</li>
        <li><strong>Flexibilidad en la Representación:</strong> Pueden adaptarse a una gran variedad de tipos de problemas mediante diferentes esquemas de codificación (binaria, real, permutaciones, árboles, etc.).</li>
        <li><strong>No Requieren Información del Gradiente:</strong> Funcionan basándose únicamente en la función de fitness, sin necesidad de derivadas u otra información auxiliar sobre el problema.</li>
        <li><strong>Adaptabilidad a Restricciones:</strong> Las restricciones del problema pueden incorporarse a menudo en la función de fitness mediante penalizaciones o mediante operadores genéticos especializados que preservan la viabilidad.</li>
      </ol>
      <p><strong>Desventajas:</strong></p>
      <ol>
        <li><strong>Convergencia Lenta:</strong> Pueden requerir un número significativo de evaluaciones de la función de fitness (muchas generaciones) para converger a soluciones de alta calidad, especialmente en problemas muy grandes.</li>
        <li><strong>Ajuste de Parámetros:</strong> El rendimiento de un AG puede ser sensible a la elección de sus parámetros (tamaño de población, tasas de mutación/cruce, método de selección, etc.), que a menudo deben ajustarse empíricamente.</li>
        <li><strong>No Hay Garantía de Optimalidad Global:</strong> Como heurísticas, no garantizan encontrar la solución óptima global, aunque suelen encontrar soluciones muy buenas o casi óptimas.</li>
        <li><strong>Convergencia Prematura:</strong> Si no se maneja adecuadamente la diversidad, pueden converger prematuramente a un óptimo local.</li>
        <li><strong>Diseño de la Función de Fitness:</strong> Definir una función de fitness adecuada que guíe correctamente la evolución puede ser un desafío en algunos problemas.</li>
        <li><strong>Complejidad de la Implementación:</strong> Aunque los conceptos básicos son simples, una implementación robusta y eficiente con mecanismos avanzados puede ser compleja.</li>
      </ol>
    </div>

    <!-- Pregunta 20 (Nueva) -->
    <button class="section-toggle-button" onclick="toggleSection('faq_concept_4', this)" aria-expanded="false" aria-controls="faq_concept_4">
      <span>20. En el contexto de AlphaEvolve, ¿cómo la capacidad de los LLMs para entender y generar código transforma los operadores genéticos tradicionales?</span><span class="icon">►</span>
    </button>
    <div id="faq_concept_4" class="content-panel">
      <p><strong class="panel-label">Respuesta Detallada:</strong></p>
      <p>La integración de Modelos de Lenguaje de Gran Escala (LLMs) en sistemas como AlphaEvolve transforma radicalmente la naturaleza y capacidad de los operadores genéticos tradicionales (mutación y cruzamiento) cuando se aplican a la evolución de código:</p>
      <ol>
        <li><strong>Operadores Semánticamente Conscientes:</strong>
          <ul>
            <li><strong>Tradicional:</strong> Los operadores genéticos clásicos (ej. inversión de bit, swap de genes) son a menudo "ciegos" a la semántica del código. Realizan cambios estructurales sin entender la función del código.</li>
            <li><strong>AlphaEvolve (con LLMs):</strong> Los LLMs actúan como operadores que **entienden la sintaxis y, hasta cierto punto, la semántica del lenguaje de programación**. Pueden proponer modificaciones que son no solo sintácticamente correctas sino también lógicamente coherentes y orientadas a un objetivo (ej. "refactoriza esta función para mejorar su eficiencia" o "introduce manejo de errores aquí").</li>
          </ul>
        </li>
        <li><strong>Mutaciones Más Inteligentes y Dirigidas:</strong>
          <ul>
            <li><strong>Tradicional:</strong> La mutación es típicamente aleatoria y pequeña (ej. cambiar un bit, intercambiar dos elementos).</li>
            <li><strong>AlphaEvolve:</strong> Los LLMs pueden realizar "mutaciones" mucho más sofisticadas. Pueden reescribir secciones enteras de código, introducir nuevos algoritmos o estructuras de datos, o aplicar patrones de diseño complejos, basándose en el contexto proporcionado en el prompt (que incluye el código existente y los objetivos de mejora).</li>
          </ul>
        </li>
        <li><strong>Cruzamiento Conceptual:</strong>
          <ul>
            <li><strong>Tradicional:</strong> El cruzamiento combina segmentos de cromosomas padres. En la evolución de código tradicional (programación genética basada en árboles), esto significa intercambiar subárboles.</li>
            <li><strong>AlphaEvolve:</strong> Aunque no se describa un "cruzamiento" directo entre dos programas padres de la misma forma, los LLMs pueden lograr un "cruzamiento conceptual". Al ser expuestos a múltiples programas exitosos (padres o ejemplos de la base de datos) en el prompt, el LLM puede **sintetizar ideas de diferentes fuentes** para generar una nueva solución que combine las fortalezas de varias aproximaciones previas.</li>
          </ul>
        </li>
        <li><strong>Generación de Operadores "Sobre la Marcha":</strong>
          <ul>
            <li><strong>Tradicional:</strong> Los operadores genéticos son predefinidos.</li>
            <li><strong>AlphaEvolve:</strong> Los LLMs, guiados por prompts (que pueden ser evolucionados ellos mismos mediante meta-prompts), pueden ser vistos como una forma de **generar o aplicar operadores de modificación de código de manera adaptativa y contextual**, sin necesidad de que el programador humano defina explícitamente cada posible tipo de transformación.</li>
          </ul>
        </li>
        <li><strong>Manejo de Código Complejo y Extenso:</strong>
          <ul>
            <li><strong>Tradicional:</strong> La evolución directa de código complejo con operadores tradicionales es muy difícil debido a la fragilidad y la interdependencia del código.</li>
            <li><strong>AlphaEvolve:</strong> Los LLMs, especialmente con su capacidad para trabajar con "diffs" y entender contextos largos, están mejor equipados para proponer cambios coherentes en bases de código más grandes y complejas.</li>
          </ul>
        </li>
      </ol>
      <p>En resumen, los LLMs en AlphaEvolve elevan los operadores genéticos de simples manipulaciones sintácticas a transformaciones de código más inteligentes, semánticamente ricas y dirigidas por objetivos, lo que permite abordar la evolución de programas a una escala y complejidad mucho mayores.</p>
    </div>

  </div> <!-- Fin de .faq-container -->

  <script>
    function toggleFaqTheme() {
      document.body.classList.toggle("dark-mode");
      let themeButton = document.getElementById('theme-toggle-faq-btn');
      let isDarkMode = document.body.classList.contains("dark-mode");
      localStorage.setItem("faq_theme_ag_colab_conceptual", isDarkMode ? "dark" : "light"); // Clave única
      if (themeButton) {
          themeButton.textContent = isDarkMode ? "Modo Claro" : "Modo Oscuro";
      }
    }

    function toggleSection(id, buttonElement) {
      let panel = document.getElementById(id);
      let icon = buttonElement.querySelector('.icon');
      if (panel && buttonElement) {
          panel.classList.toggle('is-visible');
          let isVisible = panel.classList.contains('is-visible');
          buttonElement.setAttribute('aria-expanded', isVisible);
          buttonElement.classList.toggle('is-expanded', isVisible);
          if (icon) {
              icon.textContent = isVisible ? '▼' : '►';
          }
      }
    }

    window.addEventListener('load', () => {
      let themeButton = document.getElementById('theme-toggle-faq-btn');
      const savedTheme = localStorage.getItem("faq_theme_ag_colab_conceptual"); // Usar clave única

      if (savedTheme === "dark") {
        document.body.classList.add("dark-mode");
        if (themeButton) { themeButton.textContent = "Modo Claro"; }
      } else {
        document.body.classList.remove("dark-mode");
        if (themeButton) { themeButton.textContent = "Modo Oscuro"; }
      }

      document.querySelectorAll('.faq-container .content-panel').forEach(panel => {
         panel.classList.remove('is-visible');
         // panel.style.maxHeight = '0'; // CSS maneja esto con la clase
      });
      document.querySelectorAll('.faq-container .section-toggle-button').forEach(button => {
          button.setAttribute('aria-expanded', 'false');
          button.classList.remove('is-expanded');
          let icon = button.querySelector('.icon');
          if (icon) {
              icon.textContent = '►';
          }
       });
    });
  </script>
</body>
</html>
"""

# Mostrar el HTML en la salida de la celda
display(HTML(html_content))

# Importar las funciones necesarias de IPython para mostrar HTML
from IPython.core.display import display, HTML

# Definir el contenido HTML, CSS y JavaScript como un string multilínea
html_glossary_content = """
<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Glosario: Algoritmos Genéticos, Evolución de Código y Conceptos Relacionados</title>
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&family=Lora:ital,wght@0,400;0,700&display=swap" rel="stylesheet">
  <style>
    :root {
      --bg-color: #fafbfd; /* Un blanco muy sutil, ligeramente azulado */
      --text-color: #3a3f51; /* Un gris oscuro azulado */
      --header-color: #2a72c5; /* Azul principal */
      --header-dark-color: #a3c7f0; /* Azul claro para modo oscuro */
      --accent-color: #10ac84; /* Verde azulado (teal) */
      --accent-dark-color: #58d68d; /* Verde más claro */
      --button-bg: #3498db; /* Azul cielo */
      --button-hover-bg: #2980b9; /* Azul más oscuro */
      --button-dark-bg: #e88e30; /* Naranja */
      --button-dark-hover-bg: #ca6f1e; /* Naranja oscuro */
      --button-text-color: white;
      --theme-button-bg: #9b59b6; /* Amatista */
      --theme-button-dark-bg: #f1c40f; /* Amarillo girasol */
      --content-panel-bg: #f1f8ff; /* Azul muy pálido */
      --content-panel-dark-bg: #3a4759; /* Gris azulado oscuro */
      --panel-label-color: var(--accent-color);
      --panel-label-dark-color: var(--accent-dark-color);
      --icon-color: var(--button-text-color);
      --term-title-color: var(--header-color);
      --term-title-dark-color: var(--header-dark-color);
    }

    body {
      font-family: 'Lora', 'Roboto', serif;
      line-height: 1.85;
      background-color: var(--bg-color);
      color: var(--text-color);
      transition: background-color 0.3s, color 0.3s;
      padding: 20px;
      margin: 0;
    }
    .glossary-container {
      max-width: 1000px;
      margin: auto;
      padding: 25px;
      position: relative;
      background-color: var(--bg-color);
      border-radius: 10px;
      box-shadow: 0 4px 15px rgba(0,0,0,0.08);
    }
    body.dark-mode .glossary-container {
        box-shadow: 0 4px 18px rgba(0,0,0,0.3);
    }
    body.dark-mode {
      --bg-color: #283141; /* Azul noche */
      --text-color: #dbe4f0; /* Blanco azulado */
      --header-color: var(--header-dark-color);
      --accent-color: var(--accent-dark-color);
      --button-bg: var(--button-dark-bg);
      --button-hover-bg: var(--button-dark-hover-bg);
      --content-panel-bg: var(--content-panel-dark-bg);
      --panel-label-color: var(--panel-label-dark-color);
      --term-title-color: var(--term-title-dark-color);
    }

    .glossary-container h1 {
      font-family: 'Roboto', sans-serif;
      font-size: 2.5em;
      color: var(--header-color);
      text-align: center;
      margin-bottom: 30px;
      padding-bottom: 12px;
      border-bottom: 3px solid var(--accent-color);
    }
     .glossary-container h2.section-category-title {
        font-family: 'Roboto', sans-serif;
        font-size: 1.7em;
        color: var(--accent-color);
        margin-top: 35px;
        margin-bottom: 10px;
        padding-bottom: 6px;
        border-bottom: 1px solid var(--accent-color);
    }

    .definition-panel {
      max-height: 0;
      overflow: hidden;
      transition: max-height 0.4s ease-in-out, padding-top 0.4s ease-in-out, padding-bottom 0.4s ease-in-out;
      margin-top: 0;
      padding: 0 25px;
      border-left: 5px solid var(--accent-color);
      background-color: var(--content-panel-bg);
      border-radius: 0 0 8px 8px;
    }
    .definition-panel.is-visible {
      max-height: 1500px; /* Ajustar según necesidad */
      padding-top: 20px;
      padding-bottom: 20px;
    }
    .definition-panel p, .definition-panel ul, .definition-panel ol {
        margin-bottom: 1.15em;
        font-size: 1.02em;
    }
    .definition-panel p:last-child, .definition-panel ul:last-child, .definition-panel ol:last-child {
        margin-bottom: 0;
    }
    .definition-panel strong.term-label { /* Para "Definición:" */
        color: var(--panel-label-color);
        font-family: 'Roboto', sans-serif;
        font-size: 1.1em;
        display: block;
        margin-bottom: 0.7em;
    }


    .term-toggle-button {
      background-color: var(--button-bg);
      color: var(--button-text-color);
      border: none;
      padding: 14px 20px;
      border-radius: 8px;
      cursor: pointer;
      margin-top: 10px;
      transition: background-color 0.3s, border-radius 0.2s;
      width: 100%;
      text-align: left;
      font-family: 'Roboto', sans-serif;
      font-size: 1.15em;
      font-weight: 700;
      display: flex;
      align-items: center;
      justify-content: space-between;
    }
    .term-toggle-button:hover {
      background-color: var(--button-hover-bg);
    }
    .term-toggle-button.is-expanded {
        border-radius: 8px 8px 0 0;
    }
    .term-toggle-button .term-text {
        color: var(--button-text-color); /* Hereda, pero explícito */
    }
    .term-toggle-button .icon {
        margin-left: 12px;
        font-size: 0.9em;
        color: var(--icon-color);
        transition: transform 0.3s ease-out;
    }
    .term-toggle-button.is-expanded .icon {
        transform: rotate(90deg);
    }


    .theme-toggle-glossary {
      background-color: var(--theme-button-bg);
      color: white;
      border: none;
      padding: 10px 15px;
      border-radius: 8px;
      cursor: pointer;
      position: absolute;
      top: 30px;
      right: 25px;
      font-size: 0.9em;
      font-family: 'Roboto', sans-serif;
      transition: background-color 0.3s;
      z-index: 100;
    }
    body.dark-mode .theme-toggle-glossary {
       background-color: var(--theme-button-dark-bg);
       color: var(--text-color);
    }

    button:focus, a:focus {
        outline: 3px solid var(--accent-color);
        outline-offset: 2px;
    }
    body.dark-mode button:focus, body.dark-mode a:focus {
         outline-color: var(--accent-dark-color);
    }
    ul, ol {
        padding-left: 28px;
    }
    li {
        margin-bottom: 0.65em;
    }
    strong {
        font-weight: 700;
    }
    code {
      background-color: rgba(0,0,0,0.05);
      padding: 3px 6px;
      border-radius: 4px;
      font-family: 'Courier New', Courier, monospace;
      font-size: 0.92em;
    }
    body.dark-mode code {
      background-color: rgba(255,255,255,0.12);
    }
  </style>
</head>
<body>
  <div class="glossary-container">
    <button id="theme-toggle-glossary-btn" class="theme-toggle-glossary" onclick="toggleGlossaryTheme()" title="Cambiar tema de color">Modo Oscuro</button>

    <h1>Glosario: Algoritmos Genéticos, Evolución de Código y Conceptos Relacionados</h1>

    <!-- Categoría: Fundamentos de Algoritmos Genéticos -->
    <h2 class="section-category-title">Fundamentos de Algoritmos Genéticos</h2>
    <button class="term-toggle-button" onclick="toggleTerm('term_ag', this)" aria-expanded="false" aria-controls="term_ag">
      <span class="term-text">Algoritmo Genético (AG)</span><span class="icon">►</span>
    </button>
    <div id="term_ag" class="definition-panel">
      <p><strong class="term-label">Definición:</strong></p>
      <p>Técnica de búsqueda metaheurística inspirada en la evolución natural y la selección darwiniana. Opera sobre una población de soluciones candidatas (individuos), aplicando operadores genéticos (selección, cruzamiento, mutación) para evolucionar iterativamente hacia mejores soluciones con respecto a una función de fitness.</p>
    </div>

    <button class="term-toggle-button" onclick="toggleTerm('term_cromosoma', this)" aria-expanded="false" aria-controls="term_cromosoma">
      <span class="term-text">Cromosoma (Individuo)</span><span class="icon">►</span>
    </button>
    <div id="term_cromosoma" class="definition-panel">
      <p><strong class="term-label">Definición:</strong></p>
      <p>Representación codificada de una solución candidata a un problema. En un AG, la población está compuesta por múltiples cromosomas. Su estructura (ej. cadena binaria, permutación, árbol) depende de la naturaleza del problema.</p>
    </div>

    <button class="term-toggle-button" onclick="toggleTerm('term_fitness', this)" aria-expanded="false" aria-controls="term_fitness">
      <span class="term-text">Función de Fitness (Aptitud)</span><span class="icon">►</span>
    </button>
    <div id="term_fitness" class="definition-panel">
      <p><strong class="panel-label">Definición:</strong></p>
      <p>Función que asigna un valor numérico a cada individuo (cromosoma) de la población, indicando su calidad o "aptitud" como solución al problema. Guía el proceso de selección, favoreciendo a los individuos más aptos.</p>
    </div>

    <button class="term-toggle-button" onclick="toggleTerm('term_seleccion', this)" aria-expanded="false" aria-controls="term_seleccion">
      <span class="term-text">Selección</span><span class="icon">►</span>
    </button>
    <div id="term_seleccion" class="definition-panel">
      <p><strong class="panel-label">Definición:</strong></p>
      <p>Proceso mediante el cual se eligen individuos de la población actual para ser progenitores de la siguiente generación. Métodos comunes incluyen la selección por torneo, ruleta y elitismo. Está sesgada hacia individuos con mayor fitness.</p>
    </div>

    <button class="term-toggle-button" onclick="toggleTerm('term_cruzamiento', this)" aria-expanded="false" aria-controls="term_cruzamiento">
      <span class="term-text">Cruzamiento (Crossover / Recombinación)</span><span class="icon">►</span>
    </button>
    <div id="term_cruzamiento" class="definition-panel">
      <p><strong class="panel-label">Definición:</strong></p>
      <p>Operador genético que combina material genético de dos (o más) individuos progenitores para crear uno o más descendientes. Su objetivo es generar nuevas soluciones que hereden características deseables de sus padres, promoviendo la explotación de regiones prometedoras del espacio de búsqueda.</p>
    </div>

    <button class="term-toggle-button" onclick="toggleTerm('term_mutacion', this)" aria-expanded="false" aria-controls="term_mutacion">
      <span class="term-text">Mutación</span><span class="icon">►</span>
    </button>
    <div id="term_mutacion" class="definition-panel">
      <p><strong class="panel-label">Definición:</strong></p>
      <p>Operador genético que introduce pequeños cambios aleatorios en el cromosoma de un individuo. Su función principal es mantener la diversidad genética en la población, prevenir la convergencia prematura y permitir la exploración de nuevas áreas del espacio de soluciones.</p>
    </div>

    <button class="term-toggle-button" onclick="toggleTerm('term_elitismo', this)" aria-expanded="false" aria-controls="term_elitismo">
      <span class="term-text">Elitismo</span><span class="icon">►</span>
    </button>
    <div id="term_elitismo" class="definition-panel">
      <p><strong class="panel-label">Definición:</strong></p>
      <p>Estrategia que consiste en copiar directamente uno o más de los mejores individuos de la población actual a la siguiente generación, sin someterlos a cruzamiento o mutación. Asegura que la mejor solución encontrada no se pierda.</p>
    </div>

    <button class="term-toggle-button" onclick="toggleTerm('term_codificacion', this)" aria-expanded="false" aria-controls="term_codificacion">
      <span class="term-text">Codificación (Representación Genética)</span><span class="icon">►</span>
    </button>
    <div id="term_codificacion" class="definition-panel">
      <p><strong class="panel-label">Definición:</strong></p>
      <p>Forma en que una solución candidata al problema se traduce en un cromosoma manipulable por el AG. Ejemplos: cadenas binarias, permutaciones (TSP), secuencias de posiciones (laberintos), árboles (programación genética), o directamente código fuente (AlphaEvolve).</p>
    </div>

    <!-- Categoría: Aplicaciones y Problemas Específicos -->
    <h2 class="section-category-title">Aplicaciones y Problemas Específicos</h2>
    <button class="term-toggle-button" onclick="toggleTerm('term_tsp', this)" aria-expanded="false" aria-controls="term_tsp">
      <span class="term-text">Problema del Viajante (TSP)</span><span class="icon">►</span>
    </button>
    <div id="term_tsp" class="definition-panel">
      <p><strong class="panel-label">Definición:</strong></p>
      <p>Problema clásico de optimización combinatoria NP-hard. Consiste en encontrar la ruta más corta posible que visite un conjunto dado de ciudades exactamente una vez y regrese a la ciudad de origen.</p>
    </div>

    <button class="term-toggle-button" onclick="toggleTerm('term_laberinto', this)" aria-expanded="false" aria-controls="term_laberinto">
      <span class="term-text">Navegación en Laberintos</span><span class="icon">►</span>
    </button>
    <div id="term_laberinto" class="definition-panel">
      <p><strong class="panel-label">Definición:</strong></p>
      <p>Problema de encontrar un camino válido y óptimo (ej. más corto) desde un punto de inicio a un punto final en un entorno con obstáculos (paredes). Comúnmente modelado como una cuadrícula o matriz.</p>
    </div>

    <button class="term-toggle-button" onclick="toggleTerm('term_ciclo_hamiltoniano', this)" aria-expanded="false" aria-controls="term_ciclo_hamiltoniano">
      <span class="term-text">Ciclo Hamiltoniano (HC)</span><span class="icon">►</span>
    </button>
    <div id="term_ciclo_hamiltoniano" class="definition-panel">
      <p><strong class="panel-label">Definición:</strong></p>
      <p>En teoría de grafos, un ciclo en un grafo que visita cada vértice exactamente una vez. Encontrar un ciclo Hamiltoniano es un problema NP-completo. El TSP es una generalización donde se busca el HC de menor coste.</p>
    </div>

    <!-- Categoría: Conceptos Avanzados en AG -->
    <h2 class="section-category-title">Conceptos Avanzados en AG</h2>
    <button class="term-toggle-button" onclick="toggleTerm('term_mut_adaptativa', this)" aria-expanded="false" aria-controls="term_mut_adaptativa">
      <span class="term-text">Mutación Adaptativa</span><span class="icon">►</span>
    </button>
    <div id="term_mut_adaptativa" class="definition-panel">
      <p><strong class="panel-label">Definición:</strong></p>
      <p>Técnica donde la tasa de mutación se ajusta dinámicamente durante la evolución, usualmente en función de la diversidad de la población o del progreso del fitness, para balancear exploración y explotación.</p>
    </div>

    <button class="term-toggle-button" onclick="toggleTerm('term_reseteo_parcial', this)" aria-expanded="false" aria-controls="term_reseteo_parcial">
      <span class="term-text">Reseteo Parcial de Población</span><span class="icon">►</span>
    </button>
    <div id="term_reseteo_parcial" class="definition-panel">
      <p><strong class="panel-label">Definición:</strong></p>
      <p>Mecanismo para combatir el estancamiento que consiste en reemplazar una porción de la población (excepto quizás la élite) con nuevos individuos generados aleatoriamente, para reintroducir diversidad.</p>
    </div>

    <button class="term-toggle-button" onclick="toggleTerm('term_alg_memetico', this)" aria-expanded="false" aria-controls="term_alg_memetico">
      <span class="term-text">Algoritmo Memético (Búsqueda Local Híbrida)</span><span class="icon">►</span>
    </button>
    <div id="term_alg_memetico" class="definition-panel">
      <p><strong class="panel-label">Definición:</strong></p>
      <p>Un AG híbrido que combina la exploración global del AG con técnicas de búsqueda local para refinar individuos, mejorando la calidad de la solución y la velocidad de convergencia. Ejemplo: aplicar 2-opt en soluciones del TSP.</p>
    </div>

    <button class="term-toggle-button" onclick="toggleTerm('term_map_elites', this)" aria-expanded="false" aria-controls="term_map_elites">
      <span class="term-text">MAP-Elites</span><span class="icon">►</span>
    </button>
    <div id="term_map_elites" class="definition-panel">
      <p><strong class="panel-label">Definición:</strong></p>
      <p>Algoritmo de iluminación que busca encontrar un conjunto de soluciones de alta calidad que sean diversas con respecto a múltiples dimensiones de características definidas por el usuario. Mantiene un archivo (mapa) de las mejores soluciones encontradas para cada celda en un espacio de características discretizado.</p>
    </div>

    <!-- Categoría: AlphaEvolve y Evolución de Código -->
    <h2 class="section-category-title">AlphaEvolve y Evolución de Código</h2>
    <button class="term-toggle-button" onclick="toggleTerm('term_alphaevolve', this)" aria-expanded="false" aria-controls="term_alphaevolve">
      <span class="term-text">AlphaEvolve</span><span class="icon">►</span>
    </button>
    <div id="term_alphaevolve" class="definition-panel">
      <p><strong class="panel-label">Definición:</strong></p>
      <p>Un agente de evolución de código desarrollado por Google DeepMind que utiliza un ensamblaje de Modelos de Lenguaje de Gran Escala (LLMs) dentro de un marco de computación evolutiva para mejorar y descubrir algoritmos y código en general. Puede operar sobre archivos de código completos y en diversos lenguajes.</p>
    </div>

    <button class="term-toggle-button" onclick="toggleTerm('term_llm', this)" aria-expanded="false" aria-controls="term_llm">
      <span class="term-text">Modelo de Lenguaje de Gran Escala (LLM)</span><span class="icon">►</span>
    </button>
    <div id="term_llm" class="definition-panel">
      <p><strong class="panel-label">Definición:</strong></p>
      <p>Un modelo de inteligencia artificial entrenado con grandes cantidades de datos de texto (y código) capaz de comprender, generar y manipular lenguaje natural y código de programación. En AlphaEvolve, los LLMs actúan como operadores de mutación y cruzamiento "inteligentes".</p>
    </div>

    <button class="term-toggle-button" onclick="toggleTerm('term_prompt_sampler', this)" aria-expanded="false" aria-controls="term_prompt_sampler">
      <span class="term-text">Prompt Sampler (Muestreador de Prompts)</span><span class="icon">►</span>
    </button>
    <div id="term_prompt_sampler" class="definition-panel">
      <p><strong class="panel-label">Definición:</strong></p>
      <p>Componente de AlphaEvolve que construye los prompts (instrucciones) para los LLMs. Utiliza programas de la base de datos evolutiva, contexto explícito, resultados de evaluación y meta-prompts para guiar a los LLMs en la generación de modificaciones de código útiles.</p>
    </div>

    <button class="term-toggle-button" onclick="toggleTerm('term_meta_prompt', this)" aria-expanded="false" aria-controls="term_meta_prompt">
      <span class="term-text">Meta-Prompt</span><span class="icon">►</span>
    </button>
    <div id="term_meta_prompt" class="definition-panel">
      <p><strong class="panel-label">Definición:</strong></p>
      <p>En AlphaEvolve, son instrucciones y contexto sugeridos por el propio LLM en un paso adicional de generación de prompts. Estos meta-prompts pueden ser co-evolucionados, permitiendo al sistema aprender a mejorar la forma en que solicita modificaciones de código a los LLMs.</p>
    </div>

    <button class="term-toggle-button" onclick="toggleTerm('term_diff_codigo', this)" aria-expanded="false" aria-controls="term_diff_codigo">
      <span class="term-text">Diff (Diferencias de Código)</span><span class="icon">►</span>
    </button>
    <div id="term_diff_codigo" class="definition-panel">
      <p><strong class="panel-label">Definición:</strong></p>
      <p>Formato utilizado por AlphaEvolve para que los LLMs propongan cambios específicos al código. Representa las adiciones, eliminaciones y modificaciones a un bloque de código original (ej. formato `<<<<<<< SEARCH ... ======= ... >>>>>>> REPLACE`).</p>
    </div>

  </div> <!-- Fin de .glossary-container -->

  <script>
    function toggleGlossaryTheme() {
      document.body.classList.toggle("dark-mode");
      let themeButton = document.getElementById('theme-toggle-glossary-btn');
      let isDarkMode = document.body.classList.contains("dark-mode");
      localStorage.setItem("glossary_theme_colab", isDarkMode ? "dark" : "light"); // Clave única
      if (themeButton) {
          themeButton.textContent = isDarkMode ? "Modo Claro" : "Modo Oscuro";
      }
    }

    function toggleTerm(id, buttonElement) { // Renombrada para evitar conflictos
      let panel = document.getElementById(id);
      let icon = buttonElement.querySelector('.icon');
      if (panel && buttonElement) {
          panel.classList.toggle('is-visible');
          let isVisible = panel.classList.contains('is-visible');
          buttonElement.setAttribute('aria-expanded', isVisible);
          buttonElement.classList.toggle('is-expanded', isVisible);
          if (icon) {
              icon.textContent = isVisible ? '▼' : '►';
          }
      }
    }

    window.addEventListener('load', () => {
      let themeButton = document.getElementById('theme-toggle-glossary-btn');
      const savedTheme = localStorage.getItem("glossary_theme_colab");

      if (savedTheme === "dark") {
        document.body.classList.add("dark-mode");
        if (themeButton) { themeButton.textContent = "Modo Claro"; }
      } else {
        document.body.classList.remove("dark-mode");
        if (themeButton) { themeButton.textContent = "Modo Oscuro"; }
      }

      document.querySelectorAll('.glossary-container .definition-panel').forEach(panel => {
         panel.classList.remove('is-visible');
      });
      document.querySelectorAll('.glossary-container .term-toggle-button').forEach(button => {
          button.setAttribute('aria-expanded', 'false');
          button.classList.remove('is-expanded');
          let icon = button.querySelector('.icon');
          if (icon) {
              icon.textContent = '►';
          }
       });
    });
  </script>
</body>
</html>
"""

# Mostrar el HTML en la salida de la celda
display(HTML(html_glossary_content))