<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>An√°lisis de Rendimiento en GPU: Un Caso de Estudio con Grafos</title>
    <style>
        /* --- ESTILOS GENERALES Y TEMATIZACI√ìN --- */
        * { margin: 0; padding: 0; box-sizing: border-box; }
        :root {
            --bg-primary: linear-gradient(135deg, #1e3a8a 0%, #a21caf 100%);
            --bg-secondary: rgba(255, 255, 255, 0.9);
            --text-primary: #111827;
            --text-secondary: #4b5563;
            --accent-primary: #1e40af;
            --accent-secondary: #a21caf;
            --accent-active: #16a34a;
            --accent-idle: #9ca3af;
            --card-bg: rgba(255, 255, 255, 0.85);
            --border-color: rgba(0, 0, 0, 0.1);
            --shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.2);
            --transition: all 0.3s ease-in-out;
        }
        [data-theme="dark"] {
            --bg-primary: linear-gradient(135deg, #1e293b 0%, #3730a3 100%);
            --bg-secondary: rgba(15, 23, 42, 0.9);
            --text-primary: #e5e7eb;
            --text-secondary: #94a3b8;
            --accent-primary: #60a5fa;
            --accent-secondary: #f0abfc;
            --accent-active: #4ade80;
            --accent-idle: #4b5563;
            --card-bg: rgba(30, 41, 59, 0.85);
            --border-color: rgba(255, 255, 255, 0.1);
            --shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.3);
        }
        html { scroll-behavior: smooth; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background: var(--bg-primary); color: var(--text-primary);
            min-height: 100vh; overflow-x: hidden; position: relative;
            line-height: 1.7; transition: var(--transition);
        }

        /* --- BURBUJAS DE FONDO --- */
        .bubbles { position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; z-index: -1; }
        .bubble { position: absolute; bottom: -150px; background: rgba(255, 255, 255, 0.05); border-radius: 50%; animation: rise 45s infinite ease-in; }
        @keyframes rise {
            0% { transform: translateY(0); opacity: 0; }
            10% { opacity: 0.4; }
            90% { opacity: 0.4; }
            100% { transform: translateY(-100vh); opacity: 0; }
        }

        /* --- LAYOUT Y CONTENEDORES --- */
        .container { max-width: 1200px; margin: 0 auto; padding: 2rem; position: relative; z-index: 1; }
        .header { text-align: center; margin-bottom: 3rem; }
        .main-title {
            font-size: clamp(2.2rem, 5vw, 3.5rem); font-weight: 800;
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            background-clip: text; margin-bottom: 1rem; color: white;
        }
        [data-theme="light"] .main-title { color: var(--text-primary); }
        .subtitle { font-size: 1.2rem; color: var(--text-secondary); max-width: 900px; margin: 0 auto; }
        .card {
            background: var(--card-bg); backdrop-filter: blur(15px); -webkit-backdrop-filter: blur(15px);
            border: 1px solid var(--border-color); border-radius: 20px; padding: 2.5rem;
            margin-bottom: 2.5rem; box-shadow: var(--shadow); transition: var(--transition);
        }
        h2 { font-size: 2rem; color: var(--accent-primary); margin-bottom: 1.5rem; }
        h3 { font-size: 1.5rem; color: var(--text-primary); margin: 2rem 0 1rem; }
        h4 { font-size: 1.2rem; color: var(--accent-secondary); margin-top: 1.5rem; }
        
        /* --- FORMATO DE TEXTO Y GLOSARIO --- */
        code {
            background-color: rgba(162, 28, 175, 0.1); color: var(--accent-secondary);
            padding: 0.2em 0.4em; border-radius: 5px;
            font-family: 'SF Mono', 'Fira Code', monospace;
        }
        strong, dt { color: var(--accent-primary); font-weight: 600; }
        dl { margin-top: 1rem; }
        dd { margin-left: 1.5rem; margin-bottom: 1rem; }

        /* --- PANEL DE SIMULACI√ìN --- */
        .dashboard { text-align: center; }
        .dashboard-grid {
            display: grid; grid-template-columns: 1fr 1fr; gap: 2rem; margin-top: 1rem;
        }
        @media (max-width: 900px) { .dashboard-grid { grid-template-columns: 1fr; } }
        .perf-panel {
            border: 1px solid var(--border-color); border-radius: 15px;
            padding: 1.5rem; background: rgba(0,0,0,0.05);
        }
        [data-theme="dark"] .perf-panel { background: rgba(0,0,0,0.2); }
        .perf-metric { margin-bottom: 1.5rem; }
        .perf-metric h5 { margin-bottom: 0.5rem; }
        .chart-canvas { width: 100%; height: 150px; background: rgba(0,0,0,0.05); border-radius: 8px; }
        [data-theme="dark"] .chart-canvas { background: rgba(0,0,0,0.2); }
        
        .warp-visualizer {
            display: grid; grid-template-columns: repeat(8, 1fr); gap: 4px;
            height: 80px; padding: 4px;
        }
        .thread {
            width: 100%; height: 100%; background-color: var(--accent-idle);
            border-radius: 2px; transition: background-color 0.5s;
        }
        .thread.active { background-color: var(--accent-active); }
        
        .memory-visualizer {
            height: 40px; border: 1px solid var(--border-color);
            background: repeating-linear-gradient(45deg, rgba(0,0,0,0.05), rgba(0,0,0,0.05) 10px, rgba(0,0,0,0.08) 10px, rgba(0,0,0,0.08) 20px);
            position: relative; overflow: hidden;
        }
        .memory-access {
            position: absolute; top: 0; height: 100%;
            background-color: var(--accent-primary); opacity: 0.7;
            transition: all 0.5s;
        }

        #start-sim-btn {
            padding: 0.8rem 2rem; font-size: 1.1rem; border: none;
            border-radius: 10px; background-color: var(--accent-primary); color: white;
            cursor: pointer; transition: var(--transition);
        }
        #start-sim-btn:hover { transform: translateY(-2px); box-shadow: var(--shadow); }
        #sim-status { font-weight: bold; margin-top: 1rem; font-family: 'SF Mono', monospace; }

        /* --- OTROS --- */
        .theme-toggle {
            position: fixed; top: 1.5rem; right: 1.5rem; width: 50px; height: 50px;
            border-radius: 50%; background: var(--card-bg); border: 1px solid var(--border-color);
            cursor: pointer; display: flex; align-items: center; justify-content: center;
            font-size: 1.2rem; color: var(--accent-primary); transition: var(--transition); z-index: 1000;
        }
        .theme-toggle:hover { transform: scale(1.1) rotate(360deg); box-shadow: var(--shadow); }
        footer { text-align: center; padding: 2rem; margin-top: 2rem; color: rgba(255,255,255,0.8); }
    </style>
</head>
<body data-theme="dark">

    <div class="bubbles" id="bubbles-container"></div>
    <button class="theme-toggle" id="theme-toggle-btn" title="Cambiar tema">üåô</button>

    <div class="container">
        <header class="header">
            <h1 class="main-title">An√°lisis de Rendimiento en GPU con Grafos</h1>
            <p class="subtitle">Un caso de estudio utilizando grafos casi irregulares para ilustrar c√≥mo sutiles diferencias en la distribuci√≥n de grados impactan dr√°sticamente el rendimiento de algoritmos en arquitecturas paralelas.</p>
        </header>

        <section class="card">
            <h2>Contexto: El Desaf√≠o de los Grafos en GPUs</h2>
            <p>En la computaci√≥n de alto rendimiento (HPC), las GPUs son clave para acelerar algoritmos. Sin embargo, su arquitectura SIMT (Single Instruction, Multiple Thread) es ideal para datos regulares y paralelos. Los grafos, con su estructura inherentemente irregular, presentan un desaf√≠o particular.</p>
            <h3>Los Grafos de Prueba</h3>
            <p>Utilizamos dos grafos de orden n=10 con secuencias de grado casi irregulares. Estas estructuras son perfectas para el an√°lisis porque su alta diversidad de grados exacerba los problemas de balanceo de carga en la GPU.</p>
            <ul>
                <li><strong>Grafo A (con V√©rtice Aislado):</strong> Grados <code>(8, 7, 6, 5, 4, 4, 3, 2, 1, 0)</code></li>
                <li><strong>Grafo B (Complemento, sin Aislado):</strong> Grados <code>(9, 8, 7, 6, 5, 5, 4, 3, 2, 1)</code></li>
            </ul>
        </section>

        <section class="card dashboard">
            <h2>Panel de Simulaci√≥n de Rendimiento BFS en GPU</h2>
            <p>Presiona el bot√≥n para simular la ejecuci√≥n de una B√∫squeda en Amplitud (BFS) en ambos grafos y comparar las m√©tricas de rendimiento clave a trav√©s de los niveles de la b√∫squeda.</p>
            <button id="start-sim-btn">Iniciar Simulaci√≥n</button>
            <p id="sim-status">Nivel BFS: -</p>
            <div class="dashboard-grid">
                <!-- Panel para Grafo A -->
                <div class="perf-panel">
                    <h3>Grafo A (con Aislado)</h3>
                    <div class="perf-metric">
                        <h5>Divergencia de Warp (% Hilos Activos)</h5>
                        <div class="warp-visualizer" id="warp-a"></div>
                    </div>
                    <div class="perf-metric">
                        <h5>Tama√±o de la Frontera</h5>
                        <canvas class="chart-canvas" id="frontier-a-canvas"></canvas>
                    </div>
                    <div class="perf-metric">
                        <h5>Acceso a Memoria</h5>
                        <div class="memory-visualizer" id="memory-a"></div>
                    </div>
                </div>
                <!-- Panel para Grafo B -->
                <div class="perf-panel">
                    <h3>Grafo B (sin Aislado)</h3>
                    <div class="perf-metric">
                        <h5>Divergencia de Warp (% Hilos Activos)</h5>
                        <div class="warp-visualizer" id="warp-b"></div>
                    </div>
                    <div class="perf-metric">
                        <h5>Tama√±o de la Frontera</h5>
                        <canvas class="chart-canvas" id="frontier-b-canvas"></canvas>
                    </div>
                    <div class="perf-metric">
                        <h5>Acceso a Memoria</h5>
                        <div class="memory-visualizer" id="memory-b"></div>
                    </div>
                </div>
            </div>
        </section>
        
        <section class="card">
            <h2>An√°lisis del Perfil de Rendimiento</h2>
            <p>Al ejecutar el BFS, emergen perfiles de rendimiento marcadamente distintos.</p>
            
            <h4>Grafo A: Cuellos de Botella por Desequilibrio Extremo</h4>
            <p>La presencia de v√©rtices de grado muy bajo (0 y 1) crea ineficiencias severas.</p>
            <ul>
                <li><strong>Hilos Inactivos y Divergencia:</strong> En un warp de 32 hilos, si un hilo procesa el v√©rtice de grado 1 mientras otros procesan v√©rtices de grado 8, el primero termina y queda inactivo, esperando a los dem√°s. Esto se llama <strong>divergencia de hilos</strong> y es una de las principales causas de ineficiencia en GPU.</li>
                <li><strong>Tama√±o de la Frontera:</strong> La frontera del BFS (nodos a visitar) es muy variable. Comienza grande y se reduce dr√°sticamente al alcanzar nodos de bajo grado, subutilizando la capacidad masivamente paralela de la GPU.</li>
                <li><strong>Coalescencia de Memoria:</strong> El acceso a memoria es √≥ptimo si los hilos de un warp leen direcciones contiguas (acceso coalescente). La alta variabilidad de grados en el Grafo A provoca accesos dispersos y <strong>no coalescentes</strong>, desperdiciando ancho de banda.</li>
            </ul>

            <h4>Grafo B: Rendimiento M√°s Robusto y Estable</h4>
            <p>La ausencia de v√©rtices de grado 0 y 1 mitiga los casos m√°s extremos.</p>
             <ul>
                <li><strong>Hilos Inactivos y Divergencia:</strong> La diferencia de trabajo entre el grado m√≠nimo (1) y el m√°ximo (9) sigue existiendo, pero se elimina el caso de "cero trabajo", reduciendo la inactividad y la severidad de la divergencia.</li>
                <li><strong>Tama√±o de la Frontera:</strong> La propagaci√≥n del BFS es m√°s robusta, resultando en un paralelismo m√°s sostenido a lo largo de las iteraciones, lo que es ideal para la GPU.</li>
                <li><strong>Coalescencia de Memoria:</strong> El perfil sigue siendo irregular, pero la estructura de grados ligeramente m√°s homog√©nea puede mejorar marginalmente la localidad de los accesos.</li>
            </ul>
        </section>

        <section class="card">
            <h2>Conclusiones Clave y Profundizaci√≥n</h2>
            <h3>Resumen de Hallazgos y Gu√≠a para Schedulers</h3>
            <p>Este caso de estudio revela que el principal cuello de botella en el procesamiento de grafos en GPU es el **desequilibrio de carga a nivel de warp**, causado por la alta variabilidad en la distribuci√≥n de grados. Incluso cambios sutiles, como eliminar un v√©rtice de grado cero, mejoran significativamente el perfil de rendimiento. La lecci√≥n para el dise√±o de un planificador (scheduler) es clara: las asignaciones ingenuas de "un v√©rtice por hilo" son ineficientes. Se deben priorizar estrategias como:</p>
            <ul>
                <li><strong>Agrupaci√≥n de tareas por grado</strong> para minimizar la divergencia.</li>
                <li><strong>Distribuci√≥n del trabajo a nivel de arista</strong> en lugar de v√©rtice.</li>
                <li><strong>Preprocesamiento del grafo</strong> para mejorar la localidad de los datos en memoria.</li>
            </ul>

            <h3>Glosario de Conceptos de GPU</h3>
            <dl>
                <dt>GPU (Unidad de Procesamiento Gr√°fico)</dt>
                <dd>Un procesador masivamente paralelo con miles de n√∫cleos, dise√±ado para ejecutar la misma operaci√≥n sobre grandes conjuntos de datos simult√°neamente.</dd>
                
                <dt>SIMT (Single Instruction, Multiple Thread)</dt>
                <dd>El modelo de ejecuci√≥n de las GPUs. Una √∫nica instrucci√≥n es emitida a un grupo de hilos, y cada hilo la aplica a su propio dato.</dd>
                
                <dt>Warp</dt>
                <dd>La unidad fundamental de planificaci√≥n en una GPU (t√≠picamente 32 hilos). Todos los hilos en un warp ejecutan la misma instrucci√≥n al mismo tiempo.</dd>
                
                <dt>Divergencia de Hilos</dt>
                <dd>Ocurre cuando los hilos dentro de un mismo warp necesitan tomar caminos diferentes en el c√≥digo (ej. un `if-else`). La GPU gestiona esto ejecutando ambas ramas secuencialmente, desactivando los hilos que no corresponden a la rama actual. Los hilos inactivos que esperan representan una p√©rdida total de eficiencia.</dd>
                
                <dt>Memoria Global</dt>
                <dd>La memoria principal y m√°s grande de la GPU. Es potente pero tiene una alta latencia, por lo que la eficiencia en su acceso es crucial.</dd>
                
                <dt>Acceso Coalescente</dt>
                <dd>El patr√≥n de acceso a memoria m√°s eficiente. Ocurre cuando los 32 hilos de un warp acceden a una regi√≥n de memoria contigua en una sola transacci√≥n. Los accesos dispersos (no coalescentes) requieren m√∫ltiples transacciones, degradando severamente el rendimiento.</dd>
            </dl>
            
            <h3>Estrategias Avanzadas y Futuro</h3>
            <p>La optimizaci√≥n de grafos en GPU es un campo activo. Las t√©cnicas avanzadas incluyen el **reordenamiento de v√©rtices** (usando algoritmos como RCM) para mejorar la localidad de la memoria y el uso de **representaciones de grafos h√≠bridas**, donde los v√©rtices de bajo grado se almacenan de una forma y los de alto grado de otra, para optimizar tanto el almacenamiento como el procesamiento.</p>
        </section>

        <footer>
            <p>Material elaborado por el profesor Sergio Gevatschnaider</p>
        </footer>
    </div>

    <script>
    document.addEventListener('DOMContentLoaded', () => {
        // --- M√ìDULO 1: UI ---
        const themeToggleBtn = document.getElementById('theme-toggle-btn');
        const set_theme = (theme) => {
            document.body.setAttribute('data-theme', theme);
            localStorage.setItem('theme', theme);
            themeToggleBtn.textContent = theme === 'dark' ? '‚òÄÔ∏è' : 'üåô';
        };
        themeToggleBtn.addEventListener('click', () => {
            const new_theme = document.body.getAttribute('data-theme') === 'dark' ? 'light' : 'dark';
            set_theme(new_theme);
        });
        set_theme(localStorage.getItem('theme') || 'dark');
        // Bubble generator omitted for brevity but would be here.

        // --- M√ìDULO 2: CLASE DEL SIMULADOR GPU ---
        class GPUSimulator {
            constructor() {
                this.warpAContainer = document.getElementById('warp-a');
                this.warpBContainer = document.getElementById('warp-b');
                this.frontierACanvas = document.getElementById('frontier-a-canvas');
                this.frontierBCanvas = document.getElementById('frontier-b-canvas');
                this.memoryAContainer = document.getElementById('memory-a');
                this.memoryBContainer = document.getElementById('memory-b');
                this.statusEl = document.getElementById('sim-status');
                
                this.simData = {
                    a: {
                        frontier: [1, 8, 15, 12, 5, 2],
                        activeThreads: [100, 80, 50, 40, 25, 15],
                        coalesced: [false, false, true, false, true, true]
                    },
                    b: {
                        frontier: [1, 9, 16, 14, 10, 6],
                        activeThreads: [100, 90, 75, 65, 55, 45],
                        coalesced: [false, true, true, false, true, true]
                    }
                };
                
                this.intervalId = null;
                this._initDOM();
            }

            _initDOM() {
                [this.warpAContainer, this.warpBContainer].forEach(container => {
                    container.innerHTML = '';
                    for (let i = 0; i < 32; i++) {
                        const threadDiv = document.createElement('div');
                        threadDiv.className = 'thread';
                        container.appendChild(threadDiv);
                    }
                });
                this.memoryAContainer.innerHTML = '';
                this.memoryBContainer.innerHTML = '';
            }
            
            _getThemeColors() {
                return {
                    line: getComputedStyle(document.documentElement).getPropertyValue('--accent-primary').trim(),
                    text: getComputedStyle(document.documentElement).getPropertyValue('--text-primary').trim(),
                };
            }
            
            _drawFrontierChart(canvas, data, step) {
                const ctx = canvas.getContext('2d');
                const { width, height } = canvas;
                ctx.clearRect(0, 0, width, height);

                const maxVal = Math.max(...this.simData.a.frontier, ...this.simData.b.frontier);
                const points = data.slice(0, step + 1);
                
                ctx.beginPath();
                ctx.strokeStyle = this._getThemeColors().line;
                ctx.lineWidth = 3;
                
                points.forEach((p, i) => {
                    const x = (i / (data.length - 1)) * width;
                    const y = height - (p / maxVal) * height * 0.9 - height * 0.05;
                    if (i === 0) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                });
                ctx.stroke();

                const lastX = (step / (data.length - 1)) * width;
                const lastY = height - (points[step] / maxVal) * height * 0.9 - height * 0.05;
                ctx.beginPath();
                ctx.arc(lastX, lastY, 5, 0, 2 * Math.PI);
                ctx.fillStyle = this._getThemeColors().line;
                ctx.fill();

                ctx.fillStyle = this._getThemeColors().text;
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'center';
                ctx.fillText(`Frontera: ${points[step]}`, width/2, 20);
            }
            
            _updateWarp(container, activePercentage) {
                const threads = container.children;
                const activeCount = Math.floor(32 * (activePercentage / 100));
                for (let i = 0; i < 32; i++) {
                    threads[i].classList.toggle('active', i < activeCount);
                }
                 const title = container.previousElementSibling;
                 title.textContent = `Divergencia de Warp (${activePercentage}% Activos)`;
            }

            _updateMemoryAccess(container, isCoalesced) {
                 container.innerHTML = '';
                const title = container.previousElementSibling;
                if (isCoalesced) {
                    title.textContent = 'Acceso a Memoria (Coalescente)';
                    const block = document.createElement('div');
                    block.className = 'memory-access';
                    block.style.left = '20%';
                    block.style.width = '30%';
                    container.appendChild(block);
                } else {
                    title.textContent = 'Acceso a Memoria (No Coalescente)';
                    for (let i = 0; i < 5; i++) {
                         const block = document.createElement('div');
                         block.className = 'memory-access';
                         block.style.left = `${10 + i * 18}%`;
                         block.style.width = '4%';
                         container.appendChild(block);
                    }
                }
            }

            run() {
                if (this.intervalId) clearInterval(this.intervalId);
                let step = 0;
                const totalSteps = this.simData.a.frontier.length;

                const updateStep = () => {
                    this.statusEl.textContent = `Nivel BFS: ${step + 1}`;
                    
                    this._drawFrontierChart(this.frontierACanvas, this.simData.a.frontier, step);
                    this._updateWarp(this.warpAContainer, this.simData.a.activeThreads[step]);
                    this._updateMemoryAccess(this.memoryAContainer, this.simData.a.coalesced[step]);

                    this._drawFrontierChart(this.frontierBCanvas, this.simData.b.frontier, step);
                    this._updateWarp(this.warpBContainer, this.simData.b.activeThreads[step]);
                    this._updateMemoryAccess(this.memoryBContainer, this.simData.b.coalesced[step]);

                    step++;
                    if (step >= totalSteps) {
                        clearInterval(this.intervalId);
                        this.statusEl.textContent = 'Simulaci√≥n Completada';
                    }
                };

                updateStep(); 
                this.intervalId = setInterval(updateStep, 1500);
            }
        }

        // --- M√ìDULO 3: CONTROLADOR ---
        const simulator = new GPUSimulator();
        const startBtn = document.getElementById('start-sim-btn');
        startBtn.addEventListener('click', () => simulator.run());
    });
    </script>
</body>
</html>