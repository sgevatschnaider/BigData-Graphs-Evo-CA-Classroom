<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Guía de Estudio: El Algoritmo de Held-Karp</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
  <style>
    :root {
      --bg-primary: linear-gradient(135deg, #11998e 0%, #38ef7d 100%);
      --bg-secondary: rgba(255, 255, 255, 0.9);
      --bg-tertiary: rgba(248, 250, 252, 0.85);
      --text-primary: #1a202c;
      --text-secondary: #4a5568;
      --text-light: #ffffff;
      --accent-primary: #16a085;
      --accent-secondary: #27ae60;
      --accent-gradient: linear-gradient(135deg, var(--accent-primary) 0%, var(--accent-secondary) 100%);
      --border-color: rgba(226, 232, 240, 0.9);
      --shadow-card: 0 15px 35px rgba(0, 0, 0, 0.08);
      --border-radius: 20px;
      --transition: all 0.4s cubic-bezier(0.25, 0.8, 0.25, 1);
    }
    [data-theme="dark"] {
      --bg-primary: linear-gradient(135deg, #0f2027 0%, #203a43 50%, #2c5364 100%);
      --bg-secondary: rgba(26, 32, 44, 0.9);
      --bg-tertiary: rgba(45, 55, 72, 0.75);
      --text-primary: #f7fafc;
      --text-secondary: #a0aec0;
      --accent-primary: #1ddde8;
      --accent-secondary: #38ef7d;
      --border-color: rgba(255, 255, 255, 0.15);
    }
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html { scroll-behavior: smooth; }
    body { font-family: 'Inter', sans-serif; line-height: 1.8; background: var(--bg-primary); color: var(--text-primary); transition: var(--transition); min-height: 100vh; position: relative; overflow-x: hidden; }
    
    .container { max-width: 1000px; margin: 0 auto; padding: 2rem; z-index: 1; }
    .header { text-align: center; margin-bottom: 3rem; position: relative; }
    .main-title { font-size: clamp(2.5rem, 5vw, 3.8rem); font-weight: 800; background: var(--accent-gradient); -webkit-background-clip: text; -webkit-text-fill-color: transparent; background-clip: text; margin-bottom: 1rem; }
    .subtitle { font-size: 1.4rem; color: var(--text-light); font-weight: 400; opacity: 0.95; text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3); max-width: 900px; margin: auto; }

    .theme-toggle { position: fixed; top: 2rem; right: 2rem; width: 60px; height: 60px; border: 1px solid var(--border-color); border-radius: 50%; background: var(--bg-secondary); backdrop-filter: blur(15px); box-shadow: var(--shadow-card); cursor: pointer; display: flex; align-items: center; justify-content: center; font-size: 1.4rem; color: var(--accent-primary); transition: var(--transition); z-index: 1000; }
    .theme-toggle:hover { transform: scale(1.15) rotate(180deg); box-shadow: 0 25px 50px rgba(0, 0, 0, 0.12), 0 0 30px rgba(22, 160, 133, 0.3); }

    .lesson-container { display: flex; flex-direction: column; gap: 1.5rem; }
    .topic-card { background: var(--bg-secondary); backdrop-filter: blur(20px); border-radius: var(--border-radius); box-shadow: var(--shadow-card); border: 2px solid var(--border-color); overflow: hidden; transition: var(--transition); }
    .topic-header { cursor: pointer; padding: 1.5rem 2rem; display: flex; justify-content: space-between; align-items: center; }
    .topic-title { font-size: 1.3rem; font-weight: 600; color: var(--text-primary); }
    .expand-icon { font-size: 1.2rem; color: var(--text-secondary); transition: var(--transition); }
    .topic-card.open .expand-icon { transform: rotate(180deg); }
    .topic-content { max-height: 0; overflow: hidden; transition: max-height 3s ease, padding 3s ease; background: var(--bg-tertiary); }
    .topic-card.open .topic-content { max-height: 9000px; padding: 1.5rem 2rem; border-top: 1px solid var(--border-color); }
    .topic-content p, .topic-content ul { color: var(--text-secondary); margin-bottom: 1.5rem; }
    .topic-content h4 { font-size: 1.2rem; color: var(--text-primary); margin-top: 2.5rem; margin-bottom: 1.5rem; font-weight: 600; border-bottom: 2px solid var(--border-color); padding-bottom: 0.5rem; }
    .topic-content ul { padding-left: 20px; }
    .topic-content li { margin-bottom: 1rem; line-height: 1.7; }
    .topic-content strong { color: var(--text-primary); font-weight: 600; }
    .topic-content code { font-family: 'JetBrains Mono', monospace; background-color: rgba(0,0,0,0.05); padding: 2px 6px; border-radius: 4px; color: var(--accent-primary); font-size: 0.9em; }
    [data-theme="dark"] .topic-content code { background-color: rgba(0,0,0,0.3); }
    
    .diagram-container { background: rgba(0,0,0,0.02); border: 1px solid var(--border-color); border-radius: 10px; padding: 1.5rem; margin: 2.5rem 0; font-family: 'JetBrains Mono', monospace; color: var(--text-secondary); }
    [data-theme="dark"] .diagram-container { background: rgba(0,0,0,0.2); }
    .diagram-title { font-weight: 600; text-align: center; margin-bottom: 2rem; color: var(--text-primary); font-size: 1rem; }
    .diagram-flow, .diagram-grid { display: flex; justify-content: space-around; align-items: center; gap: 1rem; flex-wrap: wrap;}
    .diagram-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); align-items: stretch; gap: 1.5rem; }
    .diagram-box { border: 2px solid var(--border-color); padding: 1rem; border-radius: 8px; text-align: center; background: var(--bg-secondary); box-shadow: var(--shadow-card); min-width: 120px; display: flex; flex-direction: column; justify-content: center; }
    .diagram-box strong { display: block; font-size: 0.9em; color: var(--text-primary); margin-bottom: 0.3rem; }
    .diagram-box span { font-size: 0.8em; }
    .diagram-arrow { flex-grow: 1; position: relative; text-align: center; }
    .diagram-arrow::after { content: '→'; font-size: 2.5rem; color: var(--accent-primary); }
    .diagram-arrow.down::after { content: '↓'; display: block; margin: 0.5rem 0; }
    .diagram-arrow-label { font-size: 0.8em; font-weight: 500; }
    .formula-box { font-family: 'JetBrains Mono', monospace; text-align: center; font-size: 1.1em; padding: 1rem; color: var(--text-primary); }
    .highlight { color: var(--accent-primary); font-weight: bold; }
    .sub-item { margin-left: 20px; border-left: 2px solid var(--border-color); padding-left: 15px; margin-top: 1rem; }
    
    table { width: 100%; border-collapse: collapse; text-align: center; font-family: 'JetBrains Mono', monospace; margin-top: 1rem; }
    th, td { padding: 10px; border: 1px solid var(--border-color); }
    th { background-color: rgba(0,0,0,0.05); color: var(--text-primary); font-weight: 600; }
    td:first-child, th:first-child { background-color: rgba(0,0,0,0.05); font-weight: 600; }
    [data-theme="dark"] th, [data-theme="dark"] td:first-child { background-color: rgba(255,255,255,0.05); }

    footer { text-align: center; margin-top: 4rem; padding: 2rem 0; border-top: 1px solid var(--border-color); }
    footer p { color: var(--text-light); opacity: 0.9; margin-bottom: 0.5rem; }
  </style>
</head>
<body data-theme="dark">
  <div class="theme-toggle" id="themeToggleButton" title="Cambiar tema"><i class="fas fa-moon" id="theme-icon"></i></div>
  
  <div class="container">
    <header class="header">
      <h1 class="main-title">El Algoritmo de Held-Karp</h1>
      <p class="subtitle">Optimizando el TSP con Programación Dinámica</p>
    </header>

    <div class="lesson-container">
        
        <div class="topic-card open">
            <div class="topic-header"><span class="topic-title">1. Introducción: Superando la Fuerza Bruta</span><i class="fas fa-chevron-down expand-icon"></i></div>
            <div class="topic-content">
                <p>El enfoque de fuerza bruta para el TSP, que evalúa todas las <code>O(n!)</code> permutaciones, es impracticable para más de unas pocas ciudades. El algoritmo de Held-Karp usa <strong>programación dinámica</strong> para reducir drásticamente esta complejidad.</p>
                <p>La idea central es brillante: descomponer el problema en subproblemas más pequeños, resolverlos y <strong>almacenar sus resultados (memoización)</strong>. De esta forma, las soluciones a los subproblemas se reutilizan para construir soluciones a problemas más grandes, evitando recalcular lo mismo una y otra vez.</p>
                <div class="diagram-container">
                    <div class="diagram-title">Salto Cuántico en Eficiencia</div>
                     <div class="diagram-grid">
                        <div class="diagram-box"><strong>Fuerza Bruta</strong><span>O(n!)<br>Prueba todo. Se vuelve imposible muy rápido.</span></div>
                        <div class="diagram-box"><strong>Held-Karp (DP)</strong><span>O(n² * 2ⁿ)<br>Construye sobre soluciones parciales. Mucho más rápido, aunque aún exponencial.</span></div>
                    </div>
                </div>
            </div>
        </div>

        <div class="topic-card">
            <div class="topic-header"><span class="topic-title">2. La Función de Programación Dinámica</span><i class="fas fa-chevron-down expand-icon"></i></div>
            <div class="topic-content">
                <p>Definimos la función clave <code>C(S, j)</code> como el costo mínimo de un camino que:</p>
                <ul>
                    <li>Parte de la ciudad inicial (llamémosla 1).</li>
                    <li>Visita todas las ciudades del conjunto <code>S</code>.</li>
                    <li>Termina exactamente en la ciudad <code>j</code>, donde <code>j</code> debe pertenecer a <code>S</code>.</li>
                </ul>
                
                <h4>Caso Base (El inicio del camino)</h4>
                <p>Si el conjunto <code>S</code> solo contiene a la ciudad <code>j</code>, el camino es simplemente ir del inicio a <code>j</code>. Por lo tanto:</p>
                <div class="formula-box">C({j}, j) = d(1, j)</div>

                <h4>Fórmula de Recurrencia (Construyendo el camino)</h4>
                <p>Para calcular el costo de llegar a <code>j</code> habiendo pasado por el conjunto <code>S</code>, debemos haber llegado desde una ciudad anterior <code>i</code> en ese mismo conjunto. El algoritmo explora todas las posibilidades y elige la mejor.</p>
                <div class="diagram-container">
                    <div class="diagram-title">Lógica de la Recurrencia</div>
                    <div class="diagram-flow">
                        <div class="diagram-box"><strong>Costo Óptimo Anterior</strong><span>C(S \ {j}, i)</span></div>
                        <div class="diagram-arrow"><div class="diagram-arrow-label">+ d(i, j)</div></div>
                        <div class="diagram-box"><strong>Nuevo Costo Óptimo</strong><span>C(S, j)</span></div>
                    </div>
                    <div class="formula-box">C(S, j) = min<sub>i ∈ S, i ≠ j</sub> ( C(S \ {j}, i) + d(i, j) )</div>
                </div>

                <h4>Resultado Final (Cerrando el ciclo)</h4>
                <p>Una vez calculados todos los subproblemas hasta el conjunto completo de ciudades <code>{2, ..., n}</code>, el costo final del TSP es el mínimo de todos los caminos posibles que regresan a la ciudad inicial 1.</p>
                 <div class="formula-box">Costo TSP = min<sub>j ∈ {2,...,n}</sub> ( C({2,...,n}, j) + d(j, 1) )</div>
            </div>
        </div>
        
        <div class="topic-card">
            <div class="topic-header"><span class="topic-title">3. 🔬 Ejemplo Numérico (n=4)</span><i class="fas fa-chevron-down expand-icon"></i></div>
            <div class="topic-content">
                <p>Usamos la ciudad 1 como inicio y la siguiente matriz de costos:</p>
                <div class="table-container">
                    <table>
                        <thead><tr><th>De/A</th><th>1</th><th>2</th><th>3</th><th>4</th></tr></thead>
                        <tbody>
                            <tr><td>1</td><td>0</td><td>10</td><td>15</td><td>20</td></tr>
                            <tr><td>2</td><td>10</td><td>0</td><td>35</td><td>25</td></tr>
                            <tr><td>3</td><td>15</td><td>35</td><td>0</td><td>30</td></tr>
                            <tr><td>4</td><td>20</td><td>25</td><td>30</td><td>0</td></tr>
                        </tbody>
                    </table>
                </div>

                <h4>Paso 1: Casos Base (Tamaño de S = 1)</h4>
                <p>Costos para ir del inicio (1) a cada ciudad.</p>
                <div class="sub-item">
                    <code>C({2}, 2) = d(1, 2) = 10</code><br>
                    <code>C({3}, 3) = d(1, 3) = 15</code><br>
                    <code>C({4}, 4) = d(1, 4) = 20</code>
                </div>

                <h4>Paso 2: Subconjuntos de Tamaño 2</h4>
                <p>Calculamos los costos de los caminos que visitan dos ciudades.</p>
                <div class="sub-item">
                    <code>C({2,3}, 2) = C({3},3) + d(3,2) = 15 + 35 = 50</code><br>
                    <code>C({2,3}, 3) = C({2},2) + d(2,3) = 10 + 35 = 45</code><br><br>
                    <code>C({2,4}, 2) = C({4},4) + d(4,2) = 20 + 25 = 45</code><br>
                    <code>C({2,4}, 4) = C({2},2) + d(2,4) = 10 + 25 = 35</code><br><br>
                    <code>C({3,4}, 3) = C({4},4) + d(4,3) = 20 + 30 = 50</code><br>
                    <code>C({3,4}, 4) = C({3},3) + d(3,4) = 15 + 30 = 45</code>
                </div>
                
                <h4>Paso 3: Subconjunto de Tamaño 3 ({2,3,4})</h4>
                <p>Usamos los resultados del Paso 2 para construir caminos más largos.</p>
                <div class="sub-item">
                    <p><strong>Terminando en 2:</strong><br>
                    <code>C({2,3,4}, 2) = min( C({3,4},3)+d(3,2), C({3,4},4)+d(4,2) )</code><br>
                    <code>= min( 50+35, 45+25 ) = min(85, 70) = <span class="highlight">70</span></code></p>
                    <p><strong>Terminando en 3:</strong><br>
                    <code>C({2,3,4}, 3) = min( C({2,4},2)+d(2,3), C({2,4},4)+d(4,3) )</code><br>
                    <code>= min( 45+35, 35+30 ) = min(80, 65) = <span class="highlight">65</span></code></p>
                    <p><strong>Terminando en 4:</strong><br>
                    <code>C({2,3,4}, 4) = min( C({2,3},2)+d(2,4), C({2,3},3)+d(3,4) )</code><br>
                    <code>= min( 50+25, 45+30 ) = min(75, 75) = <span class="highlight">75</span></code></p>
                </div>

                <h4>Paso 4: Resultado Final</h4>
                <p>Cerramos el ciclo desde cada posible última ciudad hacia el inicio (1).</p>
                 <div class="sub-item">
                    <code>Costo = min( C({2,3,4},2)+d(2,1), C({2,3,4},3)+d(3,1), C({2,3,4},4)+d(4,1) )</code><br>
                    <code>= min( 70+10, 65+15, 75+20 )</code><br>
                    <code>= min( 80, 80, 95 ) = <span class="highlight">80</span></code>
                </div>
                <p><strong>El costo mínimo del tour es 80.</strong></p>
            </div>
        </div>

        <div class="topic-card">
            <div class="topic-header"><span class="topic-title">4. Complejidad y Conclusión</span><i class="fas fa-chevron-down expand-icon"></i></div>
            <div class="topic-content">
                <p>La complejidad del algoritmo se deriva del número de subproblemas y el costo para resolver cada uno.</p>
                <div class="diagram-container">
                    <div class="diagram-title">Análisis de Complejidad</div>
                    <div class="diagram-grid">
                        <div class="diagram-box"><strong># Subconjuntos (S)</strong><span>Hay 2<sup>n-1</sup> subconjuntos posibles de las ciudades restantes.</span></div>
                        <div class="diagram-box"><strong># Finales (j)</strong><span>Para cada S, hay ~|S| posibles ciudades finales <em>j</em>.</span></div>
                        <div class="diagram-box"><strong>Costo por Subproblema</strong><span>Para cada par (S, j), se itera sobre ~|S| ciudades previas <em>i</em>.</span></div>
                    </div>
                     <div class="formula-box">Total ≈ Σ<sub>k=2</sub><sup>n</sup> (<sup>n-1</sup><sub>k-1</sub>) * (k-1) * (k-2) ≈ O(n² * 2ⁿ)</div>
                </div>
                <p>Aunque sigue siendo exponencial, <code>O(n² * 2ⁿ)</code> es una mejora monumental sobre <code>O(n!)</code>. En la práctica, Held-Karp permite resolver instancias del TSP para <strong>hasta 20-25 ciudades</strong>, un límite significativamente mayor que el de la fuerza bruta (≈12 ciudades).</p>
            </div>
        </div>
        
    </div>

    <footer>
      <p>Material de estudio sobre el Algoritmo de Held-Karp</p>
      <p>Elaborado por el profesor Sergio Gevatschnaider</p>
    </footer>

  </div>
  
  <script>
    (function() {
        const themeToggleButton = document.getElementById('themeToggleButton');
        const themeIcon = document.getElementById('theme-icon');
        const bodyEl = document.body;

        function setTheme(theme) {
            bodyEl.setAttribute('data-theme', theme);
            localStorage.setItem('theme', theme);
            if (themeIcon) {
                themeIcon.className = theme === 'dark' ? 'fas fa-sun' : 'fas fa-moon';
            }
        }

        themeToggleButton.addEventListener('click', () => {
            const currentTheme = bodyEl.getAttribute('data-theme') || 'dark';
            const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
            setTheme(newTheme);
        });

        const savedTheme = localStorage.getItem('theme') || 'dark';
        setTheme(savedTheme);

        document.querySelectorAll('.topic-header').forEach(header => {
            header.addEventListener('click', () => {
                const card = header.parentElement;
                card.classList.toggle('open');
            });
        });
    })();
  </script>
</body>
</html>