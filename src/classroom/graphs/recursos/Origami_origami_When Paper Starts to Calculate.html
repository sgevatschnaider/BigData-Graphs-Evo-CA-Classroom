<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>When Paper Starts to Calculate | Turing-Complete Origami</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700;800;900&family=JetBrains+Mono:wght@400;500;600&display=swap" rel="stylesheet">
  <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
  <style>
    /* ==================================== */
    /* VARIABLES & GLOBAL CONFIG */
    /* ==================================== */
    :root {
      --bg-primary: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
      --bg-secondary: rgba(255, 255, 255, 0.95);
      --bg-tertiary: rgba(248, 250, 252, 0.9);
      --text-primary: #1a202c;
      --text-secondary: #4a5568;
      --text-accent: #2b6cb0;
      --accent-primary: #4299e1;
      --accent-secondary: #3182ce;
      --accent-gradient: linear-gradient(135deg, var(--accent-primary) 0%, var(--accent-secondary) 100%);
      --border-color: rgba(0, 0, 0, 0.08);
      --shadow-card: 0 20px 40px rgba(0, 0, 0, 0.1);
      --shadow-hover: 0 30px 60px rgba(0, 0, 0, 0.15);
      --border-radius: 24px;
      --transition: all 0.4s cubic-bezier(0.25, 0.8, 0.25, 1);
    }

    [data-theme="dark"] {
      --bg-primary: linear-gradient(135deg, #0f2027 0%, #203a43 50%, #2c5364 100%);
      --bg-secondary: rgba(26, 32, 44, 0.95);
      --bg-tertiary: rgba(45, 55, 72, 0.8);
      --text-primary: #f7fafc;
      --text-secondary: #a0aec0;
      --text-accent: #90cdf4;
      --accent-primary: #43cea2;
      --accent-secondary: #185a9d;
      --border-color: rgba(255, 255, 255, 0.15);
      --shadow-card: 0 20px 40px rgba(0, 0, 0, 0.3);
      --shadow-hover: 0 30px 60px rgba(0, 0, 0, 0.4);
    }

    * { margin: 0; padding: 0; box-sizing: border-box; }
    html { scroll-behavior: smooth; font-size: clamp(14px, 2vw, 18px); }
    body {
      font-family: 'Inter', sans-serif;
      line-height: 1.8;
      background: var(--bg-primary);
      background-attachment: fixed;
      color: var(--text-primary);
      transition: var(--transition);
      min-height: 100vh;
      overflow-x: hidden;
    }

    /* ==================================== */
    /* BACKGROUND ANIMATION (PARTICLES) */
    /* ==================================== */
    .particles {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: -1;
      opacity: 0.4;
    }
    .particle {
      position: absolute;
      width: 2px;
      height: 2px;
      background: var(--accent-primary);
      border-radius: 50%;
      animation: float 20s infinite linear;
    }
    @keyframes float {
      0% { transform: translateY(100vh) translateX(0px) rotate(0deg); opacity: 0; }
      10% { opacity: 1; }
      90% { opacity: 1; }
      100% { transform: translateY(-100px) translateX(100px) rotate(360deg); opacity: 0; }
    }

    /* ==================================== */
    /* THEME TOGGLE */
    /* ==================================== */
    .theme-toggle {
      position: fixed;
      top: 2rem;
      right: 2rem;
      width: 70px;
      height: 70px;
      border: 1px solid var(--border-color);
      border-radius: 50%;
      background: var(--bg-secondary);
      backdrop-filter: blur(20px);
      box-shadow: var(--shadow-card);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 1.8rem;
      color: var(--accent-primary);
      transition: var(--transition);
      z-index: 1000;
      animation: pulse 2s infinite;
    }
    .theme-toggle:hover {
      transform: scale(1.2) rotate(180deg);
      box-shadow: 0 25px 50px rgba(0,0,0,0.2), 0 0 30px rgba(66, 153, 225, 0.4);
    }
    @keyframes pulse {
      0%, 100% { box-shadow: var(--shadow-card); }
      50% { box-shadow: 0 0 0 10px rgba(66, 153, 225, 0.1); }
    }

    /* ==================================== */
    /* HERO SECTION */
    /* ==================================== */
    .hero {
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      text-align: center;
      padding: 2rem;
      position: relative;
    }
    .main-title {
      font-size: clamp(3rem, 8vw, 6rem);
      font-weight: 900;
      background: var(--accent-gradient);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      margin-bottom: 1.5rem;
      animation: fadeInUp 1s ease-out;
      letter-spacing: -0.03em;
    }
    .subtitle {
      font-size: clamp(1.2rem, 3vw, 1.8rem);
      color: var(--text-secondary);
      font-weight: 400;
      max-width: 900px;
      margin: 0 auto;
      animation: fadeInUp 1s ease-out 0.2s both;
    }
    .scroll-indicator {
      position: absolute;
      bottom: 2rem;
      font-size: 2rem;
      color: var(--accent-primary);
      animation: bounce 2s infinite;
      cursor: pointer;
    }
    @keyframes fadeInUp {
      from { opacity: 0; transform: translateY(30px); }
      to { opacity: 1; transform: translateY(0); }
    }
    @keyframes bounce {
      0%, 20%, 50%, 80%, 100% { transform: translateY(0); }
      40% { transform: translateY(-10px); }
      60% { transform: translateY(-5px); }
    }

    /* ==================================== */
    /* MAIN CONTENT */
    /* ==================================== */
    .container {
      max-width: 1200px;
      margin: 0 auto;
      padding: 2rem;
      position: relative;
      z-index: 1;
    }
    .lesson-container {
      display: flex;
      flex-direction: column;
      gap: 2rem;
      margin-top: 4rem;
    }

    /* ==================================== */
    /* TOPIC CARDS */
    /* ==================================== */
    .topic-card {
      background: var(--bg-secondary);
      backdrop-filter: blur(20px);
      border-radius: var(--border-radius);
      box-shadow: var(--shadow-card);
      border: 1px solid var(--border-color);
      overflow: hidden;
      transition: var(--transition);
      opacity: 0;
      transform: translateY(50px);
    }
    .topic-card.visible {
      opacity: 1;
      transform: translateY(0);
      animation: slideIn 0.6s ease-out;
    }
    @keyframes slideIn {
      from { opacity: 0; transform: translateY(50px) scale(0.95); }
      to { opacity: 1; transform: translateY(0) scale(1); }
    }
    .topic-card:hover {
      transform: translateY(-10px);
      box-shadow: var(--shadow-hover);
    }
    .topic-header {
      cursor: pointer;
      padding: 2.5rem 3rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
      background: var(--bg-tertiary);
      transition: var(--transition);
      position: sticky;
      top: 0;
      z-index: 10;
    }
    .topic-title {
      font-size: 1.8rem;
      font-weight: 700;
      color: var(--text-primary);
      display: flex;
      align-items: center;
      gap: 1rem;
    }
    .topic-number {
      font-size: 3.5rem;
      font-weight: 900;
      color: var(--accent-primary);
      opacity: 0.3;
      line-height: 1;
    }
    .expand-icon {
      font-size: 1.5rem;
      color: var(--text-secondary);
      transition: var(--transition);
      width: 40px;
      height: 40px;
      display: flex;
      align-items: center;
      justify-content: center;
      border-radius: 50%;
      background: var(--bg-tertiary);
    }
    .topic-card.open .expand-icon {
      transform: rotate(180deg);
      background: var(--accent-primary);
      color: white;
    }
    .topic-content {
      max-height: 0;
      overflow: hidden;
      transition: max-height 1.5s cubic-bezier(0.25, 0.8, 0.25, 1), padding 1.5s ease;
      background: var(--bg-tertiary);
    }
    .topic-card.open .topic-content {
      max-height: 5000px;
      padding: 3rem;
      border-top: 1px solid var(--border-color);
    }
    .topic-content p {
      color: var(--text-secondary);
      margin-bottom: 1.8rem;
      font-size: 1.1rem;
    }
    .topic-content h4 {
      font-size: 1.5rem;
      color: var(--text-primary);
      margin: 3rem 0 1.5rem;
      font-weight: 700;
      border-left: 5px solid var(--accent-primary);
      padding-left: 1rem;
    }
    .topic-content ul {
      padding-left: 2rem;
      margin-bottom: 2rem;
    }
    .topic-content li {
      margin-bottom: 1rem;
      line-height: 1.7;
      color: var(--text-secondary);
      position: relative;
    }
    .topic-content li::before {
      content: "▸";
      color: var(--accent-primary);
      position: absolute;
      left: -1.5rem;
      font-weight: 700;
    }
    .topic-content strong {
      color: var(--text-primary);
      font-weight: 600;
      background: linear-gradient(120deg, var(--accent-primary), var(--accent-secondary));
      background-size: 100% 0.2em;
      background-repeat: no-repeat;
      background-position: 0 100%;
      padding: 0 0.2em;
    }

    /* ==================================== */
    /* CTA BUTTONS & LINKS */
    /* ==================================== */
    .cta-button {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      gap: 0.8rem;
      text-align: center;
      padding: 1.2rem 2rem;
      margin: 2rem 0.5rem;
      border-radius: 16px;
      background: var(--accent-gradient);
      color: white !important;
      font-weight: 700;
      text-decoration: none;
      transition: var(--transition);
      box-shadow: 0 8px 20px rgba(0,0,0,0.15);
      position: relative;
      overflow: hidden;
      border: none;
      font-size: 1.1rem;
      min-width: 280px;
    }
    .cta-button::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent);
      transition: left 0.7s;
    }
    .cta-button:hover::before { left: 100%; }
    .cta-button:hover {
      transform: translateY(-5px) scale(1.03);
      box-shadow: 0 15px 35px rgba(0,0,0,0.25);
    }
    .cta-button i { font-size: 1.3rem; }
    .button-group {
      display: flex;
      flex-wrap: wrap;
      gap: 1.5rem;
      justify-content: center;
      margin: 2rem 0;
    }
    .external-links-section {
      background: var(--bg-tertiary);
      border-radius: 16px;
      padding: 2rem;
      margin: 3rem 0;
      border: 1px dashed var(--accent-primary);
    }
    .external-links-title {
      font-size: 1.3rem;
      font-weight: 700;
      color: var(--text-primary);
      text-align: center;
      margin-bottom: 1.5rem;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 0.8rem;
    }

    /* ==================================== */
    /* DIAGRAMS & SIMULATORS */
    /* ==================================== */
    .diagram-container, .code-container {
      background: rgba(0, 0, 0, 0.03);
      border: 1px solid var(--border-color);
      border-radius: 16px;
      padding: 2.5rem;
      margin: 3rem 0;
      font-family: 'JetBrains Mono', monospace;
      color: var(--text-secondary);
      transition: var(--transition);
      position: relative;
      overflow: hidden;
    }
    [data-theme="dark"] .diagram-container, [data-theme="dark"] .code-container {
      background: rgba(0, 0, 0, 0.2);
    }
    .diagram-container::before, .code-container::before {
      content: "";
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 4px;
      background: var(--accent-gradient);
      opacity: 0.5;
    }
    .diagram-title {
      font-weight: 700;
      text-align: center;
      margin-bottom: 2.5rem;
      color: var(--text-primary);
      font-size: 1.3rem;
      text-transform: uppercase;
      letter-spacing: 0.1em;
      opacity: 0.8;
    }
    .diagram-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      align-items: stretch;
      gap: 2rem;
    }
    .diagram-box {
      border: 2px solid var(--border-color);
      padding: 1.8rem;
      border-radius: 12px;
      text-align: center;
      background: var(--bg-secondary);
      box-shadow: var(--shadow-card);
      display: flex;
      flex-direction: column;
      justify-content: center;
      transition: var(--transition);
      transform-style: preserve-3d;
    }
    .diagram-box:hover {
      transform: rotateX(5deg) translateY(-5px);
      box-shadow: var(--shadow-hover);
      border-color: var(--accent-primary);
    }
    .diagram-box strong {
      display: block;
      font-size: 1.1em;
      color: var(--text-primary);
      margin-bottom: 0.8rem;
      font-weight: 700;
    }
    .diagram-box span {
      font-size: 0.9em;
      opacity: 0.9;
    }
    .diagram-arrow.down::after {
      content: '↓';
      display: block;
      margin: 1rem 0;
      font-size: 3rem;
      color: var(--accent-primary);
      animation: pulse 1.5s infinite;
    }
    .diagram-section {
      padding: 1.5rem;
      border: 2px dashed var(--border-color);
      border-radius: var(--border-radius);
      width: 100%;
      transition: var(--transition);
    }
    .diagram-section:hover {
      border-style: solid;
      border-color: var(--accent-primary);
    }
    .diagram-section-title {
      font-weight: 700;
      text-align: center;
      margin-bottom: 1.5rem;
      font-size: 1.1em;
      color: var(--text-primary);
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    /* ==================================== */
    /* INTERACTIVE SIMULATORS */
    /* ==================================== */
    .simulator-container {
      background: var(--bg-secondary);
      border-radius: var(--border-radius);
      padding: 2.5rem;
      margin: 3rem 0;
      box-shadow: var(--shadow-card);
      border: 1px solid var(--border-color);
    }
    .simulator-title {
      font-size: 1.4rem;
      font-weight: 700;
      color: var(--text-primary);
      margin-bottom: 1.5rem;
      text-align: center;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 0.8rem;
    }
    .rule110-grid {
      display: grid;
      grid-template-columns: repeat(31, 1fr);
      gap: 2px;
      max-width: 600px;
      margin: 2rem auto;
      padding: 1rem;
      background: var(--bg-tertiary);
      border-radius: 12px;
    }
    .rule110-cell {
      aspect-ratio: 1;
      border-radius: 3px;
      cursor: pointer;
      transition: all 0.2s ease;
      border: 1px solid var(--border-color);
    }
    .rule110-cell:hover {
      transform: scale(1.2);
      box-shadow: 0 0 10px var(--accent-primary);
    }
    .rule110-cell.active {
      background: var(--accent-gradient);
    }
    .rule110-cell.inactive {
      background: var(--bg-secondary);
    }

    /* ==================================== */
    /* TEXT EFFECTS */
    /* ==================================== */
    .math-formula {
      font-family: 'JetBrains Mono', monospace;
      background: var(--bg-tertiary);
      padding: 1.2rem 1.8rem;
      border-radius: 8px;
      margin: 2rem 0;
      border-left: 4px solid var(--accent-primary);
      font-size: 1.1rem;
      overflow-x: auto;
      text-align: center;
      font-weight: 600;
    }
    .highlight {
      background: linear-gradient(120deg, rgba(66, 153, 225, 0.3) 0%, rgba(49, 130, 206, 0.3) 100%);
      padding: 0.2em 0.4em;
      border-radius: 4px;
      font-weight: 600;
    }

    /* ==================================== */
    /* FOOTER */
    /* ==================================== */
    footer {
      text-align: center;
      margin-top: 6rem;
      padding: 3rem 0;
      border-top: 1px solid var(--border-color);
      background: var(--bg-tertiary);
      border-radius: var(--border-radius) var(--border-radius) 0 0;
    }
    footer p {
      color: var(--text-secondary);
      margin-bottom: 1rem;
      font-size: 0.95rem;
      max-width: 800px;
      margin-left: auto;
      margin-right: auto;
    }
    .academic-citation {
      font-style: italic;
      background: rgba(66, 153, 225, 0.1);
      padding: 1.2rem;
      border-radius: 8px;
      margin: 2rem auto 0;
      font-size: 0.9rem;
      max-width: 700px;
    }

    /* ==================================== */
    /* RESPONSIVE */
    /* ==================================== */
    @media (max-width: 768px) {
      .container { padding: 1rem; }
      .topic-card.open .topic-content { padding: 1.8rem; }
      .topic-header { padding: 1.8rem; }
      .button-group { justify-content: center; }
      .cta-button { min-width: 100%; margin: 0.5rem 0; }
    }
  </style>
</head>
<body data-theme="light">
  <!-- Background Particles -->
  <div class="particles" id="particles"></div>

  <!-- Theme Toggle -->
  <button class="theme-toggle" id="themeToggleButton" title="Change theme">
    <i class="fas fa-moon" id="theme-icon"></i>
  </button>

  <!-- Hero Section -->
  <section class="hero">
    <h1 class="main-title">When Paper Starts to Calculate</h1>
    <p class="subtitle">From traditional origami to the idea that every fold is an instruction and every figure, a geometric program.</p>
    <div class="scroll-indicator" onclick="scrollToContent()">
      <i class="fas fa-chevron-down"></i>
    </div>
  </section>

  <!-- Main Content -->
  <div class="container" id="main-content">
    <div class="lesson-container">
        
        <!-- SECTION I -->
        <div class="topic-card fade-in" data-section="1">
            <div class="topic-header">
              <span class="topic-title">
                <span class="topic-number">I</span>
                From Art to Algorithm: Origami as Computation
              </span>
              <i class="fas fa-chevron-down expand-icon"></i>
            </div>
            <div class="topic-content">
                <p>The starting point is one of utmost simplicity: a square sheet of paper and a pair of hands to fold it. The word origami itself refers to this simple gesture: it comes from the Japanese <strong>ori</strong> (to fold) and <strong>kami</strong> (paper). For centuries, origami was understood as an art form tied to rituals, decoration, and play. In all these versions, paper serves as an aesthetic and symbolic medium, something folded to create shapes, not to perform calculations.</p>

                <!-- Interactive Origami Computer Demo + External Link -->
                <div class="simulator-container fade-in">
                  <h3 class="simulator-title"><i class="fas fa-play-circle"></i> Interactive Demo: Origami Computer</h3>
                  <div class="diagram-grid" style="grid-template-columns: 1fr;">
                    <div class="diagram-box">
                      <strong>Visual Simulation</strong>
                      <span>Explore how a sequence of folds executes a geometric "program."</span>
                    </div>
                  </div>
                  <div class="button-group">
                    <button class="cta-button" onclick="runOrigamiDemo()">
                      <i class="fas fa-play"></i> Run Local Program
                    </button>
                    <a href="https://clinquant-meringue-3930c2.netlify.app/src/classroom/graphs/recursos/orgigami-origami_computer" target="_blank" class="cta-button">
                      <i class="fas fa-external-link-alt"></i> Explore Full Demo
                    </a>
                  </div>
                  <div id="origami-demo" style="height: 200px; background: var(--bg-tertiary); border-radius: 12px; margin-top: 1rem; position: relative; overflow: hidden; display: flex; align-items: center; justify-content: center;">
                    <p style="color: var(--text-secondary);">Use the buttons to interact</p>
                  </div>
                </div>

                <p>However, when we stop looking only at the final result and pay attention to the steps, the scene changes completely. Every origami model is accompanied by a precise sequence of instructions. That sequence is not much different from an <strong class="highlight">algorithm</strong>: an ordered series of operations that transform an initial state into a final state.</p>
                
                <div class="math-formula">
                  Initial State → [Instruction₁, Instruction₂, ..., Instructionₙ] → Final State
                </div>

                <!-- Organized external links -->
                <div class="external-links-section fade-in">
                  <h3 class="external-links-title">
                    <i class="fas fa-link"></i> External Visual Resources
                  </h3>
                  <div class="button-group">
                    <a href="https://clinquant-meringue-3930c2.netlify.app/src/classroom/graphs/recursos/origami_origami_euclides" target="_blank" class="cta-button">
                      <i class="fas fa-ruler-combined"></i> Compare: Ruler & Compass vs. Origami
                    </a>
                  </div>
                </div>

                <!-- Content continuation -->
                <p>From a geometric perspective, this intuition becomes sharper. A fold is a concrete transformation of the plane (a piecewise isometry). This perspective introduces a central idea: <strong>the state of the paper is not just a pretty shape; it is information</strong>. A perfectly flat sheet has a trivial "state"; a sheet with accumulated folds has a much richer geometric state.</p>
                
                <div class="diagram-container fade-in">
                    <div class="diagram-title">Two Perspectives on Origami</div>
                    <div class="diagram-grid">
                         <div class="diagram-section">
                            <div class="diagram-section-title">Artistic View</div>
                            <div class="diagram-box"><strong>Medium</strong><span>Sheet of Paper</span></div>
                            <div class="diagram-arrow down"></div>
                            <div class="diagram-box"><strong>Process</strong><span>Folds (Manual Steps)</span></div>
                            <div class="diagram-arrow down"></div>
                            <div class="diagram-box"><strong>Result</strong><span>Final Figure (Aesthetics)</span></div>
                        </div>
                        <div class="diagram-section">
                            <div class="diagram-section-title">Computational View</div>
                            <div class="diagram-box"><strong>Input</strong><span>Initial State (Data)</span></div>
                            <div class="diagram-arrow down"></div>
                            <div class="diagram-box"><strong>Program</strong><span>Algorithm (Operations)</span></div>
                            <div class="diagram-arrow down"></div>
                            <div class="diagram-box"><strong>Output</strong><span>Final State (Result)</span></div>
                        </div>
                    </div>
                </div>

                <p>The statement guiding this analysis ceases to be poetic and starts to become literal: a sheet of paper, equipped with the right pattern of folds, can behave like a universal computer.</p>
            </div>
        </div>

        <!-- SECTION II -->
        <div class="topic-card fade-in" data-section="2">
            <div class="topic-header">
              <span class="topic-title">
                <span class="topic-number">II</span>
                From Sheet to Geometric Model: What is Flat Origami?
              </span>
              <i class="fas fa-chevron-down expand-icon"></i>
            </div>
            <div class="topic-content">
                <p>So far, we have spoken of origami in fairly intuitive terms: folds, mountains, valleys, layers that cross. To connect all this with computation, it is necessary to take a more formal step and answer a very specific question: what does "an origami fold" mean in mathematical language? The typical answer in the literature is that a flat origami model can be described as a <strong>piecewise isometric map</strong>, accompanied by a <strong>crease graph</strong> and a <strong>coherent layer ordering</strong>.</p>
                
                <div class="diagram-container fade-in">
                    <div class="diagram-title">Formal Components of a Flat Origami Model</div>
                    <div class="diagram-grid">
                        <div class="diagram-box">
                            <strong><i class="fas fa-shapes"></i> Piecewise Isometric Map</strong>
                            <span>Each face transforms rigidly (rotates, translates), preserving distances without stretching or compressing.</span>
                        </div>
                        <div class="diagram-box">
                            <strong><i class="fas fa-project-diagram"></i> Crease Graph</strong>
                            <span>The network of fold lines (edges) and their intersections (vertices) that define the structure.</span>
                        </div>
                        <div class="diagram-box">
                            <strong><i class="fas fa-layer-group"></i> Coherent Layer Ordering</strong>
                            <span>Defines which part of the paper is on top and which is at the bottom in overlapping areas, without contradictions.</span>
                        </div>
                    </div>
                </div>

                <p>The idea of the <strong>piecewise isometric map</strong> is as follows. We imagine the sheet of paper as a region of the plane, for example, a square. This region is divided into pieces, called <strong>faces</strong>, which behave rigidly: each face is a polygon (triangle, quadrilateral, etc.) on which the paper does not stretch or compress. On each of these faces, the folding is described by an isometry of the plane: a translation, a rotation, or a reflection. The only "non-smooth" part of the model occurs at the boundaries between faces, which are precisely the <strong>crease lines</strong>.</p>
                <p>Viewed this way, an origami fold is an application that takes each point of the initial sheet and sends it to another position in space, with two important conditions. First, that within each face, distances are preserved: what was a segment of a certain length remains a segment of the same length. Second, that the union of all these folded faces can be realized without the paper passing through itself inconsistently. That second condition is what makes the problem interesting: it's not enough to glue isometries randomly; it must be done in a way that the final object can exist physically.</p>
                <p>In this framework, the <strong>crease lines</strong> play the role of boundaries between faces. Each line separates two regions where the isometry can be different (for example, one face is rotated and the other reflected), but both fit exactly along the common line. If we look only at the "projection" of these lines on the sheet, what we get is a <strong>crease pattern</strong>: a set of segments and curves that indicate where the paper was folded. This diagram can be seen as a <strong>graph</strong>: the points where several lines intersect are vertices, the segments of folds between these vertices are edges, and the polygonal faces appear as regions bounded by this graph.</p>
                <p>The <strong>polygonal faces</strong> are important for two reasons. First, they are the basic rigid units of the model: within each, the geometry is simple (a pure isometry). Second, their shape and how they connect to each other determine the combinatorial structure of the folding: which piece of paper is attached to which, how the folds can be "closed," and which configurations are physically realizable. In practice, this allows us to move from a purely visual description ("I see many lines on the sheet") to a precise mathematical description ("I have a planar graph with such vertices, such edges, and such faces").</p>
                <p>But a key ingredient is still missing: the <strong>layer ordering</strong>. When we fold paper, it's not just about where each point ends up on the plane, but also <strong>what is on top and what is at the bottom</strong> when several layers coincide in the same position. Two different points on the sheet can end up in the same place in space, but one can be physically above the other. To capture this information, the model incorporates a local vertical order: in each area where layers overlap, there is a relationship of "being above" that must be consistent throughout the sheet. This consistency is what prevents paradoxes of the type "this layer is above that one, which in turn is above the first."</p>
                <p>This formalization has two advantages. On one hand, it allows translating the language of origami into that of geometry and topology, making it possible to state and prove theorems about what folds can or cannot be made. On the other, it opens the door to reading the same object as an <strong>information structure</strong>: the crease graph encodes "transition possibilities," the piecewise isometric map describes the current geometric state, and the layer ordering acts as memory. It is precisely this bridge between geometry, combinatorics, and state that will make it possible, in the following sections, to reinterpret a folded sheet as a device capable of implementing logic, cellular automata, and, ultimately, universal computation.</p>
            </div>
        </div>

        <!-- SECTION III -->
        <div class="topic-card fade-in" data-section="3">
            <div class="topic-header">
              <span class="topic-title">
                <span class="topic-number">III</span>
                The Non-linear Fold: Axiom H6
              </span>
              <i class="fas fa-chevron-down expand-icon"></i>
            </div>
            <div class="topic-content">
                <p>There is a particular axiom that elevates origami to a higher level of power: the <strong class="highlight">H6 axiom</strong>.</p>
                
                <!-- H6 Visualizer Demo + External Link -->
                <div class="simulator-container fade-in">
                  <h3 class="simulator-title"><i class="fas fa-flask"></i> Axiom H6 Visualizer</h3>
                  <div style="position: relative; text-align: center;">
                    <svg width="100%" height="250" viewBox="0 0 500 250" style="max-width: 500px; margin: 0 auto;">
                      <circle cx="150" cy="80" r="6" fill="#e53e3e"/>
                      <circle cx="350" cy="120" r="6" fill="#3182ce"/>
                      <text x="150" y="60" fill="var(--text-primary)" font-size="14" font-weight="bold">P</text>
                      <text x="350" y="105" fill="var(--text-primary)" font-size="14" font-weight="bold">Q</text>
                      <line x1="50" y1="200" x2="450" y2="200" stroke="var(--text-secondary)" stroke-width="2" stroke-dasharray="5,5"/>
                      <line x1="200" y1="30" x2="300" y2="220" stroke="var(--text-secondary)" stroke-width="2" stroke-dasharray="5,5"/>
                      <text x="250" y="195" fill="var(--text-secondary)" font-size="12">L₁</text>
                      <text x="180" y="125" fill="var(--text-secondary)" font-size="12">L₂</text>
                      <line id="fold-h6" x1="250" y1="20" x2="250" y2="230" stroke="var(--accent-primary)" stroke-width="4" opacity="0" stroke-linecap="round"/>
                    </svg>
                    <div class="button-group">
                      <button class="cta-button" onclick="animateH6()">
                        <i class="fas fa-atom"></i> Animate H6 Construction
                      </button>
                      <a href="https://clinquant-meringue-3930c2.netlify.app/src/classroom/graphs/recursos/origami_orgiami-folding-lab-h6-explicado" target="_blank" class="cta-button">
                        <i class="fas fa-graduation-cap"></i> Experiment: H6 Folding Lab
                      </a>
                    </div>
                  </div>
                  <div class="math-formula">
                    ∃ fold f: f(P) ∈ L₁ ∧ f(Q) ∈ L₂ (Cubic equation system)
                  </div>
                </div>

                <p>Informally stated, H6 says: given two points (P, Q) and two lines (L₁, L₂), there exists a fold that brings point P onto line L₁ and, simultaneously, point Q onto line L₂.</p>
                <p>In algebraic terms, this implies that the parameters defining the fold must satisfy two conditions at once. The resulting system of equations is neither linear nor quadratic: in general cases, <strong>a third-degree equation appears</strong>. Finding the H6 fold is formally equivalent to solving a cubic equation.</p>
                
                <div class="diagram-container fade-in">
                    <div class="diagram-title">The Leap in Geometric Complexity</div>
                    <div class="diagram-grid">
                        <div class="diagram-box">
                            <strong><i class="fas fa-pencil-ruler"></i> Euclidean Geometry</strong>
                            <span>Its constructions are equivalent to solving equations of up to the 2nd degree.</span>
                        </div>
                        <div class="diagram-box">
                            <strong><i class="fas fa-scroll"></i> Origami (Axiom H6)</strong>
                            <span>A single operation is equivalent to solving 3rd-degree equations.</span>
                        </div>
                    </div>
                </div>

                <p>From this perspective, H6 is the non-linear "hack" of origami. It is the door through which operations that Euclid could never perform enter. Incorporating an axiom capable of solving cubics changes the rules of the game: origami formally becomes more expressive.</p>
            </div>
        </div>

        <!-- SECTION IV -->
        <div class="topic-card fade-in" data-section="4">
            <div class="topic-header">
              <span class="topic-title">
                <span class="topic-number">IV</span>
                From Fold to Bit: Information in Paper
              </span>
              <i class="fas fa-chevron-down expand-icon"></i>
            </div>
            <div class="topic-content">
                <p>To connect origami with computation, it is crucial to understand how a fold can become a bit and a sheet of paper can become memory. It's the transition where geometry begins to speak the language of information.</p>
                
                <!-- Binary Encoding Demo + External Link -->
                <div class="simulator-container fade-in">
                  <h3 class="simulator-title"><i class="fas fa-memory"></i> Binary Encoding in Folds</h3>
                  <div class="diagram-grid" style="grid-template-columns: repeat(3, 1fr); max-width: 600px; margin: 0 auto;">
                    <div class="diagram-box" id="fold-mountain">
                      <strong>Mountain</strong>
                      <span>Bit = <span class="highlight">1</span></span>
                      <div style="width: 60px; height: 40px; margin: 1rem auto; background: var(--accent-primary); clip-path: polygon(20% 100%, 50% 0%, 80% 100%);"></div>
                    </div>
                    <div class="diagram-box" id="fold-valley">
                      <strong>Valley</strong>
                      <span>Bit = <span class="highlight">0</span></span>
                      <div style="width: 60px; height: 40px; margin: 1rem auto; background: var(--text-secondary); clip-path: polygon(20% 0%, 50% 100%, 80% 0%);"></div>
                    </div>
                    <div class="diagram-box" id="fold-memory">
                      <strong>Memory</strong>
                      <span>Layer order</span>
                      <div style="margin-top: 1rem;">
                        <div style="width: 80px; height: 8px; background: var(--border-color); margin: 2px auto; border-radius: 2px;"></div>
                        <div style="width: 80px; height: 8px; background: var(--accent-primary); margin: 2px auto; border-radius: 2px;"></div>
                        <div style="width: 80px; height: 8px; background: var(--border-color); margin: 2px auto; border-radius: 2px;"></div>
                      </div>
                    </div>
                  </div>
                  <div class="button-group">
                    <button class="cta-button" onclick="toggleBinaryDemo()">
                      <i class="fas fa-sync-alt"></i> Toggle States
                    </button>
                    <a href="https://clinquant-meringue-3930c2.netlify.app/src/classroom/graphs/recursos/origami_origami%20turing%E2%80%91completo%20%E2%80%94%20demo%20visual%20interactiva" target="_blank" class="cta-button">
                      <i class="fas fa-cogs"></i> See Logic Gadgets in Action
                    </a>
                  </div>
                </div>

                <p>The starting point is a simple convention: a <strong>mountain</strong> fold can represent a <strong>1</strong>, and a <strong>valley</strong> fold a <strong>0</strong>. A strip of paper with a sequence of these folds becomes a bit tape, analogous to that of a Turing Machine.</p>
                <p>But the information is not just in the lines, but also in the <strong>order of the layers</strong>. Which region is on top of which after a fold is additional information. The paper "remembers" the history of folds, acting as a geometric memory.</p>
                
                <div class="diagram-container fade-in">
                    <div class="diagram-title">Translation from Physical to Logical</div>
                    <div class="diagram-grid">
                        <div class="diagram-box">
                            <strong><i class="fas fa-mountain"></i> Mountain/Valley Fold</strong>
                            <span>Encodes a binary state: <strong>Bit (1 / 0)</strong>.</span>
                        </div>
                        <div class="diagram-box">
                            <strong><i class="fas fa-layer-group"></i> Layer Order</strong>
                            <span>Stores the system's state: <strong>Memory</strong>.</span>
                        </div>
                        <div class="diagram-box">
                            <strong><i class="fas fa-question-circle"></i> Optional Folds</strong>
                            <span>Physical compatibility → Conditional operation: <strong>Logic Gate</strong>.</span>
                        </div>
                    </div>
                </div>

                <p>A paper pattern where the configuration of possible/impossible folds reproduces the truth table of an OR, AND, or NOT gate is not a metaphor; it is a <strong>physical reality</strong>.</p>
            </div>
        </div>

        <!-- SECTION V -->
        <div class="topic-card fade-in" data-section="5">
            <div class="topic-header">
              <span class="topic-title">
                <span class="topic-number">V</span>
                From Logic to Universal Computation: Rule 110 and the Turing Machine
              </span>
              <i class="fas fa-chevron-down expand-icon"></i>
            </div>
            <div class="topic-content">
                <p>If we can design origami "gadgets" that function as logic gates, we can combine them to create circuits. The output of one gadget (a fold) becomes the input for the next. Computation becomes a matter of physical consistency: the paper "refuses" to adopt configurations that do not respect the program.</p>
                
                <!-- Rule 110 Simulator + External Links -->
                <div class="simulator-container fade-in">
                  <h3 class="simulator-title"><i class="fas fa-border-all"></i> Simulator: Rule 110 (Turing-Complete)</h3>
                  <p style="text-align: center; color: var(--text-secondary); margin-bottom: 1rem;">
                    Click on the cells to change the state. Rule 110 can simulate any Turing machine.
                  </p>
                  <div class="rule110-grid" id="rule110-grid"></div>
                  <div class="button-group">
                    <button class="cta-button" onclick="stepRule110()">
                      <i class="fas fa-step-forward"></i> Next Generation
                    </button>
                    <button class="cta-button" onclick="randomizeRule110()">
                      <i class="fas fa-random"></i> Randomize
                    </button>
                    <button class="cta-button" onclick="clearRule110()">
                      <i class="fas fa-eraser"></i> Clear
                    </button>
                    <a href="https://clinquant-meringue-3930c2.netlify.app/src/classroom/graphs/recursos/origami_origami-turing-demo-v2" target="_blank" class="cta-button">
                      <i class="fas fa-external-link-alt"></i> View Extended Demo
                    </a>
                  </div>
                  <div class="math-formula" id="rule110-status">
                    Generations: 0 | Status: Ready
                  </div>
                </div>

                <p>This is where <strong>Rule 110</strong> comes in, a very simple cellular automaton that is, surprisingly, <strong>Turing-complete</strong>. This means it can simulate any computation that a Turing Machine can perform.</p>
                
                <div class="math-formula">
                  Rule 110: σᵢ(t+1) = f(σᵢ₋₁(t), σᵢ(t), σᵢ₊₁(t))
                </div>

                <p>The connection is direct: if we can build a crease pattern that reproduces the dynamics of Rule 110, then origami is Turing-complete. The sheet is organized into repeated blocks (cells), where the geometry implements the automaton's update table.</p>
                
                <div class="diagram-container fade-in">
                    <div class="diagram-title">The Path to Universality</div>
                     <div class="diagram-grid" style="grid-template-columns: 1fr;">
                        <div class="diagram-box">
                          <strong><i class="fas fa-microchip"></i> Step 1: Logic Gates</strong>
                          <span>Small crease patterns that implement AND, OR, NOT using optional folds.</span>
                        </div>
                        <div class="diagram-arrow down"></div>
                        <div class="diagram-box">
                          <strong><i class="fas fa-project-diagram"></i> Step 2: Circuits and Automata</strong>
                          <span>Gates are chained together to simulate local rules, such as those of Rule 110.</span>
                        </div>
                        <div class="diagram-arrow down"></div>
                        <div class="diagram-box">
                          <strong><i class="fas fa-infinity"></i> Step 3: Universal Computation</strong>
                          <span>Since Rule 110 is Turing-complete, the origami system that implements it is as well.</span>
                        </div>
                    </div>
                </div>
                
                <p>The sheet of paper becomes a physical medium for a universal automaton, where the tape is a strip of folded cells and the dynamics are written into the pattern of optional folds.</p>
                
                <!-- Turing Machine Demo + External Link -->
                <div class="simulator-container fade-in">
                  <h3 class="simulator-title"><i class="fas fa-robot"></i> Concept: Origami Turing Machine</h3>
                  <div class="diagram-grid" style="grid-template-columns: 1fr;">
                    <div class="diagram-box">
                      <strong>Physical Implementation</strong>
                      <span>Each cell of the automaton corresponds to a geometric "gadget" that implements the transition logic of Rule 110. The computation occurs by finding the unique consistent flat configuration.</span>
                    </div>
                  </div>
                  <div class="button-group">
                    <a href="https://clinquant-meringue-3930c2.netlify.app/src/classroom/graphs/recursos/origami_origami_m%C3%A1quina%20de%20turing%20de%20origami%20-%20simulaci%C3%B3n%20computacional" target="_blank" class="cta-button">
                      <i class="fas fa-external-link-alt"></i> Complete Computational Simulation
                    </a>
                  </div>
                </div>
            </div>
        </div>

        <!-- SECTION VI -->
        <div class="topic-card fade-in" data-section="6">
            <div class="topic-header">
              <span class="topic-title">
                <span class="topic-number">VI</span>
                The Theorem and its Consequences: Turing-Complete Origami
              </span>
              <i class="fas fa-chevron-down expand-icon"></i>
            </div>
            <div class="topic-content">
                <p>Formal mathematical work solidifies this intuition into a precise theorem: <strong>there exists a rigorous model of flat origami, with locally defined optional creases, that is Turing-complete</strong>. The computation is "hard-wired" into the geometry of the pattern.</p>
                
                <!-- Theorem + Extended Demo -->
                <div class="simulator-container fade-in">
                  <h3 class="simulator-title"><i class="fas fa-theorem"></i> Main Theorem</h3>
                  <div class="math-formula">
                    Theorem: Flat-Foldable Origami with Optional Creases is Turing-Complete
                  </div>
                  <div class="diagram-grid" style="grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));">
                    <div class="diagram-box">
                      <strong><i class="fas fa-puzzle-piece"></i> Gadgets</strong>
                      <span>AND, OR, NOT, NAND, NOR implemented geometrically</span>
                    </div>
                    <div class="diagram-box">
                      <strong><i class="fas fa-th"></i> Tessellation</strong>
                      <span>Infinite periodic pattern simulating automaton cells</span>
                    </div>
                    <div class="diagram-box">
                      <strong><i class="fas fa-cogs"></i> Computation</strong>
                      <span>The folding process finds the consistent configuration = the result</span>
                    </div>
                  </div>
                  <div class="button-group">
                    <a href="https://clinquant-meringue-3930c2.netlify.app/src/classroom/graphs/recursos/origami_origami%20_turing-completo%20%E2%80%94%20demo%20visual%20interactiva" target="_blank" class="cta-button">
                      <i class="fas fa-external-link-alt"></i> Explore Extended Demo
                    </a>
                  </div>
                </div>

                <p>The proof relies on constructing geometric "gadgets" that emulate Rule 110. The decisive step is to show that this is a systematic procedure: for any computation expressible by a Turing Machine, there exists a crease pattern that reproduces it.</p>
                
                <div class="diagram-container fade-in">
                    <div class="diagram-title">Implications of the Theorem</div>
                    <div class="diagram-grid" style="grid-template-columns: 1fr;">
                        <div class="diagram-section">
                            <div class="diagram-section-title">Theoretical Foundation</div>
                            <div class="diagram-box">
                              <strong>Geometric Computation</strong>
                              <span>Physical systems based on rigid transformations can achieve universal complexity.</span>
                            </div>
                        </div>
                        <div class="diagram-section">
                            <div class="diagram-section-title">Potential Applications</div>
                             <div class="diagram-box">
                              <strong>Robotics and Metamaterials</strong>
                              <span>Structures that not only deploy, but also implement control logic within the material itself.</span>
                            </div>
                        </div>
                    </div>
                </div>

                <p>The theorem invites us to change our perspective: the sheet of paper ceases to be a passive object and becomes a <strong>physical programming language</strong>. Each origami diagram is more than a recipe; it is a fragment of geometric code that manipulates information, and each fold is an instruction that executes a calculation.</p>
                
                <div class="academic-citation">
                  <strong>Academic Citation:</strong> Hull, T. C., & Zakharevich, I. (2025). Flat Origami is Turing Complete. arXiv:2309.07932. 
                  This work formally demonstrates that the flat-foldability problem with optional creases is Turing-complete by simulating Rule 110.
                </div>
            </div>
        </div>
    </div>

    <footer>
      <p>Material prepared by Professor Sergio Gevatschnaider</p>
      <p>Based on the analysis and visualization of the paper "Flat Origami is Turing Complete" by Thomas C. Hull and Inna Zakharevich</p>
      <p style="margin-top: 1.5rem;">
        <a href="https://arxiv.org/abs/2309.07932" target="_blank" class="cta-button" style="margin: 0; padding: 0.8rem 1.5rem; font-size: 1rem;">
          <i class="fas fa-file-pdf"></i> Read Original Paper on arXiv
        </a>
      </p>
    </footer>

  </div>
  
  <!-- Scripts -->
  <script>
    // ====================================
    // THEME SYSTEM
    // ====================================
    (function() {
        const themeToggleButton = document.getElementById('themeToggleButton');
        const themeIcon = document.getElementById('theme-icon');
        const bodyEl = document.body;
        const savedTheme = localStorage.getItem('theme') || 'light';

        function setTheme(theme) {
            bodyEl.setAttribute('data-theme', theme);
            localStorage.setItem('theme', theme);
            if (themeIcon) {
                themeIcon.className = theme === 'dark' ? 'fas fa-sun' : 'fas fa-moon';
            }
        }

        setTheme(savedTheme);

        themeToggleButton.addEventListener('click', () => {
            const currentTheme = bodyEl.getAttribute('data-theme') || 'light';
            const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
            setTheme(newTheme);
        });

        // Expand cards
        document.querySelectorAll('.topic-header').forEach(header => {
            header.addEventListener('click', () => {
                const card = header.parentElement;
                const isOpen = card.classList.contains('open');
                
                // Close all others
                document.querySelectorAll('.topic-card').forEach(c => {
                    if (c !== card) c.classList.remove('open');
                });
                
                // Toggle this one
                card.classList.toggle('open');
                
                // Smooth scroll
                if (!isOpen) {
                    setTimeout(() => {
                        card.scrollIntoView({ behavior: 'smooth', block: 'start' });
                    }, 200);
                }
            });
        });
    })();

    // ====================================
    // SCROLL ANIMATION
    // ====================================
    const observerOptions = {
        threshold: 0.1,
        rootMargin: '0px 0px -100px 0px'
    };

    const observer = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
            if (entry.isIntersecting) {
                entry.target.classList.add('visible');
            }
        });
    }, observerOptions);

    document.querySelectorAll('.topic-card, .fade-in').forEach(el => {
        observer.observe(el);
    });

    // ====================================
    // SIMULATION FUNCTIONS
    // ====================================
    
    // Origami Computer Simulator
    function runOrigamiDemo() {
        const container = document.getElementById('origami-demo');
        container.innerHTML = `
            <div style="display: flex; justify-content: center; align-items: center; height: 100%; gap: 1rem;">
                <div style="width: 150px; height: 100px; background: var(--accent-primary); clip-path: polygon(50% 0%, 0% 100%, 100% 100%); transition: all 0.5s ease;" id="origami-shape"></div>
            </div>
        `;
        
        const shape = document.getElementById('origami-shape');
        const sequence = [
            'polygon(50% 0%, 0% 100%, 100% 100%)',
            'polygon(50% 0%, 20% 50%, 50% 100%, 80% 50%)',
            'polygon(50% 0%, 100% 38%, 82% 100%, 18% 100%, 0% 38%)',
            'polygon(25% 0%, 75% 0%, 100% 50%, 75% 100%, 25% 100%, 0% 50%)'
        ];
        
        let step = 0;
        const interval = setInterval(() => {
            shape.style.clipPath = sequence[step % sequence.length];
            step++;
            if (step > sequence.length) clearInterval(interval);
        }, 800);
    }

    // Rule 110 Simulator
    let rule110Grid = [];
    const gridSize = 31;
    let rule110History = [];

    function initializeRule110() {
        const grid = document.getElementById('rule110-grid');
        grid.innerHTML = '';
        rule110Grid = new Array(gridSize).fill(false);
        
        // Initial state with a central pattern
        rule110Grid[Math.floor(gridSize/2)] = true;
        
        renderRule110();
    }

    function renderRule110() {
        const grid = document.getElementById('rule110-grid');
        if (!grid) return;
        grid.innerHTML = '';
        
        rule110Grid.forEach((cell, index) => {
            const cellEl = document.createElement('div');
            cellEl.className = `rule110-cell ${cell ? 'active' : 'inactive'}`;
            cellEl.onclick = () => toggleRule110Cell(index);
            grid.appendChild(cellEl);
        });
        
        updateRule110Status();
    }

    function toggleRule110Cell(index) {
        rule110Grid[index] = !rule110Grid[index];
        renderRule110();
    }

    function stepRule110() {
        const newGrid = [...rule110Grid];
        
        for (let i = 1; i < gridSize - 1; i++) {
            const left = rule110Grid[i-1];
            const center = rule110Grid[i];
            const right = rule110Grid[i+1];
            
            if (left && center && right) newGrid[i] = false;
            else if (left && center && !right) newGrid[i] = true;
            else if (left && !center && right) newGrid[i] = true;
            else if (left && !center && !right) newGrid[i] = false;
            else if (!left && center && right) newGrid[i] = true;
            else if (!left && center && !right) newGrid[i] = true;
            else if (!left && !center && right) newGrid[i] = true;
            else if (!left && !center && !right) newGrid[i] = false;
        }
        
        rule110Grid = newGrid;
        rule110History.push([...newGrid]);
        renderRule110();
    }

    function randomizeRule110() {
        rule110Grid = rule110Grid.map(() => Math.random() > 0.6);
        rule110History = [];
        renderRule110();
    }

    function clearRule110() {
        rule110Grid = new Array(gridSize).fill(false);
        rule110History = [];
        renderRule110();
    }

    function updateRule110Status() {
        const status = document.getElementById('rule110-status');
        if (status) {
            status.textContent = `Generations: ${rule110History.length} | Complexity: ${rule110History.length > 5 ? 'Emergent' : 'Basic'}`;
        }
    }

    // H6 Animation
    function animateH6() {
        const foldLine = document.getElementById('fold-h6');
        if (!foldLine) return;
        foldLine.style.transition = 'transform 0.5s ease, opacity 0.5s ease';
        foldLine.style.opacity = '0';
        foldLine.style.transform = 'scaleY(0)';
        
        setTimeout(() => {
            foldLine.style.opacity = '1';
            foldLine.style.transform = 'scaleY(1)';
        }, 100);
    }

    // Binary demo
    function toggleBinaryDemo() {
        const mountain = document.getElementById('fold-mountain');
        const valley = document.getElementById('fold-valley');
        if (!mountain || !valley) return;
        
        mountain.style.transition = 'all 0.3s ease';
        valley.style.transition = 'all 0.3s ease';
        
        const isToggled = mountain.style.transform === 'scale(0.9)';
        
        mountain.style.transform = isToggled ? 'scale(1)' : 'scale(0.9)';
        valley.style.transform = isToggled ? 'scale(1)' : 'scale(0.9)';
        mountain.style.opacity = isToggled ? '1' : '0.5';
        valley.style.opacity = isToggled ? '0.5' : '1';
    }

    // Initialization
    document.addEventListener('DOMContentLoaded', () => {
        // Particles
        const particlesContainer = document.getElementById('particles');
        if (particlesContainer) {
            for (let i = 0; i < 50; i++) {
                const particle = document.createElement('div');
                particle.className = 'particle';
                particle.style.left = Math.random() * 100 + '%';
                particle.style.animationDelay = Math.random() * 20 + 's';
                particle.style.animationDuration = (15 + Math.random() * 10) + 's';
                particlesContainer.appendChild(particle);
            }
        }
        
        if (document.getElementById('rule110-grid')) {
            initializeRule110();
        }
    });

    // Utilities
    function scrollToContent() {
        document.getElementById('main-content').scrollIntoView({ behavior: 'smooth' });
    }
  </script>
</body>
</html>