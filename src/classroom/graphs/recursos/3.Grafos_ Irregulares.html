<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Grafos Completamente Irregulares: La B√∫squeda de la Diversidad Total</title>
    <style>
        /* --- ESTILOS GENERALES Y TEMATIZACI√ìN --- */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg-primary: linear-gradient(135deg, #00c6ff 0%, #0072ff 100%);
            --bg-secondary: rgba(255, 255, 255, 0.9);
            --text-primary: #2d3748;
            --text-secondary: #4a5568;
            --accent-primary: #0072ff;
            --accent-secondary: #00c6ff;
            --accent-error: #e53e3e;
            --card-bg: rgba(255, 255, 255, 0.75);
            --border-color: rgba(0, 0, 0, 0.1);
            --shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.2);
            --transition: all 0.3s ease-in-out;
        }

        [data-theme="dark"] {
            --bg-primary: linear-gradient(135deg, #1d2b64 0%, #0d1430 100%);
            --bg-secondary: rgba(26, 32, 44, 0.9);
            --text-primary: #e2e8f0;
            --text-secondary: #a0aec0;
            --accent-primary: #4299e1;
            --accent-secondary: #63b3ed;
            --accent-error: #fc8181;
            --card-bg: rgba(45, 55, 72, 0.75);
            --border-color: rgba(255, 255, 255, 0.1);
            --shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.3);
        }

        html {
            scroll-behavior: smooth;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            min-height: 100vh;
            overflow-x: hidden;
            position: relative;
            line-height: 1.7;
            transition: var(--transition);
        }

        /* --- BURBUJAS DE FONDO --- */
        .bubbles {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: -1;
        }

        .bubble {
            position: absolute;
            bottom: -150px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 50%;
            animation: rise 25s infinite ease-in;
        }

        @keyframes rise {
            0% { transform: translateY(0); opacity: 0; }
            10% { opacity: 0.7; }
            90% { opacity: 0.7; }
            100% { transform: translateY(-100vh); opacity: 0; }
        }

        /* --- LAYOUT Y CONTENEDORES --- */
        .container {
            max-width: 1000px;
            margin: 0 auto;
            padding: 2rem;
            position: relative;
            z-index: 1;
        }

        .header {
            text-align: center;
            margin-bottom: 3rem;
        }

        .main-title {
            font-size: clamp(2.5rem, 5vw, 3.8rem);
            font-weight: 800;
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 1rem;
            color: white; /* Fallback for browsers without gradient support */
        }
        
        [data-theme="light"] .main-title {
             color: var(--text-primary);
        }

        .subtitle {
            font-size: 1.2rem;
            color: var(--text-secondary);
            max-width: 800px;
            margin: 0 auto;
        }

        .card {
            background: var(--card-bg);
            backdrop-filter: blur(15px);
            -webkit-backdrop-filter: blur(15px);
            border: 1px solid var(--border-color);
            border-radius: 20px;
            padding: 2.5rem;
            margin-bottom: 2.5rem;
            box-shadow: var(--shadow);
            transition: var(--transition);
        }
        
        .card:hover {
            transform: translateY(-5px);
        }

        h2 {
            font-size: 2rem;
            color: var(--accent-primary);
            margin-bottom: 1.5rem;
        }
        
        h3 {
             font-size: 1.5rem;
             color: var(--text-primary);
             margin: 2rem 0 1rem;
             padding-bottom: 0.5rem;
             border-bottom: 1px solid var(--border-color);
        }
        
         h4 {
             font-size: 1.2rem;
             color: var(--accent-secondary);
             margin: 1.5rem 0 0.5rem;
         }

        /* --- TIPOGRAF√çA Y FORMATO DE TEXTO --- */
        .formula {
            background: rgba(0, 0, 0, 0.05);
            border-left: 4px solid var(--accent-secondary);
            padding: 1rem;
            margin: 1rem 0;
            border-radius: 8px;
            font-family: 'SF Mono', 'Fira Code', 'JetBrains Mono', monospace;
            overflow-x: auto;
            color: var(--text-primary);
        }
        
        [data-theme="dark"] .formula {
            background: rgba(0, 0, 0, 0.2);
        }
        
        code {
            background-color: rgba(0, 198, 255, 0.1);
            color: var(--accent-primary);
            padding: 0.2em 0.4em;
            border-radius: 5px;
            font-family: 'SF Mono', 'Fira Code', monospace;
        }

        strong {
             color: var(--accent-primary);
        }

        .proof-box {
            border: 1px dashed var(--accent-primary);
            padding: 1.5rem;
            margin-top: 1.5rem;
            border-radius: 15px;
            background: rgba(0,114,255, 0.05);
        }
        
        .proof-box strong {
            display: block;
            margin-bottom: 0.5rem;
            font-size: 1.1rem;
        }

        /* --- DEMO INTERACTIVA --- */
        #interactive-proof {
            text-align: center;
        }
        
        #proof-canvas {
            width: 100%;
            max-width: 500px;
            height: auto;
            background: rgba(0,0,0,0.05);
            border-radius: 15px;
            margin: 1rem auto;
            border: 1px solid var(--border-color);
        }
        
        [data-theme="dark"] #proof-canvas {
             background: rgba(0,0,0,0.2);
        }
        
        .slider {
            -webkit-appearance: none;
            width: 80%;
            max-width: 400px;
            height: 10px;
            background: rgba(0, 0, 0, 0.1);
            outline: none;
            border-radius: 5px;
        }
        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 22px;
            height: 22px;
            background: var(--accent-primary);
            cursor: pointer;
            border-radius: 50%;
        }

        .info-display {
            margin-top: 1rem;
            font-family: 'SF Mono', 'Fira Code', monospace;
            color: var(--text-secondary);
        }
        .info-display span {
            font-weight: bold;
            color: var(--accent-primary);
        }

        /* --- OTROS --- */
        .theme-toggle {
            position: fixed;
            top: 1.5rem;
            right: 1.5rem;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: var(--card-bg);
            border: 1px solid var(--border-color);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            color: var(--accent-primary);
            transition: var(--transition);
            z-index: 1000;
        }
        .theme-toggle:hover {
            transform: scale(1.1) rotate(360deg);
            box-shadow: var(--shadow);
        }

        footer {
            text-align: center;
            padding: 2rem;
            margin-top: 2rem;
            color: rgba(255,255,255,0.8);
        }
    </style>
</head>
<body data-theme="dark">

    <div class="bubbles" id="bubbles-container"></div>
    <button class="theme-toggle" id="theme-toggle-btn" title="Cambiar tema">üåô</button>

    <div class="container">
        <header class="header">
            <h1 class="main-title">Grafos Completamente Irregulares</h1>
            <p class="subtitle">Tras explorar la simetr√≠a de los grafos regulares, nos movemos al extremo opuesto: la b√∫squeda de la m√°xima diversidad en la conectividad. ¬øEs posible que cada v√©rtice tenga un n√∫mero √∫nico de conexiones?</p>
        </header>

        <section class="card">
            <h2>Definici√≥n Formal</h2>
            <p>Diremos que un grafo simple <code>G=(V,E)</code> de orden <code>n = |V| ‚â• 2</code> es <strong>completamente irregular</strong> si todos sus v√©rtices tienen grados distintos. Formalmente:</p>
            <div class="formula">deg(u) ‚â† deg(v) &nbsp;&nbsp; para todo par de v√©rtices distintos u, v ‚àà V</div>
            <p>Por ejemplo, para un grafo de orden <code>n=4</code>, la secuencia de grados tendr√≠a que ser, en alg√∫n orden, <code>(0, 1, 2, 3)</code> para que fuera completamente irregular.</p>
        </section>

        <section class="card">
            <h2>Teorema Central y Demostraci√≥n Interactiva</h2>
            <p>La b√∫squeda de un grafo completamente irregular en el mundo de los grafos simples conduce a un resultado sorprendente y fundamental: <strong>es una tarea imposible</strong>.</p>
            <div class="formula"><strong>Teorema 2.1.</strong> No existe ning√∫n grafo simple completamente irregular (de orden n ‚â• 2).</div>

            <div id="interactive-proof">
                <h3>Visualizaci√≥n de la Contradicci√≥n</h3>
                <p>Usa el deslizador para elegir el orden del grafo (<code>n</code>) y observa por qu√© es imposible construirlo.</p>
                <canvas id="proof-canvas" width="500" height="400"></canvas>
                <div class="control-group">
                    <label for="n-slider">Orden del Grafo (n): <span id="n-value">5</span></label><br>
                    <input type="range" min="3" max="10" value="5" class="slider" id="n-slider">
                </div>
                <div class="info-display">
                    Grados Requeridos: <span id="degrees-set">{0, 1, 2, 3, 4}</span>
                </div>
            </div>
        </section>

        <section class="card">
            <h2>An√°lisis Detallado de la Prueba</h2>
            <p>La imposibilidad de los grafos completamente irregulares puede ser demostrada desde varios √°ngulos. A continuaci√≥n, se detalla la prueba cl√°sica y algunas alternativas que refuerzan el mismo resultado.</p>
            
            <h3>Prueba Cl√°sica (Principio del Palomar)</h3>
            <p>Esta demostraci√≥n es un ejemplo cl√°sico de la elegancia del razonamiento por contradicci√≥n.</p>
            <ol>
                <li><strong>El Conjunto de Grados Posibles:</strong> En un grafo simple de orden <code>n</code>, el grado de cualquier v√©rtice <code>v</code> est√° acotado. A lo sumo, puede estar conectado a los otros <code>n-1</code> v√©rtices. Por lo tanto, el conjunto de todos los valores de grado posibles es <code>{0, 1, 2, ..., n-1}</code>, que contiene exactamente <code>n</code> valores distintos.</li>
                <li><strong>La Hip√≥tesis de Irregularidad:</strong> Supongamos, en busca de una contradicci√≥n, que s√≠ existe un grafo simple completamente irregular de orden <code>n</code>. Por definici√≥n, este grafo tiene <code>n</code> v√©rtices, y todos sus grados deben ser distintos.</li>
                <li><strong>Aplicaci√≥n del Principio del Palomar:</strong> Tenemos <code>n</code> v√©rtices (las "palomas") y sus grados deben tomar valores de un conjunto de <code>n</code> posibles grados distintos (los "palomares" o "cajones"). Para que los <code>n</code> grados sean todos diferentes, no queda m√°s remedio que cada v√©rtice tome exactamente uno de los valores posibles. El conjunto de grados del grafo debe ser precisamente: <div class="formula">{deg(v) : v ‚àà V} = {0, 1, 2, ..., n-1}</div></li>
                <li><strong>La Contradicci√≥n Fundamental:</strong> Si lo anterior es cierto, entonces en nuestro grafo deben coexistir dos v√©rtices especiales:
                    <ul>
                        <li>Un v√©rtice <code>x</code> con <code>deg(x) = n-1</code>, conectado a <strong>todos</strong> los dem√°s v√©rtices.</li>
                        <li>Un v√©rtice <code>y</code> con <code>deg(y) = 0</code>, un v√©rtice aislado no conectado a <strong>ning√∫n</strong> otro.</li>
                    </ul>
                    Aqu√≠ reside el conflicto: si <code>x</code> est√° conectado a todos, debe estar conectado a <code>y</code>. Pero si <code>y</code> tiene grado 0, no puede estar conectado a <code>x</code>. Ambas condiciones son mutuamente excluyentes.
                </li>
                 <li><strong>Conclusi√≥n:</strong> La suposici√≥n inicial nos ha llevado a una contradicci√≥n l√≥gica. Por lo tanto, la suposici√≥n es falsa y tal grafo no puede existir.</li>
            </ol>
            
            <h3>Pruebas Alternativas</h3>
            
            <h4>(A) Reformulaci√≥n del Principio del Palomar</h4>
            <p>Podemos razonar por casos para llegar a la misma conclusi√≥n sin invocar la contradicci√≥n directa:</p>
            <ul>
                <li><strong>Caso 1: No existe el grado <code>n-1</code>.</strong> Si en nuestro grafo no hay ning√∫n v√©rtice conectado a todos los dem√°s, entonces los <code>n</code> grados deben pertenecer al conjunto <code>{0, 1, ..., n-2}</code>, que solo tiene <code>n-1</code> valores. Por el Principio del Palomar, al menos dos v√©rtices deben compartir grado.</li>
                <li><strong>Caso 2: No existe el grado <code>0</code>.</strong> An√°logamente, si no hay v√©rtices aislados, los <code>n</code> grados deben pertenecer al conjunto <code>{1, 2, ..., n-1}</code>, que tambi√©n tiene <code>n-1</code> valores. De nuevo, al menos un grado debe repetirse.</li>
            </ul>
             <p>La √∫nica forma de tener <code>n</code> grados distintos es usar todos los valores de <code>0</code> a <code>n-1</code>, lo que nos lleva de vuelta a la contradicci√≥n original.</p>
             
            <h4>(B) Versi√≥n por Complementos</h4>
            <p>El grado de un v√©rtice <code>v</code> en el grafo complemento <code>GÃÖ</code> est√° dado por:</p>
            <div class="formula">deg<sub>GÃÖ</sub>(v) = (n - 1) - deg<sub>G</sub>(v)</div>
            <p>Si <code>G</code> fuera completamente irregular, sus grados ser√≠an <code>{0, 1, ..., n-1}</code>. Entonces, los grados de <code>GÃÖ</code> ser√≠an <code>{n-1, n-2, ..., 0}</code>. ¬°El grafo complemento tendr√≠a exactamente el mismo conjunto de grados! Por lo tanto, <code>GÃÖ</code> tambi√©n deber√≠a tener un v√©rtice de grado <code>n-1</code> y uno de grado <code>0</code>, cayendo en la misma contradicci√≥n.</p>

            <h4>(C) Argumento por Paridad (Esbozo)</h4>
            <p>Sabemos que el n√∫mero de v√©rtices de grado impar en cualquier grafo debe ser <strong>par</strong>. Si un grafo tuviera los grados <code>{0, 1, ..., n-1}</code>, podemos contar cu√°ntos de estos son impares.</p>
            <ul>
                <li>Para <code>n=6</code>, los grados ser√≠an <code>{0,1,2,3,4,5}</code>. Hay tres grados impares (1, 3, 5). Esto es imposible.</li>
                 <li>Para <code>n=7</code>, los grados ser√≠an <code>{0,1,2,3,4,5,6}</code>. Hay tres grados impares (1, 3, 5). Esto tambi√©n es imposible.</li>
            </ul>
            <p>Este m√©todo no funciona para todos los valores de <code>n</code>, pero descarta la mitad de los casos y muestra c√≥mo otras propiedades de los grafos tambi√©n entran en conflicto con la irregularidad total.</p>
        </section>

        <section class="card">
             <h2>Alcance del Teorema</h2>
             <h3>¬øPor qu√© solo para Grafos Simples?</h3>
             <p>Es crucial subrayar que el Teorema 2.1 se aplica exclusivamente a <strong>grafos simples</strong>. La restricci√≥n clave que lleva a la contradicci√≥n es que el grado m√°ximo es <code>n-1</code>. Si permitimos otras estructuras, la situaci√≥n cambia:</p>
             <ul>
                 <li><strong>Multigrafos:</strong> Al permitir aristas paralelas, se elimina el l√≠mite superior del grado. Es f√°cil construir un multigrafo irregular asignando grados distintos y suficientemente grandes a cada v√©rtice.</li>
                 <li><strong>Grafos Ponderados:</strong> Asignando pesos a las aristas, podemos definir el "grado ponderado". Es posible tomar casi cualquier grafo y asignarle pesos de tal manera que todos los v√©rtices terminen con grados ponderados distintos.</li>
             </ul>
        </section>

        <footer>
            <p>Material elaborado por el profesor Sergio Gevatschnaider</p>
        </footer>
    </div>

    <script>
    document.addEventListener('DOMContentLoaded', () => {

        // --- M√ìDULO 1: L√ìGICA DE LA INTERFAZ (TEMA Y BURBUJAS) ---
        const themeToggleBtn = document.getElementById('theme-toggle-btn');
        const bubblesContainer = document.getElementById('bubbles-container');

        const set_theme = (theme) => {
            document.body.setAttribute('data-theme', theme);
            localStorage.setItem('theme', theme);
            themeToggleBtn.textContent = theme === 'dark' ? '‚òÄÔ∏è' : 'üåô';
        };

        themeToggleBtn.addEventListener('click', () => {
            const new_theme = document.body.getAttribute('data-theme') === 'dark' ? 'light' : 'dark';
            set_theme(new_theme);
        });

        if (bubblesContainer) {
            setInterval(() => {
                const bubble = document.createElement('div');
                bubble.classList.add('bubble');
                const size = Math.random() * 80 + 20;
                bubble.style.width = `${size}px`;
                bubble.style.height = `${size}px`;
                bubble.style.left = `${Math.random() * 100}vw`;
                bubble.style.animationDuration = `${Math.random() * 10 + 15}s`;
                bubblesContainer.appendChild(bubble);
                setTimeout(() => bubble.remove(), 25000);
            }, 500);
        }
        
        // Cargar tema guardado o por defecto
        set_theme(localStorage.getItem('theme') || 'dark');


        // --- M√ìDULO 2: CLASE DE VISUALIZACI√ìN DE LA PRUEBA ---
        class ProofVisualizer {
            constructor(canvasId) {
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d');
                this.animationFrameId = null;
            }

            _getThemeColors() {
                return {
                    node: getComputedStyle(document.documentElement).getPropertyValue('--accent-primary').trim(),
                    hubNode: getComputedStyle(document.documentElement).getPropertyValue('--accent-secondary').trim(),
                    isolatedNode: '#718096',
                    edge: getComputedStyle(document.documentElement).getPropertyValue('--text-secondary').trim(),
                    errorEdge: getComputedStyle(document.documentElement).getPropertyValue('--accent-error').trim(),
                    text: getComputedStyle(document.documentElement).getPropertyValue('--text-primary').trim(),
                };
            }

            draw(n) {
                if (this.animationFrameId) {
                    cancelAnimationFrame(this.animationFrameId);
                }

                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

                const colors = this._getThemeColors();
                const centerX = this.canvas.width / 2;
                const centerY = this.canvas.height / 2;
                const radius = Math.min(centerX, centerY) * 0.7;
                const nodeRadius = 15;

                const nodes = [];
                for (let i = 0; i < n; i++) {
                    const angle = (i * 2 * Math.PI) / n - Math.PI / 2;
                    nodes.push({
                        x: centerX + radius * Math.cos(angle),
                        y: centerY + radius * Math.sin(angle),
                    });
                }
                
                // Designar nodos especiales
                const hubNode = nodes[0];
                const isolatedNode = nodes[Math.floor(n / 2)];

                // 1. Dibujar todos los nodos
                nodes.forEach((node, i) => {
                    this.ctx.beginPath();
                    this.ctx.arc(node.x, node.y, nodeRadius, 0, 2 * Math.PI);
                    if (node === hubNode) this.ctx.fillStyle = colors.hubNode;
                    else if (node === isolatedNode) this.ctx.fillStyle = colors.isolatedNode;
                    else this.ctx.fillStyle = colors.node;
                    this.ctx.fill();
                });
                
                // 2. Etiquetar nodos especiales
                this.ctx.fillStyle = colors.text;
                this.ctx.font = 'bold 14px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.fillText(`deg=${n-1}`, hubNode.x, hubNode.y - nodeRadius - 8);
                this.ctx.fillText('deg=0', isolatedNode.x, isolatedNode.y - nodeRadius - 8);

                // 3. Dibujar aristas v√°lidas del hub
                this.ctx.strokeStyle = colors.edge;
                this.ctx.lineWidth = 2;
                nodes.forEach(node => {
                    if (node !== hubNode && node !== isolatedNode) {
                        this.ctx.beginPath();
                        this.ctx.moveTo(hubNode.x, hubNode.y);
                        this.ctx.lineTo(node.x, node.y);
                        this.ctx.stroke();
                    }
                });

                // 4. Animar la arista conflictiva
                let progress = 0;
                const animateConflict = () => {
                    // Redibujar la base
                    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                    this.drawBase(n, nodes, hubNode, isolatedNode, colors, nodeRadius);
                    
                    progress = (progress + 0.02) % 1;
                    const flash = Math.sin(progress * Math.PI * 2) > 0;
                    
                    if(flash) {
                        const targetX = hubNode.x + (isolatedNode.x - hubNode.x);
                        const targetY = hubNode.y + (isolatedNode.y - hubNode.y);

                        this.ctx.beginPath();
                        this.ctx.moveTo(hubNode.x, hubNode.y);
                        this.ctx.lineTo(targetX, targetY);
                        this.ctx.strokeStyle = colors.errorEdge;
                        this.ctx.lineWidth = 3;
                        this.ctx.setLineDash([5, 5]);
                        this.ctx.stroke();
                        this.ctx.setLineDash([]);
                        
                        // Texto de contradicci√≥n
                        this.ctx.font = 'bold 24px Arial';
                        this.ctx.fillStyle = colors.errorEdge;
                        this.ctx.textAlign = 'center';
                        this.ctx.fillText('¬°CONTRADICCI√ìN!', centerX, centerY);
                    }
                    
                    this.animationFrameId = requestAnimationFrame(animateConflict);
                };
                
                this.animationFrameId = requestAnimationFrame(animateConflict);
            }
            
            // Funci√≥n auxiliar para no repetir c√≥digo en la animaci√≥n
            drawBase(n, nodes, hubNode, isolatedNode, colors, nodeRadius) {
                 nodes.forEach((node, i) => {
                    this.ctx.beginPath();
                    this.ctx.arc(node.x, node.y, nodeRadius, 0, 2 * Math.PI);
                    if (node === hubNode) this.ctx.fillStyle = colors.hubNode;
                    else if (node === isolatedNode) this.ctx.fillStyle = colors.isolatedNode;
                    else this.ctx.fillStyle = colors.node;
                    this.ctx.fill();
                });
                
                this.ctx.fillStyle = colors.text;
                this.ctx.font = 'bold 14px Arial';
                this.ctx.textAlign = 'center';
                this.ctx.fillText(`deg=${n-1}`, hubNode.x, hubNode.y - nodeRadius - 8);
                this.ctx.fillText('deg=0', isolatedNode.x, isolatedNode.y - nodeRadius - 8);

                this.ctx.strokeStyle = colors.edge;
                this.ctx.lineWidth = 2;
                nodes.forEach(node => {
                    if (node !== hubNode && node !== isolatedNode) {
                        this.ctx.beginPath();
                        this.ctx.moveTo(hubNode.x, hubNode.y);
                        this.ctx.lineTo(node.x, node.y);
                        this.ctx.stroke();
                    }
                });
            }
        }
        
        // --- M√ìDULO 3: CONTROLADOR DE LA DEMO ---
        const visualizer = new ProofVisualizer('proof-canvas');
        const nSlider = document.getElementById('n-slider');
        const nValueSpan = document.getElementById('n-value');
        const degreesSetSpan = document.getElementById('degrees-set');

        const updateDemo = () => {
            const n = parseInt(nSlider.value);
            nValueSpan.textContent = n;
            const degrees = Array.from({length: n}, (_, i) => i).join(', ');
            degreesSetSpan.textContent = `{${degrees}}`;
            visualizer.draw(n);
        };

        nSlider.addEventListener('input', updateDemo);
        
        // Un observador para redibujar si el tema cambia (para que los colores se actualicen)
        const themeObserver = new MutationObserver((mutations) => {
            mutations.forEach((mutation) => {
                if (mutation.type === 'attributes' && mutation.attributeName === 'data-theme') {
                    updateDemo();
                }
            });
        });
        themeObserver.observe(document.body, { attributes: true });

        // Dibujo inicial
        updateDemo();
    });
    </script>
</body>
</html>```