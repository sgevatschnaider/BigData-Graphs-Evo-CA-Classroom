<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Glosario de Programaci√≥n Gen√©tica</title>
    <style>
        /* --- VARIABLES DE TEMA --- */
        :root {
            --bg-primary-light: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            --text-primary-light: #1c1e21;
            --text-secondary-light: #4A5568;
            --bg-secondary-light: rgba(255, 255, 255, 0.7);
            --border-light: #d1d9e6;
            --accent-light: #2b6cb0;
            --shadow-color: rgba(0, 0, 0, 0.1);

            --bg-primary-dark: linear-gradient(135deg, #0f172a 0%, #1e293b 100%);
            --text-primary-dark: #e2e8f0;
            --text-secondary-dark: #94a3b8;
            --bg-secondary-dark: rgba(30, 41, 59, 0.7);
            --border-dark: #334155;
            --accent-dark: #60a5fa;
            --shadow-color-dark: rgba(0, 0, 0, 0.4);
        }

        html {
            scroll-behavior: smooth;
        }

        body {
            margin: 0;
            padding: 2rem;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            line-height: 1.8;
            overflow-x: hidden;
            transition: background 0.4s, color 0.4s;
        }

        body.light-theme {
            background: var(--bg-primary-light);
            color: var(--text-primary-light);
        }

        body.dark-theme {
            background: var(--bg-primary-dark);
            color: var(--text-primary-dark);
        }

        .container {
            max-width: 1000px;
            margin: 1rem auto;
            border-radius: 16px;
            padding: 2.5rem;
            box-shadow: 0 16px 40px var(--shadow-color);
            border: 1px solid;
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            transition: background-color 0.4s, border-color 0.4s, box-shadow 0.4s;
        }

        body.light-theme .container {
            background-color: var(--bg-secondary-light);
            border-color: rgba(255, 255, 255, 0.5);
            box-shadow: 0 16px 40px var(--shadow-color);
        }

        body.dark-theme .container {
            background-color: var(--bg-secondary-dark);
            border-color: rgba(255, 255, 255, 0.08);
            box-shadow: 0 16px 40px var(--shadow-color-dark);
        }

        h1 {
            text-align: center;
            margin-bottom: 0.75rem;
            font-size: 2.4rem;
            background: linear-gradient(45deg, var(--accent-light), #3182ce);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        body.dark-theme h1 {
            background: linear-gradient(45deg, var(--accent-dark), #93c5fd);
            -webkit-background-clip: text;
        }

        .subtitle {
            text-align: center;
            font-size: 1.05rem;
            margin-bottom: 2.2rem;
            color: var(--text-secondary-light);
        }

        body.dark-theme .subtitle {
            color: var(--text-secondary-dark);
        }

        /* --- CONTROLES Y PROGRESO --- */
        .controls-container {
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
            justify-content: center;
            align-items: center;
            margin-bottom: 1.5rem;
        }

        .search-box {
            padding: 0.8rem 1.2rem;
            border-radius: 25px;
            border: 1px solid var(--border-light);
            background-color: var(--bg-secondary-light);
            transition: all 0.3s ease;
            min-width: 280px;
            font-size: 0.98rem;
        }

        body.dark-theme .search-box {
            background-color: var(--bg-secondary-dark);
            border-color: var(--border-dark);
            color: var(--text-primary-dark);
        }

        .search-box:focus {
            outline: none;
            border-color: var(--accent-light);
            box-shadow: 0 0 12px rgba(43, 108, 176, 0.35);
        }

        body.dark-theme .search-box:focus {
            border-color: var(--accent-dark);
            box-shadow: 0 0 12px rgba(96, 165, 250, 0.35);
        }

        .progress-container {
            padding: 1rem;
            border-radius: 10px;
            margin-bottom: 1.5rem;
            background-color: rgba(0, 0, 0, 0.04);
        }

        body.dark-theme .progress-container {
            background-color: rgba(255, 255, 255, 0.04);
        }

        .progress-bar {
            width: 100%;
            height: 10px;
            border-radius: 999px;
            overflow: hidden;
            background-color: rgba(0, 0, 0, 0.12);
        }

        body.dark-theme .progress-bar {
            background-color: rgba(255, 255, 255, 0.12);
        }

        .progress-fill {
            height: 100%;
            width: 0%;
            transition: width 0.5s ease-in-out;
            background: linear-gradient(90deg, var(--accent-light), #63b3ed);
        }

        body.dark-theme .progress-fill {
            background: linear-gradient(90deg, var(--accent-dark), #bfdbfe);
        }

        .progress-text {
            margin-top: 0.5rem;
            font-size: 0.9rem;
            font-weight: 500;
            color: var(--text-secondary-light);
        }

        body.dark-theme .progress-text {
            color: var(--text-secondary-dark);
        }

        /* --- BOTONES --- */
        .action-button {
            padding: 0.8rem 1.6rem;
            border-radius: 25px;
            border: none;
            cursor: pointer;
            font-size: 0.95rem;
            font-weight: 600;
            transition: all 0.25s ease;
            white-space: nowrap;
        }

        .action-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.2);
        }

        body.light-theme .theme-button {
            background: linear-gradient(135deg, #2d3748, #4a5568);
            color: #f7fafc;
        }

        body.dark-theme .theme-button {
            background: linear-gradient(135deg, #f0f0f0, #d0d0d0);
            color: #1a202c;
        }

        body.light-theme .random-button {
            background: linear-gradient(135deg, #2b6cb0, #3182ce);
            color: #f7fafc;
        }

        body.dark-theme .random-button {
            background: linear-gradient(135deg, #60a5fa, #93c5fd);
            color: #111827;
        }

        /* --- √çTEMS DEL GLOSARIO --- */
        .entry-item {
            margin-bottom: 1rem;
            border-radius: 12px;
            transition: all 0.3s ease;
        }

        .entry-item.reviewed {
            border-left: 5px solid #48bb78;
        }

        .entry-term {
            background-color: transparent;
            cursor: pointer;
            padding: 1rem 1.4rem;
            width: 100%;
            border: none;
            text-align: left;
            outline: none;
            font-size: 1.05rem;
            font-weight: 600;
            border-radius: 12px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: background-color 0.3s ease;
        }

        body.dark-theme .entry-term {
            color: var(--text-primary-dark);
        }

        .entry-term:hover {
            background-color: rgba(0, 0, 0, 0.05);
        }

        body.dark-theme .entry-term:hover {
            background-color: rgba(255, 255, 255, 0.05);
        }

        .entry-icon {
            font-size: 1.4rem;
            font-weight: bold;
            color: var(--accent-light);
            transition: transform 0.25s ease-out;
        }

        body.dark-theme .entry-icon {
            color: var(--accent-dark);
        }

        .entry-term.active .entry-icon {
            transform: rotate(90deg);
        }

        .entry-definition {
            padding: 0 1.4rem;
            max-height: 0;
            overflow: hidden;
            border-top: 1px solid transparent;
            transition: max-height 0.45s ease-in-out, padding 0.45s ease-in-out, border-color 0.3s ease;
        }

        .entry-definition.active {
            padding: 1.4rem;
            border-top-color: var(--border-light);
        }

        body.dark-theme .entry-definition.active {
            border-top-color: var(--border-dark);
        }

        p {
            margin-top: 0;
        }

        strong {
            color: var(--accent-light);
            font-weight: 600;
        }

        body.dark-theme strong {
            color: var(--accent-dark);
        }

        .review-button {
            display: inline-block;
            margin-top: 1rem;
            padding: 0.45rem 1rem;
            border-radius: 20px;
            border: 1px solid #48bb78;
            color: #48bb78;
            background: transparent;
            font-size: 0.85rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.25s ease;
        }

        .review-button:hover,
        .review-button.reviewed {
            background-color: #48bb78;
            color: #f7fafc;
        }

        /* --- BURBUJAS DE FONDO --- */
        .bubble {
            position: fixed;
            bottom: -150px;
            border-radius: 50%;
            pointer-events: none;
            z-index: -10;
            opacity: 0;
            animation: rise 25s infinite ease-in-out;
        }

        body.light-theme .bubble {
            background-color: rgba(43, 108, 176, 0.12);
        }

        body.dark-theme .bubble {
            background-color: rgba(96, 165, 250, 0.09);
        }

        @keyframes rise {
            0%   { transform: translateY(0) scale(1);   opacity: 0;   }
            10%  { opacity: 0.8; }
            50%  { transform: translateY(-50vh) scale(1.2); }
            90%  { opacity: 0.4; }
            100% { transform: translateY(-110vh) scale(0.8); opacity: 0; }
        }

        footer {
            text-align: center;
            margin-top: 3rem;
            font-size: 0.9rem;
            color: #a0aec0;
        }

        body.dark-theme footer {
            color: var(--text-secondary-dark);
        }

        @media (max-width: 640px) {
            body {
                padding: 1.2rem;
            }
            .container {
                padding: 1.6rem;
            }
            h1 {
                font-size: 2rem;
            }
        }
    </style>
</head>
<body class="dark-theme">
    <div class="container">
        <h1>Glosario de Programaci√≥n Gen√©tica</h1>
        <p class="subtitle">
            Recurso interactivo para repasar y dominar los conceptos clave de Programaci√≥n Gen√©tica, 
            desde la estructura del espacio de b√∫squeda hasta AlphaEvolve y el descubrimiento de algoritmos.
        </p>

        <div class="progress-container">
            <div class="progress-bar">
                <div class="progress-fill" id="progress-fill"></div>
            </div>
            <div class="progress-text" id="progress-text">
                Progreso: 0% ‚Äì 0/0 t√©rminos revisados
            </div>
        </div>

        <div class="controls-container">
            <button class="action-button theme-button" id="theme-toggle">‚òÄÔ∏è Cambiar a Tema Claro</button>
            <input type="text" class="search-box" id="search-input" placeholder="üîç Buscar t√©rmino o concepto...">
            <button class="action-button random-button" id="random-entry-btn">üé≤ T√©rmino aleatorio</button>
        </div>
    </div>

    <div class="container" id="entries-container">
        <!-- Entradas del glosario generadas din√°micamente -->
    </div>

    <footer>
        <p>Material elaborado por el profesor Sergio Gevatschnaider</p>
    </footer>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const entries = [
                {
                    term: "Programaci√≥n Gen√©tica (PG)",
                    definition: `
                        <p>
                            La <strong>Programaci√≥n Gen√©tica</strong> es una t√©cnica de computaci√≥n evolutiva que no se limita a ajustar par√°metros dentro de un modelo predefinido, 
                            sino que directamente evoluciona programas completos. En lugar de trabajar con cromosomas binarios o vectores num√©ricos, la PG utiliza estructuras de datos 
                            que representan c√≥digo, generalmente en forma de √°rboles sint√°cticos. Cada individuo en la poblaci√≥n es un programa que puede ser ejecutado, evaluado y 
                            comparado con otros seg√∫n una funci√≥n de fitness.
                        </p>
                        <p>
                            A trav√©s de operadores inspirados en la evoluci√≥n biol√≥gica ‚Äîselecci√≥n, crossover, mutaci√≥n‚Äî, la PG explora autom√°ticamente un espacio inmenso de posibles soluciones, 
                            buscando no solo valores √≥ptimos, sino tambi√©n estructuras algor√≠tmicas novedosas. Esta capacidad la convierte en una herramienta especialmente potente para problemas 
                            donde no se conoce de antemano la forma del modelo o donde se desea que el sistema ‚Äúinvente‚Äù f√≥rmulas, estrategias o algoritmos.
                        </p>
                    `
                },
                {
                    term: "Espacio de b√∫squeda en PG",
                    definition: `
                        <p>
                            El <strong>espacio de b√∫squeda</strong> en Programaci√≥n Gen√©tica es el conjunto de todos los programas que pueden construirse con el lenguaje evolutivo disponible 
                            (funciones, terminales y reglas sint√°cticas). A diferencia de los algoritmos gen√©ticos cl√°sicos, donde el espacio est√° formado por cadenas de longitud fija 
                            y topolog√≠a regular, en PG el espacio es enorme, din√°mico y estructuralmente heterog√©neo.
                        </p>
                        <p>
                            Cada punto del espacio no es solo un vector de n√∫meros, sino un √°rbol de programa con una estructura jer√°rquica propia. Esto implica que el espacio es, en la pr√°ctica, 
                            infinito o casi infinito, con regiones muy densas y otras muy poco exploradas. Navegar este espacio requiere mecanismos que combinen variaci√≥n aleatoria, recombinaci√≥n 
                            inteligente y selecci√≥n basada en desempe√±o, ya que es imposible cubrirlo de forma exhaustiva.
                        </p>
                    `
                },
                {
                    term: "Topolog√≠a del espacio de b√∫squeda",
                    definition: `
                        <p>
                            La <strong>topolog√≠a del espacio de b√∫squeda</strong> describe c√≥mo est√°n organizadas y conectadas entre s√≠ las soluciones posibles. En PG, esta topolog√≠a es 
                            radicalmente distinta de la que se obtiene en espacios vectoriales: cuando se modifica un programa, no solo cambian sus par√°metros, sino tambi√©n su forma interna.
                        </p>
                        <p>
                            Dos programas pueden ser muy ‚Äúcercanos‚Äù sint√°cticamente (por ejemplo, diferir en un solo sub√°rbol) pero producir salidas completamente diferentes, lo que genera 
                            paisajes de fitness altamente irregulares y a menudo discontinuos. Esta topolog√≠a no es un hipercubo uniforme, sino una especie de selva de estructuras, donde la noci√≥n 
                            de distancia es mucho m√°s compleja y donde peque√±as mutaciones pueden generar grandes saltos sem√°nticos. Entender esta topolog√≠a es clave para dise√±ar operadores 
                            evolutivos eficaces.
                        </p>
                    `
                },
                {
                    term: "Representaci√≥n en forma de √°rbol sint√°ctico",
                    definition: `
                        <p>
                            En PG, los programas suelen representarse como <strong>√°rboles sint√°cticos</strong> en los que los nodos internos son funciones (como +, ‚àí, *, sin, if, etc.) y las hojas 
                            son terminales (variables o constantes). Esta representaci√≥n refleja la forma en que se construyen las expresiones en muchos lenguajes funcionales o en notaci√≥n prefija.
                        </p>
                        <p>
                            El √°rbol permite componer operaciones de manera jer√°rquica, de modo que cada sub√°rbol corresponde a una subexpresi√≥n o ‚Äúm√≥dulo‚Äù del programa global. Esta estructura es 
                            extremadamente conveniente para la evoluci√≥n, porque hace posible cortar, pegar y reemplazar sub√°rboles completos, preservando la sintaxis del programa. Adem√°s, facilita la 
                            visualizaci√≥n y el an√°lisis de la complejidad, ya que atributos como profundidad, tama√±o o aridad se pueden medir directamente sobre la estructura del √°rbol.
                        </p>
                    `
                },
                {
                    term: "Conjunto de funciones (F-set)",
                    definition: `
                        <p>
                            El <strong>F-set</strong> es el conjunto de funciones u operadores que la PG puede utilizar como nodos internos del √°rbol. Incluye elementos como sumas, restas, multiplicaciones, 
                            divisiones protegidas, funciones trigonom√©tricas, operadores l√≥gicos o condicionales, seg√∫n el problema espec√≠fico.
                        </p>
                        <p>
                            La elecci√≥n del F-set define el ‚Äúvocabulario operativo‚Äù del lenguaje evolutivo: si es muy limitado, la PG no podr√° expresar soluciones complejas; si es demasiado rico, el espacio de b√∫squeda 
                            se dispara y se vuelve m√°s dif√≠cil encontrar programas √∫tiles. Dise√±ar un F-set adecuado implica conocer bien el dominio del problema y decidir qu√© operaciones son necesarias, cu√°les son 
                            redundantes y cu√°les podr√≠an introducir ruido o complejidad innecesaria.
                        </p>
                    `
                },
                {
                    term: "Conjunto de terminales (T-set)",
                    definition: `
                        <p>
                            El <strong>T-set</strong> est√° formado por los elementos que pueden aparecer como hojas del √°rbol: variables de entrada, constantes num√©ricas, s√≠mbolos especiales o incluso funciones sin argumentos 
                            (cero-arias). Su papel es fundamental porque determina con qu√© ‚Äúmateria prima‚Äù trabaja la PG para construir las expresiones.
                        </p>
                        <p>
                            Si el T-set es excesivamente pobre, la PG tendr√° dificultades para expresar relaciones ricas; si, por el contrario, incluye demasiadas constantes arbitrarias, el espacio se volver√° demasiado disperso. 
                            La interacci√≥n entre F-set y T-set define el lenguaje evolutivo completo: funciones que operan sobre terminales para producir programas funcionales.
                        </p>
                    `
                },
                {
                    term: "Funci√≥n de fitness",
                    definition: `
                        <p>
                            La <strong>funci√≥n de fitness</strong> es el criterio con el que se eval√∫a la calidad de cada programa. Es el ‚Äújuez‚Äù que decide qu√© individuos son preferibles dentro de la poblaci√≥n. 
                            En Programaci√≥n Gen√©tica, el fitness se define a partir del problema concreto: puede ser el error cuadr√°tico medio en una tarea de regresi√≥n, el porcentaje de aciertos en un problema de clasificaci√≥n, 
                            la cantidad de tests de software superados en reparaci√≥n autom√°tica o cualquier m√©trica que mida el desempe√±o deseado.
                        </p>
                        <p>
                            La funci√≥n de fitness transforma el comportamiento de un programa en un valor num√©rico que gu√≠a la selecci√≥n evolutiva. Un dise√±o inapropiado del fitness puede conducir a soluciones enga√±osas, 
                            sobreajuste o estancamiento evolutivo, mientras que un buen dise√±o canaliza la exploraci√≥n hacia regiones del espacio de b√∫squeda donde existen soluciones √∫tiles y generalizables.
                        </p>
                    `
                },
                {
                    term: "Selecci√≥n evolutiva (torneo, ruleta, etc.)",
                    definition: `
                        <p>
                            La <strong>selecci√≥n evolutiva</strong> es el mecanismo que decide qu√© individuos ‚Äúse reproducen‚Äù y cu√°les desaparecen de la poblaci√≥n. En PG, suelen utilizarse esquemas como selecci√≥n por torneo, 
                            donde se elige al mejor de un subconjunto al azar, o selecci√≥n proporcional al fitness, donde la probabilidad de ser elegido est√° vinculada a la calidad del individuo.
                        </p>
                        <p>
                            La selecci√≥n act√∫a como una presi√≥n que empuja a la poblaci√≥n hacia programas de mayor desempe√±o, pero si es demasiado intensa puede reducir dr√°sticamente la diversidad y llevar a la convergencia 
                            prematura. Por el contrario, una selecci√≥n demasiado d√©bil puede hacer que la evoluci√≥n avance muy lentamente. El equilibrio entre presi√≥n selectiva y diversidad es crucial para mantener un proceso 
                            evolutivo eficiente y creativo.
                        </p>
                    `
                },
                {
                    term: "Crossover de sub√°rboles",
                    definition: `
                        <p>
                            El <strong>crossover de sub√°rboles</strong> es el operador de recombinaci√≥n t√≠pico de la PG. Dado un par de programas (dos √°rboles), se elige un nodo en el primero y un nodo en el segundo, 
                            y se intercambian las ramas completas que cuelgan de esos nodos. El resultado son descendientes que combinan partes de la l√≥gica de ambos padres.
                        </p>
                        <p>
                            Este operador es especialmente poderoso porque no modifica simples bits, sino bloques estructurados de c√≥digo con significado funcional. De esta manera, m√≥dulos √∫tiles que han emergido en un individuo 
                            pueden transferirse a otro, y la evoluci√≥n puede producir programas cada vez m√°s sofisticados a partir de la recombinaci√≥n de ‚Äúideas parciales‚Äù ya descubiertas.
                        </p>
                    `
                },
                {
                    term: "Mutaci√≥n puntual",
                    definition: `
                        <p>
                            La <strong>mutaci√≥n puntual</strong> consiste en modificar un elemento peque√±o del √°rbol, por ejemplo cambiar un operador por otro compatible (sustituir ‚Äú+‚Äù por ‚Äú*‚Äù) o alterar el valor de una constante. 
                            Es un operador que introduce variaciones locales de baja intensidad, an√°logas a peque√±os ajustes en un algoritmo cl√°sico.
                        </p>
                        <p>
                            Su funci√≥n principal es explorar el entorno inmediato de una soluci√≥n y refinar estructuras ya prometedoras. Una tasa de mutaci√≥n puntual demasiado baja puede generar poblaciones ‚Äúr√≠gidas‚Äù que no exploran 
                            alternativas cercanas, mientras que una tasa excesiva puede convertir la evoluci√≥n en un proceso casi aleatorio.
                        </p>
                    `
                },
                {
                    term: "Mutaci√≥n por reemplazo de sub√°rbol",
                    definition: `
                        <p>
                            La <strong>mutaci√≥n por reemplazo de sub√°rbol</strong> afecta una parte completa del programa. Se selecciona una rama del √°rbol y se sustituye por un sub√°rbol nuevo, generado aleatoriamente seg√∫n el lenguaje 
                            evolutivo. Esta operaci√≥n es mucho m√°s disruptiva: puede cambiar radicalmente el comportamiento del programa, introduciendo nuevas combinaciones de funciones y terminales.
                        </p>
                        <p>
                            Su papel es facilitar ‚Äúsaltos‚Äù en el espacio de b√∫squeda, alejando a la poblaci√≥n de soluciones que han quedado atrapadas en √≥ptimos locales. No obstante, justamente por su car√°cter dr√°stico, debe usarse con cuidado: 
                            demasiadas mutaciones profundas pueden destruir sistem√°ticamente estructuras valiosas antes de que la selecci√≥n alcance a consolidarlas.
                        </p>
                    `
                },
                {
                    term: "Mutaci√≥n restringida por aridad",
                    definition: `
                        <p>
                            La <strong>mutaci√≥n restringida por aridad</strong> es una variante que cuida la coherencia estructural del √°rbol. En lugar de reemplazar un nodo por cualquier otro, se exige que el nuevo operador tenga la misma 
                            aridad que el anterior, es decir, que espere el mismo n√∫mero de argumentos.
                        </p>
                        <p>
                            De esta forma, la estructura general del √°rbol se conserva y se evita introducir nodos que rompan la sintaxis o que requieran reconfigurar el √°rbol completo. Esta restricci√≥n ayuda a mantener la estabilidad de la 
                            poblaci√≥n y reduce el riesgo de generar programas inv√°lidos o excesivamente deformados, al tiempo que sigue proporcionando variaci√≥n evolutiva significativa.
                        </p>
                    `
                },
                {
                    term: "Bloat",
                    definition: `
                        <p>
                            El <strong>bloat</strong> es el t√©rmino que designa el crecimiento descontrolado del tama√±o de los programas durante la evoluci√≥n. En PG, es frecuente observar que los √°rboles se vuelven cada vez m√°s grandes, 
                            con ramas largas y sub√°rboles que, en muchos casos, no contribuyen al resultado final.
                        </p>
                        <p>
                            Este fen√≥meno tiene varias causas: la neutralidad sem√°ntica (c√≥digo que no cambia la salida), la mayor robustez de individuos grandes frente a mutaciones, el sesgo estad√≠stico del crossover y la acumulaci√≥n de 
                            estructuras ‚Äúdecorativas‚Äù. El problema del bloat no es solo est√©tico: programas excesivamente grandes son m√°s costosos de evaluar, m√°s dif√≠ciles de interpretar y m√°s propensos al sobreajuste.
                        </p>
                    `
                },
                {
                    term: "Parsimonia",
                    definition: `
                        <p>
                            La <strong>parsimonia</strong> es el principio seg√∫n el cual, dadas dos soluciones con desempe√±o similar, debe preferirse la m√°s simple. En el contexto de PG, este principio se implementa mediante una penalizaci√≥n al 
                            tama√±o del programa dentro de la funci√≥n de fitness.
                        </p>
                        <p>
                            Al restar una cantidad proporcional al n√∫mero de nodos o a la profundidad del √°rbol, se desincentiva la proliferaci√≥n de estructuras innecesarias y se fomenta la emergencia de soluciones compactas y elegantes. 
                            La parsimonia mejora la interpretabilidad y la generalizaci√≥n, pero debe aplicarse con moderaci√≥n para no asfixiar la creatividad estructural.
                        </p>
                    `
                },
                {
                    term: "Regresi√≥n simb√≥lica",
                    definition: `
                        <p>
                            La <strong>regresi√≥n simb√≥lica</strong> es una de las aplicaciones cl√°sicas de la PG. Consiste en buscar una expresi√≥n matem√°tica que describa la relaci√≥n entre una o varias variables de entrada y una variable de salida, 
                            sin imponer una forma funcional previa (como ‚Äúlineal‚Äù, ‚Äúpolin√≥mica de grado 2‚Äù, etc.).
                        </p>
                        <p>
                            La PG explora un espacio de expresiones posibles ‚Äîcombinando operadores del F-set y terminales del T-set‚Äî y eval√∫a cada una seg√∫n qu√© tan bien ajusta los datos observados. A diferencia de la regresi√≥n tradicional, donde se 
                            ajustan par√°metros de un modelo fijo, la regresi√≥n simb√≥lica permite descubrir f√≥rmulas completamente nuevas, potencialmente interpretables y cercanas a leyes o patrones subyacentes.
                        </p>
                    `
                },
                {
                    term: "Reparaci√≥n autom√°tica de software con PG",
                    definition: `
                        <p>
                            La <strong>reparaci√≥n autom√°tica de software</strong> utiliza Programaci√≥n Gen√©tica para generar parches que corrigen errores en programas existentes. En lugar de que un humano analice el c√≥digo y descubra la causa del fallo, 
                            la PG propone variaciones del programa, las ejecuta contra un conjunto de tests y mantiene aquellas versiones que corrigen los errores sin introducir nuevas fallas.
                        </p>
                        <p>
                            Cada individuo es una versi√≥n modificada del c√≥digo original; la funci√≥n de fitness se define, por ejemplo, como el n√∫mero de tests superados. A trav√©s de muchas generaciones, la PG puede encontrar correcciones no triviales, 
                            a veces incluso m√°s elegantes que las soluciones intuitivas.
                        </p>
                    `
                },
                {
                    term: "Neutralidad en el paisaje de fitness",
                    definition: `
                        <p>
                            La <strong>neutralidad</strong> aparece cuando diferentes programas producen resultados pr√°cticamente id√©nticos seg√∫n la m√©trica de fitness. Esto genera zonas planas en el paisaje de evaluaci√≥n, conocidas como plateaus, donde 
                            m√∫ltiples individuos tienen el mismo nivel de desempe√±o.
                        </p>
                        <p>
                            En esos espacios neutrales, la evoluci√≥n puede desplazarse libremente sin mejora ni deterioro evidente, explorando variaciones sint√°cticas que no cambian la salida. Esta neutralidad facilita la deriva hacia estructuras m√°s grandes 
                            sin presi√≥n en contra (y por eso contribuye al bloat), pero tambi√©n puede servir como ‚Äúpuente evolutivo‚Äù hacia regiones del espacio donde aparecen soluciones mejores.
                        </p>
                    `
                },
                {
                    term: "Generalizaci√≥n y sobreajuste en PG",
                    definition: `
                        <p>
                            Al igual que en otros m√©todos de aprendizaje, la PG puede caer en el <strong>sobreajuste</strong>, es decir, en la creaci√≥n de programas que se ajustan muy bien a los datos de entrenamiento pero fallan cuando se enfrentan a nuevos 
                            ejemplos. Esto ocurre especialmente cuando los √°rboles se vuelven muy grandes y flexibles, capaces de memorizar particularidades del conjunto de entrenamiento.
                        </p>
                        <p>
                            La <strong>generalizaci√≥n</strong>, en cambio, es la capacidad del programa para captar patrones reales y robustos del problema. Favorecerla implica usar datasets adecuados, incorporar parsimonia, limitar la profundidad de los √°rboles, 
                            utilizar validaci√≥n cruzada o incluir penalizaciones espec√≠ficas en la funci√≥n de fitness. Los mecanismos que controlan el bloat suelen estar √≠ntimamente ligados a la mejora de la capacidad de generalizaci√≥n.
                        </p>
                    `
                },
                {
                    term: "AlphaEvolve y descubrimiento de algoritmos",
                    definition: `
                        <p>
                            <strong>AlphaEvolve</strong> es un ejemplo moderno de sistema que combina ideas de Programaci√≥n Gen√©tica con modelos de lenguaje y evaluaci√≥n automatizada para descubrir algoritmos nuevos. A diferencia de un LLM que solo genera c√≥digo 
                            a partir de patrones aprendidos, AlphaEvolve integra un ciclo evolutivo: propone variantes de c√≥digo, las ejecuta en tareas espec√≠ficas, mide su desempe√±o y mantiene aquellas que muestran mejoras.
                        </p>
                        <p>
                            Con el tiempo, puede producir soluciones que no est√°n presentes en los datos de entrenamiento y que optimizan aspectos como velocidad, precisi√≥n o consumo de recursos. AlphaEvolve materializa la visi√≥n de la PG como herramienta de 
                            invenci√≥n algor√≠tmica y muestra c√≥mo la evoluci√≥n de programas sigue siendo una l√≠nea de frontera en inteligencia artificial.
                        </p>
                    `
                }
            ];

            const body = document.body;
            const entriesContainer = document.getElementById('entries-container');
            const searchInput = document.getElementById('search-input');
            const themeToggle = document.getElementById('theme-toggle');
            const randomBtn = document.getElementById('random-entry-btn');
            const progressFill = document.getElementById('progress-fill');
            const progressText = document.getElementById('progress-text');

            const reviewedEntries = new Set();

            function renderEntries() {
                entriesContainer.innerHTML = '';
                entries.forEach((entry, index) => {
                    const item = document.createElement('div');
                    item.className = 'entry-item';

                    item.innerHTML = `
                        <button class="entry-term">
                            <span>${entry.term}</span>
                            <span class="entry-icon">‚Ä∫</span>
                        </button>
                        <div class="entry-definition">
                            ${entry.definition}
                            <button class="review-button" data-index="${index}">Marcar como revisado</button>
                        </div>
                    `;

                    entriesContainer.appendChild(item);
                });

                attachEntryEvents();
                updateProgress();
            }

            function attachEntryEvents() {
                document.querySelectorAll('.entry-term').forEach(button => {
                    button.addEventListener('click', () => {
                        const definition = button.nextElementSibling;
                        button.classList.toggle('active');
                        definition.classList.toggle('active');

                        const icon = button.querySelector('.entry-icon');
                        if (button.classList.contains('active')) {
                            definition.style.maxHeight = definition.scrollHeight + 'px';
                        } else {
                            definition.style.maxHeight = null;
                        }
                    });
                });

                document.querySelectorAll('.review-button').forEach(button => {
                    button.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const index = e.target.dataset.index;
                        const item = e.target.closest('.entry-item');

                        if (reviewedEntries.has(index)) {
                            reviewedEntries.delete(index);
                            e.target.textContent = 'Marcar como revisado';
                            e.target.classList.remove('reviewed');
                            item.classList.remove('reviewed');
                        } else {
                            reviewedEntries.add(index);
                            e.target.textContent = '‚úì Revisado';
                            e.target.classList.add('reviewed');
                            item.classList.add('reviewed');
                        }
                        updateProgress();
                    });
                });
            }

            function updateProgress() {
                const total = entries.length;
                const reviewed = reviewedEntries.size;
                const percentage = total > 0 ? Math.round((reviewed / total) * 100) : 0;

                progressFill.style.width = percentage + '%';
                progressText.textContent = `Progreso: ${percentage}% ‚Äì ${reviewed}/${total} t√©rminos revisados`;
            }

            function filterEntries() {
                const term = searchInput.value.toLowerCase().trim();
                const items = document.querySelectorAll('.entry-item');

                items.forEach((item, index) => {
                    const entry = entries[index];
                    const text = (entry.term + ' ' + entry.definition).toLowerCase();
                    item.style.display = text.includes(term) ? 'block' : 'none';
                });
            }

            function showRandomEntry() {
                const visibleItems = Array.from(document.querySelectorAll('.entry-item'))
                    .filter(item => item.style.display !== 'none');

                if (visibleItems.length === 0) return;

                const randomItem = visibleItems[Math.floor(Math.random() * visibleItems.length)];
                randomItem.scrollIntoView({ behavior: 'smooth', block: 'center' });

                const termBtn = randomItem.querySelector('.entry-term');
                if (!termBtn.classList.contains('active')) {
                    termBtn.click();
                }
            }

            function createBubble() {
                const bubble = document.createElement('div');
                bubble.classList.add('bubble');

                const size = Math.random() * 80 + 20;
                bubble.style.width = `${size}px`;
                bubble.style.height = `${size}px`;
                bubble.style.left = `${Math.random() * 100}%`;
                bubble.style.animationDelay = `${Math.random() * 5}s`;
                bubble.style.animationDuration = `${Math.random() * 12 + 16}s`;

                body.appendChild(bubble);
                setTimeout(() => bubble.remove(), 26000);
            }

            // Inicializaci√≥n
            renderEntries();
            setInterval(createBubble, 700);

            searchInput.addEventListener('input', filterEntries);

            themeToggle.addEventListener('click', () => {
                body.classList.toggle('dark-theme');
                body.classList.toggle('light-theme');

                const isDark = body.classList.contains('dark-theme');
                themeToggle.textContent = isDark ? '‚òÄÔ∏è Cambiar a Tema Claro' : 'üåô Cambiar a Tema Oscuro';
            });

            randomBtn.addEventListener('click', showRandomEntry);
        });
    </script>
</body>
</html>
