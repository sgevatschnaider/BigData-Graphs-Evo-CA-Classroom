<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>ZKP Isomorfismo de Grafos — Demo con compromisos y Fiat–Shamir</title>
<style>
  :root { --bg:#0f1220; --fg:#e8ecf1; --muted:#9aa3b2; --acc:#50e3c2; --warn:#ffad5a; --err:#ff6b6b; --ok:#8be28b; }
  body { margin:0; font-family:ui-sans-serif,system-ui,Segoe UI,Roboto,Helvetica,Arial; background:var(--bg); color:var(--fg); }
  header { padding:16px 20px; border-bottom:1px solid #1b2036; display:flex; gap:12px; align-items:center; flex-wrap:wrap; }
  h1 { font-size:18px; margin:0; }
  .wrap { display:grid; grid-template-columns: 340px 1fr; gap:16px; padding:16px; }
  .panel { background:#121733; border:1px solid #1b2036; border-radius:12px; padding:12px; }
  .panel h2 { font-size:14px; margin:0 0 8px 0; color:#cbd5e1; }
  .row { display:flex; gap:8px; flex-wrap:wrap; align-items:center; }
  button { background:#1b254b; color:#e8ecf1; border:1px solid #2a3470; padding:8px 10px; border-radius:10px; cursor:pointer; font-weight:600; }
  button:hover { background:#22306b; }
  button:disabled { opacity:.5; cursor:not-allowed; }
  .accent { background:var(--acc); color:#072a2a; border-color:#3ac7ac; }
  .warn { background:var(--warn); color:#2a1400; border-color:#e38c2d; }
  .ok { background:var(--ok); color:#062406; border-color:#63bf63; }
  .err { background:var(--err); color:#2b0000; border-color:#cc5252; }
  .small { font-size:12px; color:var(--muted); }
  .grid { display:grid; grid-template-columns: repeat(3, minmax(240px, 1fr)); gap:12px; }
  svg { width:100%; height:280px; background:#0b1026; border:1px solid #1b2036; border-radius:10px; }
  .node { fill:#83a1ff; stroke:#19224b; stroke-width:1.5; }
  .node.h { fill:#50e3c2; }
  .edge { stroke:#5a6aa5; stroke-width:2; opacity:.9; }
  .label { fill:#dbe4ff; font-size:11px; text-anchor:middle; dominant-baseline:central; pointer-events:none; }
  .stat { background:#101635; border:1px dashed #2a3470; border-radius:10px; padding:8px; margin-top:8px; }
  code, .mono { font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; font-size:12px; }
  .mono { word-break:break-all; }
</style>
</head>
<body>
<header>
  <h1>ZKP Isomorfismo de Grafos — Compromisos (SHA-256) & Fiat–Shamir</h1>
  <span class="small">Σ-protocolo con compromiso → desafío → respuesta → verificación</span>
</header>

<div class="wrap">
  <div class="panel">
    <h2>Parámetros</h2>
    <div class="row">
      <label>Nodos: <input id="nNodes" type="number" min="5" max="10" value="7" style="width:64px; margin-left:6px"></label>
      <label style="margin-left:8px">Densidad p: <input id="density" type="number" min="0.1" max="0.9" step="0.05" value="0.35" style="width:64px; margin-left:6px"></label>
    </div>
    <div class="row" style="margin-top:6px">
      <button id="newInst" class="accent">Nueva instancia (G₁,G₂, π secreta)</button>
      <button id="resetRounds">Reiniciar rondas</button>
    </div>

    <h2>Modo de desafío</h2>
    <div class="row small">
      <label><input id="fsMode" type="checkbox"> Fiat–Shamir (NIZK, desafío por hash)</label>
    </div>

    <h2>Ronda criptográfica</h2>
    <ol class="small" style="margin-top:0; line-height:1.6">
      <li><b>Compromiso:</b> el Probador envía <code>com = H( serialize(H) || nonce )</code> sin revelar <code>H</code> ni <code>nonce</code>.</li>
      <li><b>Desafío:</b> interactivo <code>c∈{1,2}</code> o Fiat–Shamir <code>c = H(transcript) mod 2 + 1</code>.</li>
      <li><b>Respuesta:</b> revelar <code>H, nonce</code> y <code>f</code> tal que <code>f(G_c)=H</code>.</li>
    </ol>
    <div class="row" style="margin:6px 0">
      <button id="commitBtn">1) Comprometer</button>
      <button id="ch1" disabled>2) c = 1</button>
      <button id="ch2" disabled>2) c = 2</button>
      <button id="respondBtn" class="warn" disabled>3) Responder</button>
    </div>
    <div class="row" style="margin:6px 0">
      <button id="autoRound" disabled>Auto-ronda</button>
      <button id="autoMany" disabled>Auto-10 rondas</button>
    </div>

    <div class="stat" id="statusBox">Estado: prepara una instancia nueva.</div>

    <h2>Valores (transparencia)</h2>
    <div class="small">π (secreta, fija) mapea G₁→G₂. σ (aleatoria por ronda) mapea G₁→H.</div>
    <div class="mono" id="piMap">π: —</div>
    <div class="mono" id="sigmaMap">σ: —</div>
    <div class="mono" id="nonceBox">nonce: —</div>
    <div class="mono" id="commitBox">commit: —</div>
    <div class="mono" id="challengeBox">c: —</div>
    <div class="mono" id="fMap">f: —</div>

    <h2>Seguridad</h2>
    <div class="stat" id="securityBox">Rondas: 0 · Prob. engañar: 1</div>
  </div>

  <div class="panel">
    <h2>Visualización</h2>
    <div class="grid">
      <div>
        <div class="small">G₁ (público)</div>
        <svg id="g1"></svg>
      </div>
      <div>
        <div class="small">G₂ = π(G₁) (público)</div>
        <svg id="g2"></svg>
      </div>
      <div>
        <div class="small">H (comprometido, solo se muestra tras la respuesta)</div>
        <svg id="h"></svg>
      </div>
    </div>
    <div class="small" style="margin-top:6px">
      Colores: <span style="color:#83a1ff">G₁/G₂</span>, <span style="color:#50e3c2">H</span>. Las permutaciones relabelan etiquetas sin cambiar aristas.
    </div>
  </div>
</div>

<script>
/* ===== Utilidades base ===== */
const el = id => document.getElementById(id);
const range = n => [...Array(n).keys()];
function srnd(n){ // entero [0,n)
  const buf = new Uint32Array(1); crypto.getRandomValues(buf);
  return Number(buf[0] % n);
}
function shuffle(arr){
  const a=arr.slice();
  for (let i=a.length-1;i>0;i--){ const j=srnd(i+1); [a[i],a[j]]=[a[j],a[i]]; }
  return a;
}
function compose(p, q){ const n=p.length, r=new Array(n); for(let i=0;i<n;i++) r[i]=p[q[i]]; return r; }
function invert(p){ const n=p.length, inv=new Array(n); for(let i=0;i<n;i++) inv[p[i]]=i; return inv; }
function permuteGraph(G, p){
  const n=G.n; const E=new Set();
  for (const [u,v] of G.edges){
    const a=p[u], b=p[v]; const lo=Math.min(a,b), hi=Math.max(a,b);
    E.add(lo+"-"+hi);
  }
  return {n, edges:[...E].map(s=>s.split("-").map(Number))};
}
function randomGraph(n, p){
  const edges=[];
  for(let i=0;i<n;i++){ for(let j=i+1;j<n;j++){ if (Math.random()<p) edges.push([i,j]); } }
  if (edges.length===0) edges.push([0,1]);
  return {n, edges};
}
function checkIso(G,H,f){
  if (G.n!==H.n || f.length!==G.n) return false;
  const map=new Set(H.edges.map(([a,b])=> (Math.min(a,b)+"-"+Math.max(a,b))));
  for (const [u,v] of G.edges){
    const a=f[u], b=f[v], key=(Math.min(a,b)+"-"+Math.max(a,b));
    if (!map.has(key)) return false;
  }
  return true;
}

/* ===== Serialización determinista ===== */
function canonEdges(edges){
  return edges.map(([u,v])=> [Math.min(u,v), Math.max(u,v)])
              .sort((a,b)=> a[0]-b[0] || a[1]-b[1]);
}
function serializeGraph(G){ // bytes: n || edges-count || pairs (u,v)
  const E = canonEdges(G.edges);
  const len = 4 + 4 + 4*E.length*2;
  const buf = new ArrayBuffer(len);
  const dv = new DataView(buf);
  let o=0;
  dv.setUint32(o, G.n); o+=4;
  dv.setUint32(o, E.length); o+=4;
  for (const [u,v] of E){ dv.setUint32(o,u); o+=4; dv.setUint32(o,v); o+=4; }
  return new Uint8Array(buf);
}
function serializePerm(p){
  const buf = new ArrayBuffer(4 + 4*p.length);
  const dv = new DataView(buf);
  dv.setUint32(0, p.length);
  let o=4; for (let i=0;i<p.length;i++){ dv.setUint32(o, p[i]); o+=4; }
  return new Uint8Array(buf);
}
function concatBytes(...arrs){
  const total = arrs.reduce((s,a)=> s+a.length, 0);
  const out = new Uint8Array(total);
  let o=0; for(const a of arrs){ out.set(a,o); o+=a.length; }
  return out;
}

/* ===== Criptografía (WebCrypto) ===== */
async function sha256(bytes){
  const h = await crypto.subtle.digest('SHA-256', bytes);
  return new Uint8Array(h);
}
function hex(u8){ return [...u8].map(b=> b.toString(16).padStart(2,'0')).join(''); }
function randBytes(n){
  const b = new Uint8Array(n); crypto.getRandomValues(b); return b;
}

/* ===== Visual ===== */
function polygonPositions(n, w, h, rPad=28){
  const cx=w/2, cy=h/2, r=Math.min(w,h)/2 - rPad;
  const pos=[]; for(let k=0;k<n;k++){ const ang=-Math.PI/2 + 2*Math.PI*k/n;
    pos.push({x: cx + r*Math.cos(ang), y: cy + r*Math.sin(ang)}); }
  return pos;
}
function drawGraph(svg, G, opts={}){
  const ns="http://www.w3.org/2000/svg";
  while (svg.firstChild) svg.removeChild(svg.firstChild);
  const w=svg.clientWidth||svg.parentElement.clientWidth, h=svg.clientHeight||280;
  svg.setAttribute("viewBox",`0 0 ${w} ${h}`);
  if (!G) return;
  const pos=polygonPositions(G.n, w, h);
  for (const [u,v] of G.edges){
    const e=document.createElementNS(ns,"line");
    e.setAttribute("x1", pos[u].x); e.setAttribute("y1", pos[u].y);
    e.setAttribute("x2", pos[v].x); e.setAttribute("y2", pos[v].y);
    e.setAttribute("class","edge");
    svg.appendChild(e);
  }
  for (let i=0;i<G.n;i++){
    const g=document.createElementNS(ns,"g");
    const c=document.createElementNS(ns,"circle");
    c.setAttribute("cx",pos[i].x); c.setAttribute("cy",pos[i].y); c.setAttribute("r",16);
    c.setAttribute("class", opts.classNode || "node");
    g.appendChild(c);
    const t=document.createElementNS(ns,"text");
    t.setAttribute("x",pos[i].x); t.setAttribute("y",pos[i].y); t.setAttribute("class","label");
    t.textContent = (opts.labels ? opts.labels[i] : i);
    g.appendChild(t);
    svg.appendChild(g);
  }
}

/* ===== Estado ===== */
const state = {
  G1:null, G2:null, H:null,
  pi:null, sigma:null, f:null,
  n:7, p:0.35,
  rounds:0,
  committed:false, challenged:null, responded:false,
  nonce:null, commit:null
};

/* ===== UI helpers ===== */
function setStatus(msg, cls=""){ const box=el("statusBox"); box.textContent="Estado: "+msg; box.className="stat "+cls; }
function setSecurity(){ const prob=Math.pow(0.5, state.rounds);
  el("securityBox").textContent = `Rondas: ${state.rounds} · Prob. engañar: ${prob.toLocaleString(undefined,{maximumFractionDigits:6})}`; }
function showMaps(){
  el("piMap").textContent = "π: " + (state.pi? state.pi.join(" "): "—");
  el("sigmaMap").textContent = "σ: " + (state.sigma? state.sigma.join(" "): "—");
  el("fMap").textContent = "f: " + (state.f? state.f.join(" "): "—");
  el("nonceBox").textContent = "nonce: " + (state.nonce? hex(state.nonce) : "—");
  el("commitBox").textContent = "commit: " + (state.commit? hex(state.commit) : "—");
  el("challengeBox").textContent = "c: " + (state.challenged ?? "—");
}
function setButtons(){
  const fs = el("fsMode").checked;
  el("commitBtn").disabled = !(state.G1 && !state.committed);
  el("ch1").disabled = !state.committed || state.challenged!==null || fs;
  el("ch2").disabled = !state.committed || state.challenged!==null || fs;
  el("respondBtn").disabled = !(state.committed && (state.challenged!==null) && !state.responded);
  el("autoRound").disabled = !state.G1 || state.responded;
  el("autoMany").disabled = !state.G1;
}

/* ===== Flujo del protocolo ===== */
function newInstance(){
  state.n = parseInt(el("nNodes").value||"7",10);
  state.p = parseFloat(el("density").value||"0.35");
  state.G1 = randomGraph(state.n, state.p);
  state.pi = shuffle(range(state.n));       // secreta
  state.G2 = permuteGraph(state.G1, state.pi);
  state.H = null; state.sigma=null; state.f=null;
  state.rounds=0; state.committed=false; state.challenged=null; state.responded=false;
  state.nonce=null; state.commit=null;
  drawGraph(el("g1"), state.G1, {labels:range(state.n)});
  drawGraph(el("g2"), state.G2, {labels:range(state.n)});
  drawGraph(el("h"), null, {});
  showMaps(); setButtons(); setSecurity();
  setStatus("Instancia creada. Pulsa «Comprometer».","");
}
async function commitPhase(){
  // σ y H = σ(G1)
  state.sigma = shuffle(range(state.n));
  state.H = permuteGraph(state.G1, state.sigma);
  // nonce y compromiso com = H( serialize(H) || nonce )
  state.nonce = randBytes(16);
  const serH = serializeGraph(state.H);
  const com = await sha256(concatBytes(serH, state.nonce));
  state.commit = com;
  state.committed=true; state.challenged=null; state.responded=false; state.f=null;
  showMaps(); setButtons();
  setStatus("Compromiso enviado: com = SHA256(H || nonce). Esperando desafío.");
  // En modo Fiat–Shamir, derivar desafío ahora sin intervención del verificador
  if (el("fsMode").checked){
    const context = concatBytes(
      serializeGraph(state.G1),
      serializeGraph(state.G2),
      serializePerm(state.pi),
      state.commit
    );
    const h = await sha256(context);
    const c = (h[h.length-1] & 1) ? 2 : 1; // bit LSB
    state.challenged = c;
    showMaps(); setButtons();
    setStatus(`Fiat–Shamir: desafío derivado c = ${c}. Pulsa «Responder».`);
  }
}
function challenge(c){
  state.challenged = c; showMaps(); setButtons();
  setStatus(`Desafío elegido: c = ${c}. Pulsa «Responder».`);
}
async function respond(){
  // Preparar f según c
  if (state.challenged===1){
    state.f = state.sigma.slice(); // f = σ
  } else if (state.challenged===2){
    state.f = compose(state.sigma, invert(state.pi)); // f = σ ∘ π^{-1}
  } else {
    setStatus("Desafío inválido.","err"); return;
  }
  // Mostrar H (ya comprometido) y verificar binding + isomorfismo
  drawGraph(el("h"), state.H, {labels:range(state.n), classNode:"node h"});
  state.responded=true; showMaps(); setButtons();

  // Verificación de compromiso
  const serH = serializeGraph(state.H);
  const recom = await sha256(concatBytes(serH, state.nonce));
  const bindOK = hex(recom) === hex(state.commit);

  // Verificación de isomorfismo
  const isoOK = state.challenged===1 ? checkIso(state.G1, state.H, state.f)
                                     : checkIso(state.G2, state.H, state.f);
  if (bindOK && isoOK){
    state.rounds += 1; setSecurity();
    setStatus("Verificación: ✅ compromiso coincide y f(G_c)=H. Ronda aceptada.","ok");
  } else {
    let why = (!bindOK?"compromiso inválido ":"") + (!isoOK?"isomorfismo incorrecto":"");
    setStatus("Verificación: ❌ " + why.trim()+".","err");
  }
}
function autoOneRound(){
  if (!state.G1){ setStatus("Crea una instancia primero."); return; }
  commitPhase().then(()=>{
    if (!el("fsMode").checked){
      if (state.challenged===null) challenge( (srnd(2)===0)?1:2 );
    }
    respond();
  });
}
function autoManyRounds(k=10){
  (async ()=>{
    for (let i=0;i<k;i++){
      await commitPhase();
      if (!el("fsMode").checked){
        challenge( (srnd(2)===0)?1:2 );
      }
      await respond();
    }
  })();
}

/* ===== Eventos ===== */
el("newInst").onclick = newInstance;
el("resetRounds").onclick = ()=>{ state.rounds=0; setSecurity(); setStatus("Rondas reiniciadas."); }
el("commitBtn").onclick = ()=>commitPhase();
el("ch1").onclick = ()=>challenge(1);
el("ch2").onclick = ()=>challenge(2);
el("respondBtn").onclick = ()=>respond();
el("autoRound").onclick = ()=>autoOneRound();
el("autoMany").onclick = ()=>autoManyRounds(10);
el("fsMode").onchange = setButtons;

/* Inicial + responsive */
newInstance();
window.addEventListener('resize', ()=>{
  if (state.G1){ drawGraph(el("g1"), state.G1, {labels:range(state.n)}); }
  if (state.G2){ drawGraph(el("g2"), state.G2, {labels:range(state.n)}); }
  if (state.H){ drawGraph(el("h"), state.H, {labels:range(state.n), classNode:"node h"}); }
});
</script>
</body>
</html>
