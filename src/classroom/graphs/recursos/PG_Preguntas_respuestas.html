<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Examen Interactivo de Programaci√≥n Gen√©tica</title>
    <style>
        /* --- ESTILOS GENERALES Y TEMATIZACI√ìN --- */
        :root {
            --bg-primary-light: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            --text-primary-light: #1c1e21;
            --text-secondary-light: #4A5568;
            --bg-secondary-light: rgba(255, 255, 255, 0.7);
            --border-light: #d1d9e6;
            --accent-light: #2b6cb0;
            --shadow-color: rgba(0, 0, 0, 0.1);

            --bg-primary-dark: linear-gradient(135deg, #0f172a 0%, #1e293b 100%);
            --text-primary-dark: #e2e8f0;
            --text-secondary-dark: #94a3b8;
            --bg-secondary-dark: rgba(30, 41, 59, 0.7);
            --border-dark: #334155;
            --accent-dark: #60a5fa;
            --shadow-color: rgba(0, 0, 0, 0.4);
        }

        html { scroll-behavior: smooth; }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            margin: 0;
            padding: 2rem;
            transition: background 0.4s, color 0.4s;
            overflow-x: hidden;
            line-height: 1.8;
        }

        body.light-theme { background: var(--bg-primary-light); color: var(--text-primary-light); }
        body.dark-theme { background: var(--bg-primary-dark); color: var(--text-primary-dark); }
        
        .container {
            max-width: 1000px;
            margin: 1rem auto;
            border-radius: 16px;
            padding: 2.5rem;
            box-shadow: 0 16px 40px var(--shadow-color);
            border: 1px solid;
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            transition: background-color 0.4s, border-color 0.4s;
        }
        body.light-theme .container { background-color: var(--bg-secondary-light); border-color: rgba(255, 255, 255, 0.5); }
        body.dark-theme .container { background-color: var(--bg-secondary-dark); border-color: rgba(255, 255, 255, 0.1); }

        h1 {
            text-align: center; margin-bottom: 1rem; font-size: 2.5rem;
            background: linear-gradient(45deg, var(--accent-light), #3182ce);
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
        }
        body.dark-theme h1 { background: linear-gradient(45deg, var(--accent-dark), #93c5fd); -webkit-background-clip: text; }
        .subtitle {
            text-align: center; font-size: 1.1rem; margin-bottom: 2.5rem;
            color: var(--text-secondary-light);
        }
        body.dark-theme .subtitle { color: var(--text-secondary-dark); }

        /* --- CONTROLES Y PROGRESO --- */
        .controls-container {
            display: flex; gap: 1rem; margin-bottom: 1rem; flex-wrap: wrap;
            justify-content: center; align-items: center; padding: 1rem;
        }
        .search-box {
            padding: 0.8rem 1.2rem; border-radius: 25px; border: 1px solid var(--border-light);
            background-color: var(--bg-secondary-light); transition: all 0.3s ease; min-width: 300px;
            font-size: 1rem;
        }
        body.dark-theme .search-box { background-color: var(--bg-secondary-dark); color: var(--text-primary-dark); border-color: var(--border-dark); }
        .search-box:focus { outline: none; border-color: var(--accent-light); box-shadow: 0 0 12px rgba(43, 108, 176, 0.3); }
        body.dark-theme .search-box:focus { border-color: var(--accent-dark); }
        
        .progress-container {
            padding: 1rem; border-radius: 8px; margin-bottom: 1rem;
            background-color: rgba(0, 0, 0, 0.03);
        }
        body.dark-theme .progress-container { background-color: rgba(255, 255, 255, 0.05); }
        .progress-bar { width: 100%; height: 10px; background-color: rgba(0,0,0,0.1); border-radius: 5px; overflow: hidden; }
        body.dark-theme .progress-bar { background-color: rgba(255,255,255,0.1); }
        .progress-fill { height: 100%; background: linear-gradient(90deg, var(--accent-light), #63b3ed); width: 0%; transition: width 0.5s ease-in-out; }
        body.dark-theme .progress-fill { background: linear-gradient(90deg, var(--accent-dark), #bee3f8); }
        .progress-text { margin-top: 0.5rem; font-size: 0.9rem; font-weight: 500; color: var(--text-secondary-light); }
        body.dark-theme .progress-text { color: var(--text-secondary-dark); }

        /* --- ACORDE√ìN DE PREGUNTAS Y RESPUESTAS --- */
        .qa-item { margin-bottom: 1rem; border-radius: 12px; transition: all 0.3s ease; }
        .qa-item.mastered { border-left: 5px solid #48bb78; } /* Verde para dominado */
        
        .question {
            background-color: transparent; cursor: pointer; padding: 1.2rem 1.5rem;
            width: 100%; border: none; text-align: left; outline: none;
            font-size: 1.1rem; transition: background-color 0.4s; border-radius: 12px;
            font-weight: 600; display: flex; justify-content: space-between; align-items: center;
        }
        body.dark-theme .question { color: var(--text-primary-dark); }
        .question:hover { background-color: rgba(0, 0, 0, 0.05); }
        body.dark-theme .question:hover { background-color: rgba(255, 255, 255, 0.05); }

        .question-icon { font-size: 1.5rem; font-weight: bold; transition: transform 0.3s ease-out; color: var(--accent-light); }
        body.dark-theme .question-icon { color: var(--accent-dark); }
        .question.active .question-icon { transform: rotate(45deg); }
        
        .answer {
            padding: 0 1.5rem; max-height: 0; overflow: hidden;
            transition: max-height 0.5s ease-in-out, padding 0.5s ease-in-out;
            border-top: 1px solid transparent;
        }
        .answer.active { padding: 1.5rem; border-top-color: var(--border-light); }
        body.dark-theme .answer.active { border-top-color: var(--border-dark); }

        code {
            background-color: rgba(43, 108, 176, 0.1); color: var(--accent-light);
            padding: 0.2em 0.4em; border-radius: 5px; font-family: 'SF Mono', 'Fira Code', monospace;
        }
        body.dark-theme code { background-color: rgba(96, 165, 250, 0.15); color: var(--accent-dark); }
        strong { color: var(--accent-light); font-weight: 600; }
        body.dark-theme strong { color: var(--accent-dark); }
        ul, ol { padding-left: 20px; }

        .mastery-button {
            display: inline-block; margin-top: 1rem; padding: 0.5rem 1rem;
            border-radius: 20px; border: 1px solid #48bb78; color: #48bb78;
            background: transparent; cursor: pointer; transition: all 0.3s; font-weight: 500;
        }
        .mastery-button:hover, .mastery-button.mastered { background-color: #48bb78; color: white; }

        /* --- BOTONES DE ACCI√ìN Y FOOTER --- */
        .action-button {
            padding: 0.8rem 1.8rem; border-radius: 25px; border: none;
            cursor: pointer; font-size: 1rem; font-weight: 600;
            transition: all 0.3s ease;
        }
        .action-button:hover { transform: translateY(-2px); box-shadow: 0 8px 25px var(--shadow-color); }
        
        body.light-theme .theme-button { background: linear-gradient(135deg, #333, #555); color: white; }
        body.dark-theme .theme-button { background: linear-gradient(135deg, #f0f0f0, #d0d0d0); color: black; }

        body.light-theme .random-button { background: linear-gradient(135deg, #2b6cb0, #3182ce); color: white; }
        body.dark-theme .random-button { background: linear-gradient(135deg, #60a5fa, #93c5fd); color: black; }

        footer { text-align: center; margin-top: 3rem; font-size: 0.9rem; color: #888; padding: 2rem 0; }
        body.dark-theme footer { color: var(--text-secondary-dark); }

        /* --- BURBUJAS AUTOM√ÅTICAS --- */
        .bubble {
            position: fixed; bottom: -150px; border-radius: 50%;
            pointer-events: none; z-index: -10; opacity: 0;
            animation: rise 25s infinite ease-in-out;
        }
        body.light-theme .bubble { background-color: rgba(43, 108, 176, 0.1); }
        body.dark-theme .bubble { background-color: rgba(96, 165, 250, 0.08); }
        
        @keyframes rise {
            0% { transform: translateY(0) scale(1); opacity: 0; }
            10% { opacity: 0.8; }
            50% { transform: translateY(-50vh) scale(1.2); }
            90% { opacity: 0.4; }
            100% { transform: translateY(-110vh) scale(0.8); opacity: 0; }
        }
    </style>
</head>
<body class="dark-theme">

    <div class="container">
        <h1>Examen Interactivo de Programaci√≥n Gen√©tica</h1>
        <p class="subtitle">
            Pon a prueba tus conocimientos sobre Programaci√≥n Gen√©tica, meta-programaci√≥n evolutiva y agentes como AlphaEvolve con estas preguntas de nivel avanzado.
        </p>
        
        <div class="progress-container">
            <div class="progress-bar"><div class="progress-fill" id="progress-fill"></div></div>
            <div class="progress-text" id="progress-text">Dominio: 0% - 0/20 preguntas dominadas</div>
        </div>
        
        <div class="controls-container">
            <div class="controls">
                <button class="action-button theme-button" id="theme-toggle">‚òÄÔ∏è Cambiar a Tema Claro</button>
                <input type="text" class="search-box" id="search-input" placeholder="üîç Buscar pregunta o concepto...">
                <button class="action-button random-button" id="random-question-btn">üé≤ Pregunta Aleatoria</button>
            </div>
        </div>
    </div>
    
    <div class="container" id="qa-container">
        <!-- Las preguntas se insertar√°n aqu√≠ din√°micamente -->
    </div>

    <footer>
        <p>Material elaborado por el profesor Sergio Gevatschnaider</p>
    </footer>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            
            const questionsAndAnswers = [
                {
                    question: "1. ¬øEn qu√© se diferencia la topolog√≠a del espacio de b√∫squeda en Programaci√≥n Gen√©tica respecto de la de un algoritmo gen√©tico cl√°sico?",
                    answer: `
                        <p>
                            En los algoritmos gen√©ticos tradicionales, el espacio de b√∫squeda suele tener una geometr√≠a simple y estable. 
                            Todos los individuos comparten una representaci√≥n fija, como vectores de bits o listas de valores num√©ricos, 
                            lo que convierte el espacio en un hipercubo o en una estructura regular donde la distancia entre soluciones 
                            est√° bien definida y se mantiene estable a lo largo de la evoluci√≥n.
                        </p>
                        <p>
                            En Programaci√≥n Gen√©tica, en cambio, los individuos son <strong>√°rboles sint√°cticos</strong> cuya estructura, 
                            profundidad y n√∫mero de nodos cambian de generaci√≥n en generaci√≥n. El espacio de b√∫squeda deja de tener 
                            dimensi√≥n fija y se vuelve un territorio de geometr√≠a irregular, vasto, fractal y heterog√©neo, donde cada 
                            modificaci√≥n puede alterar no solo el valor del programa, sino tambi√©n su forma. La PG opera as√≠ sobre un 
                            espacio mucho m√°s creativo y expresivo, pero tambi√©n m√°s dif√≠cil de explorar y controlar.
                        </p>
                    `
                },
                {
                    question: "2. ¬øPor qu√© la Programaci√≥n Gen√©tica trabaja con espacios de dimensionalidad variable y c√≥mo afecta esto la din√°mica evolutiva?",
                    answer: `
                        <p>
                            La Programaci√≥n Gen√©tica utiliza representaciones basadas en √°rboles porque los programas reales no tienen 
                            una estructura r√≠gida: pueden crecer, simplificarse, dividirse en m√≥dulos o combinarse en nuevos bloques. 
                            Cada individuo tiene una dimensionalidad efectiva que depende del n√∫mero de nodos y de la profundidad del √°rbol, 
                            de modo que la poblaci√≥n contiene simult√°neamente soluciones peque√±as y enormes.
                        </p>
                        <p>
                            Esta dimensionalidad variable hace que la din√°mica evolutiva sea mucho m√°s flexible que en un algoritmo gen√©tico cl√°sico, 
                            ya que permite explorar soluciones sencillas y complejas dentro de la misma poblaci√≥n. Sin embargo, tambi√©n introduce 
                            desaf√≠os importantes: el espacio se vuelve m√°s dif√≠cil de recorrer, aparecen regiones donde el tama√±o crece r√°pidamente, 
                            aumentan los costos de evaluaci√≥n y se manifiestan fen√≥menos como el <em>bloat</em>. En s√≠ntesis, se gana capacidad expresiva, 
                            pero se requiere una gesti√≥n cuidadosa de la complejidad para no sacrificar eficiencia.
                        </p>
                    `
                },
                {
                    question: "3. ¬øQu√© implicancias tiene la representaci√≥n de programas como √°rboles en la exploraci√≥n del espacio de hip√≥tesis?",
                    answer: `
                        <p>
                            Cuando un programa se representa como un √°rbol, cada nodo se convierte en una unidad sem√°ntica coherente 
                            (una funci√≥n, una operaci√≥n o un terminal) y cada sub√°rbol pasa a funcionar como un m√≥dulo funcional completo. 
                            Esto facilita la exploraci√≥n evolutiva porque permite modificar partes enteras del programa sin afectar el resto, 
                            favoreciendo la recombinaci√≥n de comportamientos √∫tiles entre individuos distintos.
                        </p>
                        <p>
                            Adem√°s, los √°rboles permiten construir soluciones de forma jer√°rquica, imitando el estilo humano de programaci√≥n, 
                            donde se dise√±an componentes peque√±os que luego se componen en bloques mayores. Esta flexibilidad, sin embargo, 
                            multiplica el tama√±o del espacio de hip√≥tesis y puede dar lugar a programas innecesariamente complejos. Por ello, 
                            la representaci√≥n en forma de √°rbol es simult√°neamente la fuente de la potencia creativa de la PG y el origen de su 
                            necesidad de mecanismos de regulaci√≥n estructural.
                        </p>
                    `
                },
                {
                    question: "4. ¬øC√≥mo influye la profundidad m√°xima permitida en el √°rbol en el trade-off entre expresividad y sobreajuste?",
                    answer: `
                        <p>
                            La profundidad m√°xima de los √°rboles determina cu√°n complejos pueden llegar a ser los programas que la PG es capaz de generar. 
                            Si se permite una profundidad grande, la evoluci√≥n podr√° construir estructuras muy elaboradas, capaces de capturar patrones 
                            sutiles y relaciones altamente no lineales, pero al mismo tiempo aumenta el riesgo de que estas soluciones terminen 
                            memorizando el conjunto de entrenamiento y pierdan capacidad de generalizaci√≥n.
                        </p>
                        <p>
                            Si, por el contrario, la profundidad se restringe demasiado, las soluciones resultar√°n m√°s simples, m√°s f√°ciles de evaluar 
                            y m√°s interpretables, pero tal vez incapaces de representar la complejidad del problema. La profundidad m√°xima act√∫a entonces 
                            como un regulador entre expresividad y riesgo de sobreajuste: elegirla bien implica permitir suficiente riqueza estructural 
                            sin darle libertad absoluta al crecimiento descontrolado de los programas.
                        </p>
                    `
                },
                {
                    question: "5. ¬øQu√© es el bloat y por qu√© emerge incluso sin presi√≥n selectiva expl√≠cita?",
                    answer: `
                        <p>
                            El <strong>bloat</strong> es el crecimiento desproporcionado del tama√±o de los programas, un fen√≥meno que aparece 
                            de manera natural en Programaci√≥n Gen√©tica incluso cuando no hay presi√≥n selectiva expl√≠cita que lo favorezca. 
                            Surgen muchas ramas que son sem√°nticamente neutras, es decir, no modifican el resultado de la evaluaci√≥n, por lo que 
                            la selecci√≥n no las penaliza directamente.
                        </p>
                        <p>
                            Adem√°s, los individuos m√°s grandes tienden a ser m√°s robustos frente a mutaciones disruptivas, lo que les otorga 
                            una ligera ventaja evolutiva, y el operador de <em>crossover</em> suele producir descendientes algo m√°s grandes que sus padres. 
                            La combinaci√≥n de estos efectos induce una deriva hacia √°rboles m√°s extensos que no necesariamente mejoran el desempe√±o. 
                            Esto dificulta la comprensi√≥n de las soluciones, encarece la evaluaci√≥n y puede empeorar la capacidad de generalizaci√≥n, 
                            por lo que es fundamental contar con mecanismos para contener el bloat.
                        </p>
                    `
                },
                {
                    question: "6. ¬øC√≥mo act√∫a la parsimonia (Œª) sobre la funci√≥n de fitness y qu√© riesgos tiene aplicarla en exceso?",
                    answer: `
                        <p>
                            La parsimonia se introduce en la funci√≥n de <em>fitness</em> como un t√©rmino de penalizaci√≥n proporcional al tama√±o del programa. 
                            De este modo, no solo importa qu√© tan bien resuelve el problema un individuo, sino tambi√©n cu√°n grande es su √°rbol. 
                            Programas demasiado extensos pueden ver reducida su aptitud frente a soluciones m√°s compactas con desempe√±o equivalente, 
                            lo que desalienta el crecimiento innecesario y favorece modelos simples y elegantes.
                        </p>
                        <p>
                            Sin embargo, si el par√°metro de parsimonia, habitualmente denotado por <strong>Œª</strong>, es demasiado grande, 
                            la presi√≥n por reducir el tama√±o puede volverse dominante. En ese escenario, la evoluci√≥n tender√° a favorecer programas 
                            triviales que no poseen la complejidad necesaria para capturar la estructura del problema, bloqueando la exploraci√≥n de 
                            soluciones m√°s ricas. La parsimonia es, por tanto, una herramienta poderosa que requiere calibraci√≥n fina para equilibrar 
                            simplicidad y capacidad explicativa.
                        </p>
                    `
                },
                {
                    question: "7. ¬øEn qu√© consiste el crossover de sub√°rboles y por qu√© es un operador estructuralmente significativo?",
                    answer: `
                        <p>
                            El <strong>crossover de sub√°rboles</strong> consiste en seleccionar al azar un nodo en el √°rbol de un individuo 
                            y otro nodo en el √°rbol de un segundo individuo, para luego intercambiar de forma sim√©trica los sub√°rboles que 
                            cuelgan de esos nodos. As√≠, las ramas completas de un programa pasan a insertarse dentro de la estructura del otro.
                        </p>
                        <p>
                            Este operador es estructuralmente significativo porque no se limita a alterar valores puntuales, sino que 
                            recombina m√≥dulos funcionales completos. De este modo, los descendientes pueden heredar comportamientos complejos 
                            ya consolidados en sus progenitores, combinarlos entre s√≠ y dar lugar a soluciones nuevas que ser√≠an muy dif√≠ciles 
                            de alcanzar solo mediante mutaciones peque√±as. El crossover de sub√°rboles act√∫a, en esencia, como motor de creatividad 
                            evolutiva dentro de la Programaci√≥n Gen√©tica.
                        </p>
                    `
                },
                {
                    question: "8. ¬øCu√°l es la diferencia entre mutaci√≥n puntual, mutaci√≥n por reemplazo de sub√°rbol y mutaci√≥n restringida por aridad?",
                    answer: `
                        <p>
                            La <strong>mutaci√≥n puntual</strong> sustituye un nodo por otro nodo que cumple el mismo rol sint√°ctico: 
                            por ejemplo, cambiar una suma por una multiplicaci√≥n o modificar el valor de una constante. Es un operador de ajuste fino, 
                            dise√±ado para explorar variaciones leves en el comportamiento del programa.
                        </p>
                        <p>
                            La <strong>mutaci√≥n por reemplazo de sub√°rbol</strong> es mucho m√°s dr√°stica: reemplaza una rama completa del √°rbol por 
                            un sub√°rbol generado aleatoriamente, lo que puede transformar radicalmente la sem√°ntica del programa. 
                            Finalmente, la <strong>mutaci√≥n restringida por aridad</strong> se asegura de que el nuevo nodo tenga la misma cantidad 
                            de hijos que el nodo original. Al respetar la aridad, la estructura sint√°ctica del √°rbol permanece v√°lida, 
                            evitando errores de tipo o de forma. En conjunto, estas variantes permiten combinar cambios suaves con saltos evolutivos 
                            significativos sin romper la gram√°tica del lenguaje.
                        </p>
                    `
                },
                {
                    question: "9. ¬øPor qu√© la Programaci√≥n Gen√©tica puede considerarse una metodolog√≠a de meta-programaci√≥n evolutiva?",
                    answer: `
                        <p>
                            La Programaci√≥n Gen√©tica puede interpretarse como una forma de <strong>meta-programaci√≥n evolutiva</strong> porque no solo 
                            ajusta par√°metros dentro de un modelo fijo, sino que modifica directamente el c√≥digo de los programas. 
                            El proceso evolutivo genera, eval√∫a, selecciona, recombina y muta estructuras sint√°cticas completas, 
                            introduciendo nuevas funciones, reorganizando patrones l√≥gicos y ensamblando m√≥dulos de manera novedosa.
                        </p>
                        <p>
                            Desde esta perspectiva, la PG no se limita a optimizar una estructura dada, sino que <strong>evoluciona programas</strong> 
                            que, a su vez, pueden generar o transformar otros programas. El sistema act√∫a en un nivel superior al del 
                            aprendizaje param√©trico cl√°sico, ocupando el rol de un programador colectivo guiado por la presi√≥n selectiva 
                            y el desempe√±o medido sobre el problema.
                        </p>
                    `
                },
                {
                    question: "10. ¬øQu√© papel cumplen el F-set y el T-set en la definici√≥n del lenguaje evolutivo?",
                    answer: `
                        <p>
                            El <strong>F-set</strong> y el <strong>T-set</strong> constituyen los cimientos del lenguaje evolutivo en Programaci√≥n Gen√©tica. 
                            El F-set define el conjunto de funciones disponibles: operadores aritm√©ticos, funciones trigonom√©tricas, 
                            condicionales, operadores l√≥gicos y cualquier otro bloque funcional que se desee incorporar. 
                            El T-set especifica los terminales, es decir, las variables de entrada, las constantes num√©ricas y, 
                            eventualmente, otros s√≠mbolos de contexto.
                        </p>
                        <p>
                            Juntos determinan el espacio expresivo del sistema: qu√© tipo de comportamientos pueden representarse y qu√© tan dif√≠cil 
                            ser√° encontrarlos. Un F-set y un T-set demasiado pobres limitan la capacidad para modelar fen√≥menos complejos; 
                            un lenguaje excesivamente rico, en cambio, expande tanto el espacio de b√∫squeda que puede resultar inabordable. 
                            Dise√±ar estos conjuntos es una decisi√≥n estrat√©gica central, donde hay que equilibrar expresividad, relevancia 
                            para el dominio y viabilidad computacional.
                        </p>
                    `
                },
                {
                    question: "11. ¬øC√≥mo eval√∫a la Programaci√≥n Gen√©tica la correcci√≥n sem√°ntica de un programa cuando su sintaxis es v√°lida pero su comportamiento es inesperado?",
                    answer: `
                        <p>
                            En Programaci√≥n Gen√©tica, la correcci√≥n sem√°ntica de un programa se eval√∫a exclusivamente a trav√©s de la 
                            <strong>funci√≥n de fitness</strong>. Aunque la sintaxis sea perfectamente v√°lida, el programa puede producir resultados 
                            err√≥neos, inestables o simplemente irrelevantes para el problema que se quiere resolver. 
                            La manera de detectar esto no es inspeccionando el c√≥digo, sino ejecut√°ndolo.
                        </p>
                        <p>
                            El programa se somete a un conjunto de pruebas, ejemplos o simulaciones y se cuantifica su desempe√±o con una m√©trica definida. 
                            Si el comportamiento es inesperado o incorrecto, el valor de fitness ser√° bajo y el individuo tendr√° pocas probabilidades 
                            de sobrevivir en la poblaci√≥n. La PG es, por tanto, un sistema centrado en la sem√°ntica: lo decisivo no es c√≥mo se ve 
                            el programa, sino lo que hace frente a las tareas planteadas.
                        </p>
                    `
                },
                {
                    question: "12. ¬øPor qu√© la Programaci√≥n Gen√©tica es especialmente efectiva en tareas como la reparaci√≥n autom√°tica de software?",
                    answer: `
                        <p>
                            La Programaci√≥n Gen√©tica es especialmente √∫til en reparaci√≥n autom√°tica de software porque puede trabajar 
                            directamente sobre la sintaxis de un programa existente, introduciendo variaciones estructurales sin que el 
                            desarrollador tenga que especificar manualmente cu√°l es el error. A partir de un conjunto de tests que capturan 
                            el fallo, la PG genera m√∫ltiples candidatos de parche, modificando operadores, constantes o bloques completos de c√≥digo.
                        </p>
                        <p>
                            Cada variante se ejecuta contra los tests: las que no resuelven el error o rompen funcionalidades previas se descartan; 
                            las que mejoran el comportamiento se retienen y se siguen refinando. Este ciclo convierte la reparaci√≥n en un proceso 
                            evolutivo guiado por evidencia emp√≠rica, capaz de explorar soluciones no obvias para humanos y de encontrar 
                            correcciones que respetan el resto del comportamiento del sistema.
                        </p>
                    `
                },
                {
                    question: "13. ¬øQu√© diferencia conceptual hay entre ‚Äúajustar par√°metros‚Äù y ‚Äúevolucionar estructuras program√°ticas‚Äù?",
                    answer: `
                        <p>
                            <strong>Ajustar par√°metros</strong> significa modificar valores dentro de una estructura fija: cambiar pesos en una red neuronal, 
                            coeficientes en una f√≥rmula o hiperpar√°metros en un modelo predefinido. La forma general del sistema permanece inalterada; 
                            lo √∫nico que var√≠a son los n√∫meros que controlan su comportamiento.
                        </p>
                        <p>
                            <strong>Evolucionar estructuras program√°ticas</strong> implica algo m√°s radical: permitir que la forma misma del programa cambie. 
                            Pueden aparecer nuevos m√≥dulos, desaparecer otros, reorganizarse ramas completas del √°rbol y combinarse patrones 
                            de manera creativa. La diferencia conceptual es profunda: en un caso se ‚Äúafina‚Äù un instrumento ya construido; 
                            en el otro, se construyen instrumentos nuevos desde cero. La Programaci√≥n Gen√©tica se sit√∫a precisamente en esta 
                            segunda categor√≠a.
                        </p>
                    `
                },
                {
                    question: "14. ¬øQu√© aporta el modelo evolutivo a un agente como AlphaEvolve en contraste con un LLM tradicional?",
                    answer: `
                        <p>
                            Un modelo de lenguaje grande puede generar fragmentos de c√≥digo plausibles basados en patrones extra√≠dos de datos, 
                            pero no garantiza que ese c√≥digo sea correcto, eficiente o estable. Un agente como <strong>AlphaEvolve</strong> integra esta 
                            capacidad generativa con un <strong>marco evolutivo</strong> que introduce ciclos sistem√°ticos de prueba y mejora.
                        </p>
                        <p>
                            AlphaEvolve no se queda con la primera versi√≥n de c√≥digo producida por el modelo de lenguaje: la ejecuta, mide su desempe√±o, 
                            introduce mutaciones, recombina variantes y selecciona las que funcionan mejor, en un proceso iterativo que va m√°s all√° 
                            de la simple imitaci√≥n de ejemplos humanos. Mientras un LLM tradicional se limita a proponer soluciones veros√≠miles, 
                            el componente evolutivo transforma esa verosimilitud en un punto de partida para una b√∫squeda activa de algoritmos 
                            que pueden superar las ideas presentes en los datos de entrenamiento.
                        </p>
                    `
                },
                {
                    question: "15. ¬øC√≥mo interact√∫an la generaci√≥n estoc√°stica de programas y los mecanismos de evaluaci√≥n determinista del fitness?",
                    answer: `
                        <p>
                            La Programaci√≥n Gen√©tica combina un proceso de generaci√≥n <strong>estoc√°stica</strong> de programas con una evaluaci√≥n 
                            <strong>determinista</strong> de su desempe√±o. La estocasticidad aparece al generar la poblaci√≥n inicial, 
                            al aplicar crossover y al introducir mutaciones; es la fuente principal de diversidad y de exploraci√≥n de regiones 
                            inesperadas del espacio de soluciones.
                        </p>
                        <p>
                            La evaluaci√≥n, en cambio, se basa en reglas deterministas: dado un programa y un conjunto de entradas, su fitness 
                            queda perfectamente definido. Esta combinaci√≥n permite que el sistema mantenga un equilibrio saludable entre creatividad 
                            y rigor: la aleatoriedad propone variaciones; la evaluaci√≥n selecciona √∫nicamente aquellas que producen mejoras reales. 
                            De este modo, la PG explora ampliamente sin perder direcci√≥n ni criterios claros de √©xito.
                        </p>
                    `
                },
                {
                    question: "16. ¬øQu√© retos plantea la exploraci√≥n de espacios de b√∫squeda multimodales y discontinuos en Programaci√≥n Gen√©tica?",
                    answer: `
                        <p>
                            Los espacios de b√∫squeda <strong>multimodales</strong> presentan m√∫ltiples √≥ptimos locales, lo que hace f√°cil que la evoluci√≥n 
                            quede atrapada en soluciones aceptables pero lejos de las mejores posibles. En Programaci√≥n Gen√©tica, adem√°s, 
                            el espacio suele ser <strong>discontinuo</strong>: cambios sint√°cticos peque√±os, como reemplazar un operador o un sub√°rbol, 
                            pueden producir saltos enormes en el comportamiento del programa y, por ende, en su fitness.
                        </p>
                        <p>
                            Esta combinaci√≥n de multimodalidad y discontinuidad complica la navegaci√≥n evolutiva. La poblaci√≥n puede estabilizarse 
                            en configuraciones que parecen robustas pero que est√°n rodeadas de ‚Äúprecipicios‚Äù en el paisaje de fitness. 
                            Para afrontar estos retos, la PG necesita mecanismos que mantengan la diversidad, eviten la convergencia prematura, 
                            exploren m√∫ltiples regiones del espacio en paralelo y, en algunos casos, incorporen estrategias de nichificaci√≥n 
                            o de mantenimiento de subpoblaciones especializadas.
                        </p>
                    `
                },
                {
                    question: "17. ¬øPor qu√© la Programaci√≥n Gen√©tica puede descubrir soluciones no intuitivas para humanos, como en el dise√±o de antenas de la NASA?",
                    answer: `
                        <p>
                            La Programaci√≥n Gen√©tica no est√° limitada por la intuici√≥n, la est√©tica o los prejuicios de dise√±o humanos. 
                            Su √∫nico criterio es el desempe√±o medido por la funci√≥n de fitness. Esto le permite explorar regiones del espacio 
                            de soluciones que un ingeniero nunca considerar√≠a porque parecen ca√≥ticas, ‚Äúfeas‚Äù o simplemente alejadas de los 
                            patrones cl√°sicos de dise√±o.
                        </p>
                        <p>
                            En el caso de las antenas de la NASA, la PG gener√≥ geometr√≠as irregulares y sorprendentes que habr√≠an sido descartadas 
                            a priori por un dise√±ador humano, pero que demostraron tener un rendimiento excepcional. El proceso evolutivo 
                            rompe as√≠ las barreras de la intuici√≥n y del sentido com√∫n, y convierte la exploraci√≥n sistem√°tica del espacio de 
                            soluciones en una fuente de innovaciones radicales y no obvias.
                        </p>
                    `
                },
                {
                    question: "18. ¬øQu√© criterios pueden usarse para garantizar la seguridad y estabilidad de los programas generados durante la evoluci√≥n?",
                    answer: `
                        <p>
                            Garantizar la seguridad y estabilidad de los programas generados evolutivamente requiere actuar tanto sobre la 
                            estructura sint√°ctica como sobre la sem√°ntica. Se pueden imponer restricciones de tipos para evitar combinaciones 
                            ilegales de operadores, limitar la profundidad o el tama√±o de los √°rboles para controlar la complejidad 
                            y encapsular la ejecuci√≥n en <em>sandboxes</em> que prevengan efectos colaterales no deseados.
                        </p>
                        <p>
                            Tambi√©n es posible dise√±ar funciones de fitness que penalicen la inestabilidad num√©rica, la falta de robustez 
                            frente a perturbaciones o la producci√≥n de salidas peligrosas. Pruebas adicionales de validaci√≥n, an√°lisis est√°tico de c√≥digo 
                            y mecanismos de captura de excepciones durante la ejecuci√≥n completan el arsenal de herramientas. 
                            En conjunto, estos criterios aseguran que los individuos que sobreviven no sean solo eficaces, sino tambi√©n seguros y confiables.
                        </p>
                    `
                },
                {
                    question: "19. ¬øC√≥mo se integra la Programaci√≥n Gen√©tica con redes neuronales o modelos de aprendizaje profundo en enfoques h√≠bridos modernos?",
                    answer: `
                        <p>
                            La integraci√≥n entre Programaci√≥n Gen√©tica y aprendizaje profundo puede tomar diversas formas. 
                            Una estrategia consiste en utilizar la PG para <strong>dise√±ar arquitecturas neuronales</strong>, 
                            evolucionando la estructura de la red, sus bloques y patrones de conexi√≥n, mientras que el entrenamiento de pesos 
                            se realiza con m√©todos gradientes tradicionales.
                        </p>
                        <p>
                            Otra posibilidad es que la PG genere componentes simb√≥licos, algoritmos especializados o funciones de preprocesamiento 
                            que luego se integran dentro de un pipeline dominado por redes neuronales. Tambi√©n se pueden usar modelos 
                            de aprendizaje profundo como or√°culos que predicen el potencial de √©xito de ciertas estructuras, guiando as√≠ 
                            la b√∫squeda evolutiva. Estos enfoques h√≠bridos combinan la creatividad estructural de la PG con la potencia 
                            param√©trica del deep learning, abriendo la puerta a sistemas m√°s flexibles y expresivos.
                        </p>
                    `
                },
                {
                    question: "20. ¬øQu√© diferencia filos√≥fica y algor√≠tmica existe entre ‚Äúevolucionar f√≥rmulas‚Äù (regresi√≥n simb√≥lica) y ‚Äúevolucionar algoritmos completos‚Äù (AlphaEvolve)?",
                    answer: `
                        <p>
                            La <strong>regresi√≥n simb√≥lica</strong> se centra en encontrar expresiones matem√°ticas que modelen datos num√©ricos. 
                            Su objetivo es describir relaciones funcionales entre variables mediante combinaciones de operadores y funciones conocidas. 
                            Operacionalmente, trabaja en un espacio de f√≥rmulas relativamente acotado que busca explicar c√≥mo se relacionan las magnitudes 
                            observadas en los datos.
                        </p>
                        <p>
                            <strong>Evolucionar algoritmos completos</strong>, como en el caso de AlphaEvolve, implica ir m√°s all√° de las f√≥rmulas 
                            est√°ticas para construir programas con flujo de control, condicionales, bucles, recursi√≥n y estructuras de decisi√≥n complejas. 
                            Filos√≥ficamente, la regresi√≥n simb√≥lica busca <em>describir</em> el mundo; la evoluci√≥n de algoritmos busca <em>actuar</em> sobre √©l. 
                            Algor√≠tmicamente, el segundo enfoque opera en un espacio mucho m√°s amplio y complejo, capaz de capturar comportamientos din√°micos 
                            y estrategias de resoluci√≥n de problemas, y no solo relaciones funcionales entre entradas y salidas.
                        </p>
                    `
                }
            ];

            const qaContainer = document.getElementById('qa-container');
            const searchInput = document.getElementById('search-input');
            const themeToggle = document.getElementById('theme-toggle');
            const randomBtn = document.getElementById('random-question-btn');
            const progressFill = document.getElementById('progress-fill');
            const progressText = document.getElementById('progress-text');
            const body = document.body;

            const completedQuestions = new Set();
            
            function renderQuestions() {
                qaContainer.innerHTML = '';
                questionsAndAnswers.forEach((qa, index) => {
                    const qaItem = document.createElement('div');
                    qaItem.className = 'qa-item';
                    qaItem.innerHTML = `
                        <button class="question">
                            <span>${qa.question}</span>
                            <span class="question-icon">+</span>
                        </button>
                        <div class="answer">
                            ${qa.answer}
                            <button class="mastery-button" data-index="${index}">Marcar como Dominado</button>
                        </div>
                    `;
                    qaContainer.appendChild(qaItem);
                });
                addEventListeners();
            }

            function addEventListeners() {
                document.querySelectorAll('.question').forEach(button => {
                    button.addEventListener('click', () => {
                        const answer = button.nextElementSibling;
                        button.classList.toggle('active');
                        answer.classList.toggle('active');
                        button.querySelector('.question-icon').textContent = button.classList.contains('active') ? '‚àí' : '+';
                        answer.style.maxHeight = answer.classList.contains('active') ? answer.scrollHeight + "px" : null;
                    });
                });

                document.querySelectorAll('.mastery-button').forEach(button => {
                    button.addEventListener('click', (e) => {
                        e.stopPropagation();
                        const index = e.target.dataset.index;
                        const qaItem = e.target.closest('.qa-item');
                        
                        if (completedQuestions.has(index)) {
                            completedQuestions.delete(index);
                            e.target.textContent = 'Marcar como Dominado';
                            e.target.classList.remove('mastered');
                            qaItem.classList.remove('mastered');
                        } else {
                            completedQuestions.add(index);
                            e.target.textContent = '¬°Dominado!';
                            e.target.classList.add('mastered');
                            qaItem.classList.add('mastered');
                        }
                        updateProgress();
                    });
                });
            }
            
            function updateProgress() {
                const completedCount = completedQuestions.size;
                const totalCount = questionsAndAnswers.length;
                const percentage = totalCount > 0 ? Math.round((completedCount / totalCount) * 100) : 0;

                progressFill.style.width = percentage + '%';
                progressText.textContent = `Dominio: ${percentage}% - ${completedCount}/${totalCount} preguntas dominadas`;
            }

            function filterQuestions() {
                const searchTerm = searchInput.value.toLowerCase().trim();
                document.querySelectorAll('.qa-item').forEach((item, index) => {
                    const qa = questionsAndAnswers[index];
                    const content = (qa.question + qa.answer).toLowerCase();
                    if (content.includes(searchTerm)) {
                        item.style.display = 'block';
                    } else {
                        item.style.display = 'none';
                    }
                });
            }
            
            function showRandomQuestion() {
                const visibleItems = Array.from(document.querySelectorAll('.qa-item')).filter(item => item.style.display !== 'none');
                if (visibleItems.length === 0) return;

                const randomItem = visibleItems[Math.floor(Math.random() * visibleItems.length)];
                
                randomItem.scrollIntoView({ behavior: 'smooth', block: 'center' });
                
                const questionBtn = randomItem.querySelector('.question');
                if (!questionBtn.classList.contains('active')) {
                    questionBtn.click();
                }
            }
            
            function createBubble() {
                const bubble = document.createElement('div');
                bubble.classList.add('bubble');
                const size = Math.random() * 80 + 20;
                bubble.style.width = `${size}px`;
                bubble.style.height = `${size}px`;
                bubble.style.left = `${Math.random() * 100}%`;
                bubble.style.animationDelay = `${Math.random() * 5}s`;
                bubble.style.animationDuration = `${Math.random() * 10 + 15}s`;
                body.appendChild(bubble);
                setTimeout(() => bubble.remove(), 25000);
            }
            
            // --- INICIALIZACI√ìN ---
            renderQuestions();
            updateProgress();
            setInterval(createBubble, 500);
            searchInput.addEventListener('input', filterQuestions);
            themeToggle.addEventListener('click', () => {
                body.classList.toggle('dark-theme');
                body.classList.toggle('light-theme');
                const isDark = body.classList.contains('dark-theme');
                themeToggle.innerHTML = isDark ? '‚òÄÔ∏è Cambiar a Tema Claro' : 'üåô Cambiar a Tema Oscuro';
            });
            randomBtn.addEventListener('click', showRandomQuestion);
        });
    </script>
</body>
</html>
