<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8"/>
<title>Demostración Interactiva: La Intratabilidad del TSP</title>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<style>
  :root { 
    --bg: #111827; --bg-panel: #1f2937; --bg-panel-light: #374151;
    --border: #4b5563; --fg: #d1d5db; --fg-muted: #9ca3af; --fg-header: #f9fafb;
    --accent: #38bdf8; --ok: #4ade80; --warn: #facc15; --bad: #f87171;
  }
  body { 
    margin: 0; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif; 
    background: var(--bg); color: var(--fg); font-size: 14px; line-height: 1.6;
  }
  .container { max-width: 1400px; margin: 0 auto; padding: 24px; }
  header { text-align: center; margin-bottom: 24px; }
  h1 { margin: 0 0 8px; font-size: 28px; color: var(--fg-header); font-weight: 700; }
  header p { margin: 0; color: var(--fg-muted); font-size: 16px; max-width: 800px; margin-inline: auto; }
  
  .main-grid { display: grid; grid-template-columns: 340px 1fr; gap: 24px; }
  .left-column { display: flex; flex-direction: column; gap: 24px; }
  .right-column { display: flex; flex-direction: column; gap: 24px; }

  .panel { background: var(--bg-panel); border: 1px solid var(--border); border-radius: 12px; padding: 20px; }
  .panel h2 { margin: 0 0 16px; font-size: 18px; color: var(--fg-header); border-bottom: 1px solid var(--border); padding-bottom: 12px; }
  
  .control-group { margin-bottom: 16px; }
  .control-group label { display: block; font-weight: 500; margin-bottom: 8px; color: var(--fg-muted); }
  .control-row { display: flex; gap: 12px; align-items: center; }
  input[type="range"] { flex-grow: 1; }
  input[type="number"] { width: 70px; background: var(--bg); border: 1px solid var(--border); color: var(--fg); border-radius: 6px; padding: 8px; text-align: center; }
  button { 
    background: var(--accent); color: #111827; border: none; padding: 10px 16px; 
    border-radius: 8px; cursor: pointer; font-weight: 600; transition: all 0.2s;
    width: 100%; font-size: 14px;
  }
  button:hover:not(:disabled) { filter: brightness(1.1); }
  button:disabled { background: var(--bg-panel-light); color: var(--fg-muted); cursor: not-allowed; }
  .button-group { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-top: 16px; }

  .hardness-meter { margin-top: 16px; }
  .meter-bar { height: 12px; background: var(--bg-panel-light); border: 1px solid var(--border); border-radius: 999px; overflow: hidden; }
  .meter-bar > div { height: 100%; background: linear-gradient(90deg, var(--ok), var(--warn), var(--bad)); width: 0%; transition: width 0.3s; }
  .hardness-label { font-size: 12px; text-align: center; margin-top: 8px; font-weight: 500; }
  .ok { color: var(--ok); } .warn { color: var(--warn); } .bad { color: var(--bad); }

  .results-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 16px; }
  .result-card { background: var(--bg-panel-light); padding: 16px; border-radius: 8px; border: 1px solid var(--border); }
  .result-card h3 { margin: 0 0 12px; font-size: 16px; color: var(--fg); }
  .stat { font-family: "SF Mono", "Fira Code", ui-monospace, monospace; font-size: 14px; display: flex; justify-content: space-between; margin-bottom: 6px;}
  .stat .value { font-weight: 600; color: var(--fg-header); }
  .gap-stat .value { font-weight: 700; padding: 2px 6px; border-radius: 4px; }

  .viz-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 16px; }
  canvas { width: 100%; height: auto; aspect-ratio: 16/10; background: #000; border: 1px solid var(--border); border-radius: 10px; }
  .viz-title { text-align: center; font-size: 12px; color: var(--fg-muted); margin-top: 4px; }
  
  .explanation-panel .item { margin-bottom: 16px; }
  .explanation-panel h3 { font-size: 16px; color: var(--accent); margin-bottom: 4px; }
  .explanation-panel p { margin: 0; color: var(--fg-muted); }

  footer { text-align: center; padding: 24px; color: var(--fg-muted); font-size: 12px; border-top: 1px solid var(--border); margin-top: 24px;}

  @media (max-width: 1200px) { .main-grid { grid-template-columns: 1fr; } }
  @media (max-width: 768px) { .viz-grid, .results-grid { grid-template-columns: 1fr; } }
</style>
</head>
<body>

<div class="container">
  <header>
    <h1>La Explosión Combinatoria del Problema del Viajante (TSP)</h1>
    <p>Una demostración interactiva que compara un algoritmo <strong>exacto</strong> (garantiza la mejor ruta) con uno <strong>heurístico</strong> (rápido pero no perfecto) para ilustrar el concepto de intratabilidad (NP-Hard).</p>
  </header>

  <div class="main-grid">
    <div class="left-column">
      
      <div class="panel">
        <h2><span style="color:var(--accent)">1.</span> Configuración del Problema</h2>
        <div class="control-group">
          <label for="n">Número de ciudades (n)</label>
          <div class="control-row">
            <input id="n" type="range" min="5" max="22" value="12" oninput="syncN(this.value)"/>
            <input id="nNum" type="number" min="5" max="22" value="12" oninput="syncN(this.value)"/>
          </div>
        </div>
        <div class="control-group">
          <label for="seed">Semilla para generar ciudades</label>
          <div class="control-row">
            <input id="seed" type="number" value="1234" style="flex-grow:1;"/>
            <button onclick="regen()" style="width: auto;">Generar</button>
          </div>
        </div>

        <div class="hardness-meter">
          <label>Complejidad Computacional (para el algoritmo exacto)</label>
          <div class="meter-bar"><div id="meterFill"></div></div>
          <div class="hardness-label" id="hardnessLabel"></div>
        </div>
      </div>
      
      <div class="panel">
        <h2><span style="color:var(--accent)">2.</span> Ejecutar Algoritmos</h2>
        <p style="font-size: 12px; color: var(--fg-muted); margin:-8px 0 16px 0;">Observa la diferencia dramática en el tiempo de ejecución a medida que 'n' aumenta.</p>
        <div class="button-group">
          <button id="btnHeu" onclick="solveHeuristic()">Heurístico (Rápido)</button>
          <button id="btnExact" onclick="solveExact()">Exacto (Lento)</button>
        </div>
        <button onclick="resetView()" style="background: var(--bg-panel-light); color: var(--fg-muted); margin-top: 12px;">Limpiar Rutas</button>
      </div>

      <div class="panel">
        <h2><span style="color:var(--accent)">3.</span> Resultados</h2>
        <div class="results-grid">
          <div class="result-card">
            <h3>Heurístico</h3>
            <div class="stat"><span>Coste:</span> <span class="value" id="costHeu">—</span></div>
            <div class="stat"><span>Tiempo:</span> <span class="value" id="timeHeu">—</span></div>
            <div class="stat"><span>Mejoras 2-opt:</span> <span class="value" id="improvHeu">—</span></div>
          </div>
          <div class="result-card">
            <h3>Exacto</h3>
            <div class="stat"><span>Coste Óptimo:</span> <span class="value" id="costExact">—</span></div>
            <div class="stat"><span>Tiempo:</span> <span class="value" id="timeExact">—</span></div>
            <div class="stat gap-stat"><span>Gap (%):</span> <span class="value" id="gap">—</span></div>
          </div>
        </div>
      </div>

    </div>

    <div class="right-column">
      <div class="panel">
        <h2>Visualizaciones</h2>
        <div class="viz-grid">
          <div>
            <canvas id="canvas" width="600" height="375"></canvas>
            <div class="viz-title">Ruta Heurística (naranja) vs. Ruta Óptima (azul)</div>
          </div>
          <div>
            <canvas id="chart" width="600" height="375"></canvas>
            <div class="viz-title">Crecimiento de la Complejidad (Escala Logarítmica)</div>
          </div>
        </div>
      </div>

      <div class="panel explanation-panel">
        <h2>¿Qué significa todo esto?</h2>
        <div class="item">
          <h3>El Reto: Una "Explosión" de Rutas Posibles</h3>
          <p>Para 'n' ciudades, existen <strong>(n-1)! / 2</strong> rutas únicas. Este número crece de forma astronómica. Para 12 ciudades, son ~20 millones de rutas. Para 22 ciudades, ¡son más de 25 trillones! Un ordenador no puede probarlas todas.</p>
        </div>
        <div class="item">
          <h3 style="color: var(--warn)">La Heurística: Un Atajo Inteligente</h3>
          <p>El algoritmo heurístico no intenta encontrar la perfección. Usa una regla simple y rápida (como "ir a la ciudad más cercana") y luego realiza pequeñas mejoras (intercambios 2-opt). Es increíblemente rápido, pero casi nunca garantiza la mejor ruta posible. La "brecha" o "gap" te dice qué tan lejos quedó de la perfección.</p>
        </div>
        <div class="item">
          <h3 style="color: var(--accent)">El Algoritmo Exacto: Garantía a un Coste Exponencial</h3>
          <p>El algoritmo de Held-Karp es mucho más inteligente que la fuerza bruta, pero su tiempo de ejecución sigue creciendo de forma exponencial (aproximadamente <strong>n² * 2ⁿ</strong>). Es factible para pocas ciudades, pero rápidamente se vuelve impracticable. Esto es la esencia de un problema NP-Hard.</p>
        </div>
      </div>
    </div>
  </div>
  
  <footer>
    Material elaborado por el profesor Sergio Gevatschnaider
  </footer>
</div>

<script>
// ---------- ESTADO GLOBAL Y CONFIGURACIÓN ----------
let state = { n:12, pts:[], seed:1234, tourHeu:null, tourOpt:null, costHeu:null, costOpt:null };
const W = 600, H = 375; // Dimensiones del Canvas
let themeColors = {}; // Objeto para almacenar los colores del tema

// ---------- UTILIDADES Y GENERACIÓN DE NÚMEROS ALEATORIOS ----------
function sfc32(a,b,c,d){return function(){a|=0;b|=0;c|=0;d|=0;var t=(a+b|0)+d|0;d=d+1|0;a=b^b>>>9;b=c+(c<<3)|0;c=(c<<21|0)|(c>>>11);c=c+t|0;return (t>>>0)/4294967296;}}
function xmur3(str){for(var i=0,h=1779033703^str.length;i<str.length;i++)h=Math.imul(h^str.charCodeAt(i),3432918353),h=h<<13|h>>>19;return function(){h=Math.imul(h^h>>>16,2246822507);h=Math.imul(h^h>>>13,3266489909);return (h^h>>>16)>>>0}}
function rngFromSeed(seed){const h=xmur3(String(seed)); return sfc32(h(),h(),h(),h()); }

// ---------- LÓGICA DE LA INTERFAZ (UI) ----------
function syncN(v){
  v = Math.max(5, Math.min(22, +v));
  state.n = v;
  document.getElementById('n').value = v;
  document.getElementById('nNum').value = v;
  drawChart();
  updateHardnessMeter();
}

function regen(){
  state.seed = +document.getElementById('seed').value;
  const rand = rngFromSeed(state.seed);
  const pad = 30;
  state.pts = Array.from({length:state.n}, _ => ({x: pad+rand()*(W-2*pad), y: pad+rand()*(H-2*pad)}));
  resetView();
}

function resetView(){
  state.tourHeu = null; state.tourOpt = null; state.costHeu = null; state.costOpt = null;
  document.getElementById('costHeu').textContent = '—';
  document.getElementById('timeHeu').textContent = '—';
  document.getElementById('improvHeu').textContent = '—';
  document.getElementById('costExact').textContent = '—';
  document.getElementById('timeExact').textContent = '—';
  const gapEl = document.getElementById('gap');
  gapEl.textContent = '—';
  gapEl.style.backgroundColor = 'transparent';
  drawCanvas();
}

function updateHardnessMeter(){
  const n = state.n;
  let pct = 0, cls = 'ok', label = 'FACTIBLE';
  if (n <= 11) { pct = (n / 11) * 30; cls = 'ok'; label = 'FACTIBLE (< 1 seg)'; }
  else if (n <= 14) { pct = 30 + ((n - 11) / 3) * 40; cls = 'warn'; label = 'DIFÍCIL (segundos)'; }
  else if (n <= 17) { pct = 70 + ((n-14)/3) * 25; cls = 'bad'; label = 'INTRATABLE (minutos)'; }
  else { pct = 95 + ((n-17)/5); cls = 'bad'; label = 'INVIABLE (horas/días)'; }

  document.getElementById('meterFill').style.width = pct + '%';
  const labelEl = document.getElementById('hardnessLabel');
  labelEl.textContent = label;
  labelEl.className = 'hardness-label ' + cls;
  
  document.getElementById('btnExact').disabled = (n > 15);
  if (n > 15) {
      document.getElementById('btnExact').title = "Deshabilitado para n > 15 para evitar largos tiempos de espera.";
  } else {
      document.getElementById('btnExact').title = "";
  }
}

function setLoadingState(buttonId, isLoading) {
    const btn = document.getElementById(buttonId);
    if (isLoading) {
        btn.disabled = true;
        btn.textContent = 'Calculando...';
    } else {
        btn.disabled = false;
        btn.textContent = buttonId === 'btnHeu' ? 'Heurístico (Rápido)' : 'Exacto (Lento)';
        updateHardnessMeter(); 
    }
}

function updateGap() {
    if (state.costHeu && state.costOpt) {
        const gap = ((state.costHeu / state.costOpt - 1) * 100);
        const gapEl = document.getElementById('gap');
        gapEl.textContent = gap.toFixed(2) + '%';
        if (gap < 5) { gapEl.style.backgroundColor = 'rgba(74, 222, 128, 0.2)'; }
        else if (gap < 15) { gapEl.style.backgroundColor = 'rgba(250, 204, 21, 0.2)'; }
        else { gapEl.style.backgroundColor = 'rgba(248, 113, 113, 0.2)'; }
    }
}

// ---------- FUNCIONES DE DIBUJADO EN CANVAS ----------
function drawCanvas(){
  const cv = document.getElementById('canvas'), g = cv.getContext('2d');
  g.clearRect(0, 0, cv.width, cv.height);

  const drawTour = (tour, color, lineWidth, dashes = []) => {
    if (!tour) return;
    g.save();
    g.lineWidth = lineWidth;
    g.strokeStyle = color;
    g.setLineDash(dashes);
    g.beginPath();
    g.moveTo(state.pts[tour[0]].x, state.pts[tour[0]].y);
    for (let i = 1; i < tour.length; i++) g.lineTo(state.pts[tour[i]].x, state.pts[tour[i]].y);
    g.closePath();
    g.stroke();
    g.restore();
  };

  drawTour(state.tourHeu, '#f97316', 2, [5, 5]);
  drawTour(state.tourOpt, themeColors.accent, 4);

  for (let i = 0; i < state.pts.length; i++) {
    const p = state.pts[i];
    g.beginPath();
    g.arc(p.x, p.y, 6, 0, Math.PI * 2);
    g.fillStyle = (i === 0) ? themeColors.warn : themeColors.bg_panel_light;
    g.fill();
    g.strokeStyle = (i === 0) ? themeColors.fg_header : themeColors.fg_muted;
    g.lineWidth = 2;
    g.stroke();
  }
}

function drawChart(){
    const cv=document.getElementById('chart'), g=cv.getContext('2d'); g.clearRect(0,0,cv.width,cv.height);
    const pad = { t: 30, b: 50, l: 60, r: 20 };
    const w = cv.width - pad.l - pad.r, h = cv.height - pad.t - pad.b;

    g.strokeStyle = themeColors.border; g.lineWidth = 1; g.beginPath();
    g.moveTo(pad.l, pad.t); g.lineTo(pad.l, pad.t + h); g.lineTo(pad.l + w, pad.t + h); g.stroke();
    g.font = '12px "Segoe UI"'; g.fillStyle = themeColors.fg_muted;
    g.save(); g.translate(pad.l-40, pad.t + h/2); g.rotate(-Math.PI/2); g.textAlign="center";
    g.fillText('Operaciones (escala logarítmica)', 0, 0); g.restore();
    g.textAlign="center"; g.fillText('n (número de ciudades)', pad.l + w/2, pad.t+h+35);

    function xOf(n){ return pad.l + (n-5) * (w / (22-5)); }
    function yOf(val){ 
      const log = val > 0 ? Math.log10(val) : 0;
      const maxLog = Math.log10(1e12);
      return pad.t + h - (log / maxLog) * h;
    }
    
    const plot = (compute, color, label) => {
        g.beginPath();
        for(let n=5; n<=22; n++){
            const x=xOf(n), y=yOf(compute(n));
            if(n===5) g.moveTo(x,y); else g.lineTo(x,y);
        }
        g.strokeStyle = color; g.lineWidth=2.5; g.stroke();
        g.fillStyle = color; g.textAlign="left";
        g.fillText(label, xOf(22.5), yOf(compute(22)));
    };
    
    plot(n => n**3, themeColors.fg_muted, 'n³ (Polinomial)');
    plot(n => 2**n, themeColors.warn, '2ⁿ (Exponencial)');
    plot(n => n**2 * 2**n, themeColors.accent, 'n²·2ⁿ (Held-Karp)');
    const fact = n => n > 20 ? 1e100 : Array.from({length: n-1}, (_,i) => i+2).reduce((a,c)=>a*c,1);
    plot(fact, themeColors.bad, 'n! (Fuerza bruta)');

    const currentX = xOf(state.n);
    g.strokeStyle = themeColors.fg_header; g.setLineDash([4,4]); g.beginPath();
    g.moveTo(currentX, pad.t); g.lineTo(currentX, pad.t + h); g.stroke(); g.setLineDash([]);
}

// ---------- ALGORITMOS DE TSP ----------
function dist(i,j){ const a=state.pts[i], b=state.pts[j]; return Math.hypot(a.x-b.x, a.y-b.y); }
function tourLength(t){ let s=0; for(let i=0;i<t.length;i++){ s+=dist(t[i], t[(i+1)%t.length]); } return s; }

function solveHeuristic(){
    setLoadingState('btnHeu', true);
    setTimeout(() => {
        const t0 = performance.now();
        const n = state.n;
        const unvisited = new Set(Array.from({length:n},(_,i)=>i));
        let current = 0; unvisited.delete(current);
        const tour = [current];
        while(unvisited.size > 0){
            let nearest, minDist = Infinity;
            for(const neighbor of unvisited){
                const d = dist(current, neighbor);
                if(d < minDist){ minDist = d; nearest = neighbor; }
            }
            current = nearest;
            unvisited.delete(current);
            tour.push(current);
        }

        let improvements = 0; let improved = true;
        while(improved){
            improved = false;
            for(let i = 0; i < n - 1; i++){
                for(let j = i + 2; j < n; j++){
                    if ( (j+1)%n === i ) continue;
                    const d1 = dist(tour[i], tour[(i+1)%n]) + dist(tour[j], tour[(j+1)%n]);
                    const d2 = dist(tour[i], tour[j]) + dist(tour[(i+1)%n], tour[(j+1)%n]);
                    if(d2 < d1){
                        const segment = tour.slice(i + 1, j + 1);
                        segment.reverse();
                        tour.splice(i + 1, segment.length, ...segment);
                        improvements++;
                        improved = true;
                    }
                }
            }
        }
        
        const cost = tourLength(tour); const t1 = performance.now();
        state.tourHeu = tour; state.costHeu = cost;
        document.getElementById('costHeu').textContent = cost.toFixed(2);
        document.getElementById('timeHeu').textContent = (t1-t0).toFixed(1) + ' ms';
        document.getElementById('improvHeu').textContent = improvements;
        
        updateGap(); drawCanvas(); setLoadingState('btnHeu', false);
    }, 10);
}


function solveExact(){
    setLoadingState('btnExact', true);
    setTimeout(() => {
        const n = state.n;
        const D = Array.from({length:n}, (_,i) => Array.from({length:n}, (_,j) => dist(i,j)));
        const t0 = performance.now();

        const dp = Array.from({length: 1 << n}, () => new Float64Array(n).fill(Infinity));
        const parent = Array.from({length: 1 << n}, () => new Int16Array(n).fill(-1));
        
        dp[1][0] = 0; // dp[mask][j], mask empieza en 1 (solo nodo 0), coste 0.

        for (let mask = 1; mask < (1 << n); mask += 2) { // Itera solo máscaras que incluyen el nodo 0
            for (let i = 0; i < n; i++) {
                if (mask & (1 << i)) { // Si el nodo 'i' está en el subconjunto actual
                    if (dp[mask][i] === Infinity) continue;
                    for (let j = 0; j < n; j++) {
                        if (!(mask & (1 << j))) { // Si el nodo 'j' NO está en el subconjunto
                            const nextMask = mask | (1 << j);
                            const newCost = dp[mask][i] + D[i][j];
                            if (newCost < dp[nextMask][j]) {
                                dp[nextMask][j] = newCost;
                                parent[nextMask][j] = i;
                            }
                        }
                    }
                }
            }
        }

        const fullMask = (1 << n) - 1;
        let minTourCost = Infinity;
        let lastNode = -1;
        for (let j = 1; j < n; j++) {
            const cost = dp[fullMask][j] + D[j][0];
            if (cost < minTourCost) {
                minTourCost = cost;
                lastNode = j;
            }
        }

        const tour = [];
        let currentMask = fullMask;
        let currentNode = lastNode;
        while (currentNode !== -1) {
            tour.unshift(currentNode);
            const prevNode = parent[currentMask][currentNode];
            currentMask ^= (1 << currentNode);
            currentNode = prevNode;
        }

        const t1 = performance.now();
        state.tourOpt = tour; state.costOpt = minTourCost;
        document.getElementById('costExact').textContent = minTourCost.toFixed(2);
        document.getElementById('timeExact').textContent = (t1-t0).toFixed(1) + ' ms';
        
        updateGap(); drawCanvas(); setLoadingState('btnExact', false);
    }, 10);
}


// ---------- INICIALIZACIÓN ----------
window.addEventListener('load', () => {
  // Carga las variables de color CSS en un objeto JS para poder usarlas en el canvas
  const style = getComputedStyle(document.documentElement);
  ['bg', 'bg_panel', 'bg_panel_light', 'border', 'fg', 'fg_muted', 'fg_header', 'accent', 'ok', 'warn', 'bad'].forEach(v => {
      themeColors[v] = style.getPropertyValue(`--${v.replace('_', '-')}`).trim();
  });
  regen();
});

</script>
</body>
</html>