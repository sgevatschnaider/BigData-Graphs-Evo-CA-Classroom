<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8">
<title>Dashboard de Viralidad — Grafo • Evolutivo • Autómata</title>
<meta name="viewport" content="width=device-width, initial-scale=1"/>

<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.1/normalize.min.css">
<script src="https://d3js.org/d3.v7.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>

<!-- MathJax: tipografiar fórmulas después -->
<script>
  window.MathJax = { tex: { inlineMath: [['\\(','\\)'], ['$', '$']] }, startup: { typeset: false } };
</script>
<script defer id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

<style>
  :root{
    --bg:#0f1116; --panel:#141822; --ink:#e8ecf3; --muted:#9aa4b2; --accent:#69b3ff; --accent2:#ffd166;
    --ok:#76e39c; --warn:#ffb86b; --bad:#ff6b6b;
  }
  html,body{height:100%;}
  body{background:var(--bg); color:var(--ink); font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;}
  h1{font-weight:700; margin:16px 0 8px}
  #app{display:grid; grid-template-rows:auto auto 1fr; gap:12px; padding:16px; max-width:1400px; margin:0 auto;}
  .topbar{display:flex; gap:16px; align-items:center; justify-content:space-between}
  .formulas{display:flex; gap:24px; flex-wrap:wrap; font-size:14px; color:var(--muted)}
  .chip{background:#141822; border:1px solid #1f2636; border-radius:8px; padding:8px 10px}
  .controls{display:grid; grid-template-columns:1fr 3fr; gap:12px}
  .panel{background:#141822; border:1px solid #1f2636; border-radius:12px; padding:12px}
  .grid2{display:grid; grid-template-columns:repeat(2,1fr); gap:12px}
  .row{display:flex; gap:12px; align-items:center}
  label{font-size:13px; color:var(--muted); min-width:120px}
  input[type=range]{width:100%}
  .value{font-variant-numeric:tabular-nums; color:var(--accent2)}
  .tabs{display:flex; gap:8px}
  .tab{padding:8px 12px; border-radius:10px; border:1px solid #252c40; background:#161b28; color:var(--muted); cursor:pointer}
  .tab.active{background:#1b2335; color:var(--ink); border-color:#2d364e}
  .views{position:relative; min-height:560px}
  .view{position:absolute; inset:0; display:none}
  .view.active{display:block}
  .split{display:grid; grid-template-columns:2fr 1fr; gap:12px; height:100%}
  .card{background:#121725; border:1px solid #1f2740; border-radius:10px; padding:10px; height:100%}
  .card h3{margin:4px 0 8px; font-size:14px; color:#dbe3ff}
  .metric{font-size:13px; color:var(--muted)}
  .metric b{color:#dbe3ff}
  .legend{font-size:12px; color:var(--muted)}
  .btn{background:#1a2134; border:1px solid #263154; padding:6px 10px; border-radius:8px; color:#dbe3ff; cursor:pointer}
  .btnrow{display:flex; gap:8px; flex-wrap:wrap}
  .badge{display:inline-block; padding:2px 8px; border-radius:8px; background:#1a2134; border:1px solid #263154; font-size:12px; color:#c9d3f2}
  .footer{color:#9aa4b2; font-size:12px; text-align:right; padding:6px 2px}
  /* Dimensiones explícitas */
  #graphSVG, #treeSVG, #evoSVG { width:100%; height:470px; display:block; }
  #gridCanvas { width:800px; height:480px; display:block; background:#0e1320; border-radius:8px }
  canvas{background:#0e1320; border-radius:8px}
  svg{background:#0e1320; border-radius:8px}
</style>
</head>

<body>
<div id="app" aria-live="polite">
  <div class="topbar">
    <div>
      <h1>Dashboard de Viralidad</h1>
      <div style="color:#b8c1d9; font-size:12px">Tres vistas sincronizadas (Grafo, Evolutivo, Autómata) con los mismos parámetros (β, η, λ, κ, ρ, γ).</div>
    </div>
    <div class="formulas">
      <div class="chip">\(P(\text{share}\mid x)=\sigma(\beta^\top x)=\frac{1}{1+e^{-(\beta_0+\beta_v v+\beta_a a+\beta_{va} v a)}}\)</div>
      <div class="chip">\( \alpha'(x)=\eta\,\kappa\,P(\text{share}\mid x) \)</div>
      <div class="chip">\( \mathcal R_0 \approx \alpha'(x)\,\frac{\langle K^2\rangle-\langle K\rangle}{\langle K\rangle} \)</div>
      <div class="chip">\( G(x)=E(x)-\lambda S(x) \)</div>
    </div>
  </div>

  <!-- Parámetros compartidos -->
  <div class="controls">
    <div class="panel">
      <h3>Parámetros del contenido x=(v,a) y del sistema</h3>
      <div class="row"><label>v (valencia)</label><input id="v" type="range" min="-1" max="1" step="0.01" value="-0.5"><span class="value" id="v_val">-0.50</span></div>
      <div class="row"><label>a (activación)</label><input id="a" type="range" min="-1" max="1" step="0.01" value="0.7"><span class="value" id="a_val">0.70</span></div>

      <div class="row"><label>β₀</label><input id="b0" type="range" min="-2" max="2" step="0.01" value="0"><span class="value" id="b0_val">0.00</span></div>
      <div class="row"><label>βᵥ</label><input id="bv" type="range" min="-2" max="2" step="0.01" value="-0.5"><span class="value" id="bv_val">-0.50</span></div>
      <div class="row"><label>βₐ</label><input id="ba" type="range" min="-2" max="2" step="0.01" value="1.0"><span class="value" id="ba_val">1.00</span></div>
      <div class="row"><label>βᵥₐ</label><input id="bva" type="range" min="-2" max="2" step="0.01" value="0.8"><span class="value" id="bva_val">0.80</span></div>

      <div class="row"><label>η (amplificación)</label><input id="eta" type="range" min="0.5" max="2" step="0.01" value="1.2"><span class="value" id="eta_val">1.20</span></div>
      <div class="row"><label>κ (base contagio)</label><input id="kappa" type="range" min="0" max="1" step="0.01" value="0.6"><span class="value" id="kappa_val">0.60</span></div>
      <div class="row"><label>ρ (E→I)</label><input id="rho" type="range" min="0" max="1" step="0.01" value="0.7"><span class="value" id="rho_val">0.70</span></div>
      <div class="row"><label>γ (I→R)</label><input id="gamma" type="range" min="0" max="1" step="0.01" value="0.2"><span class="value" id="gamma_val">0.20</span></div>
      <div class="row"><label>λ (preferencias)</label><input id="lambda" type="range" min="0" max="2" step="0.01" value="1.0"><span class="value" id="lambda_val">1.00</span></div>

      <div class="row"><label>Contexto cultural</label>
        <select id="culture">
          <option value="custom" selected>custom (sliders)</option>
          <option value="western">western</option>
          <option value="eastern">eastern</option>
          <option value="conflict">conflict</option>
        </select>
        <span class="badge" id="culture_badge">Preset: custom</span>
      </div>

      <div class="row"><label>Umbral superspreader</label><input id="ss_thresh" type="range" min="0.5" max="0.99" step="0.01" value="0.80"><span class="value" id="ss_thresh_val">0.80</span></div>
    </div>

    <div class="panel">
      <h3>Opciones de simulación</h3>
      <div class="grid2">
        <div>
          <div class="row"><label>N nodos (grafo)</label><input id="N" type="range" min="60" max="500" step="1" value="220"><span class="value" id="N_val">220</span></div>
          <div class="row"><label>Grado medio</label><input id="kmean" type="range" min="4" max="20" step="1" value="10"><span class="value" id="kmean_val">10</span></div>
          <div class="row"><label>Heterogeneidad</label>
            <select id="nettype">
              <option value="er">Erdős–Rényi (homog.)</option>
              <option value="pa">Preferential Attachment (cola pesada)</option>
            </select>
          </div>
          <div class="row"><label>Semillas iniciales</label><input id="seeds" type="range" min="1" max="30" step="1" value="10"><span class="value" id="seeds_val">10</span></div>
        </div>
        <div>
          <div class="row"><label>Tamaño grilla (autómata)</label><input id="gridw" type="range" min="30" max="120" step="1" value="80"><span class="value" id="gridw_val">80</span></div>
          <div class="row"><label>Altura grilla</label><input id="gridh" type="range" min="20" max="90" step="1" value="50"><span class="value" id="gridh_val">50</span></div>
          <div class="row"><label>Salto algorítmico</label><input id="tele" type="range" min="0" max="50" step="1" value="8"><span class="value" id="tele_val">8</span></div>
          <div class="row"><label>Velocidad simulación</label><input id="speed" type="range" min="0.1" max="3" step="0.1" value="1"><span class="value" id="speed_val">1.0×</span></div>
        </div>
      </div>
      <div class="btnrow" style="margin-top:8px">
        <button class="btn" id="regen" type="button">Regenerar red</button>
        <button class="btn" id="resetAll" type="button">Resetear todo</button>
      </div>
      <div style="font-size:12px; color:#9aa4b2; margin-top:6px">Todos los sliders afectan simultáneamente a Grafo, Evolutivo y Autómata.</div>
    </div>
  </div>

  <!-- Tabs -->
  <div class="tabs">
    <div class="tab active" data-tab="grafo">A) Grafo (macro)</div>
    <div class="tab" data-tab="evolutivo">B) Evolutivo (meso)</div>
    <div class="tab" data-tab="automata">C) Autómata (micro)</div>
  </div>

  <div class="views">
    <!-- ====== GRAFO ====== -->
    <div class="view active" id="view-grafo">
      <div class="split">
        <div class="card">
          <h3>Red y cascada</h3>
          <div class="btnrow" style="margin-bottom:6px">
            <button class="btn" id="g_play"  type="button">▶ Reproducir</button>
            <button class="btn" id="g_step"  type="button">Paso</button>
            <button class="btn" id="g_pause" type="button">⏸ Pausa</button>
            <button class="btn" id="g_reset" type="button">Reiniciar</button>
            <span class="badge">Estados: S=gris, E=azul, I=amarillo, R=rojo</span>
          </div>
          <div class="grid2" style="grid-template-columns:1.6fr 1fr; height:470px">
            <svg id="graphSVG"></svg>
            <svg id="treeSVG"></svg>
          </div>
        </div>
        <div class="card">
          <h3>Métricas (Grafo)</h3>
          <div id="metrics" class="metric"></div>
          <canvas id="chartGI" height="170"></canvas>
          <div class="legend">Curvas: I(t) y C(t). Resumen de superspreaders y VPS.</div>
        </div>
      </div>
    </div>

    <!-- ====== EVOLUTIVO ====== -->
    <div class="view" id="view-evolutivo">
      <div class="split">
        <div class="card">
          <h3>“Criadero de memes” — Plano v–a</h3>
          <div class="btnrow" style="margin-bottom:6px">
            <button class="btn" id="e_step"  type="button">Generación +1</button>
            <button class="btn" id="e_run"   type="button">Auto</button>
            <button class="btn" id="e_pause" type="button">Pausa</button>
            <button class="btn" id="e_reset" type="button">Reset</button>
            <span class="badge">F₁: Alcance (≈ f(R₀)) • F₂: −G(x)</span>
          </div>
          <svg id="evoSVG"></svg>
        </div>
        <div class="card">
          <h3>Métricas (Evolutivo)</h3>
          <div id="e_metrics" class="metric"></div>
          <canvas id="chartPareto" height="180"></canvas>
          <div class="legend">Frente de Pareto y trayectoria de élites.</div>
        </div>
      </div>
    </div>

    <!-- ====== AUTÓMATA ====== -->
    <div class="view" id="view-automata">
      <div class="split">
        <div class="card">
          <h3>Autómata celular S/E/I/R</h3>
          <div class="btnrow" style="margin-bottom:6px">
            <button class="btn" id="c_play"  type="button">▶ Reproducir</button>
            <button class="btn" id="c_step"  type="button">Paso</button>
            <button class="btn" id="c_pause" type="button">⏸ Pausa</button>
            <button class="btn" id="c_reset" type="button">Reiniciar</button>
            <span class="badge">Teletransporte = saltos aleatorios (recomendación)</span>
          </div>
          <canvas id="gridCanvas"></canvas>
        </div>
        <div class="card">
          <h3>Curvas S(t),E(t),I(t),R(t)</h3>
          <canvas id="chartSER" height="240"></canvas>
        </div>
      </div>
    </div>
  </div>

  <div class="footer">Motor común: σ logística; α′=ηκ·σ(βᵀx); R₀≈α′·(E[K²]−E[K])/E[K]; G=E−λS.</div>
</div>

<script>
/* ===================== Utilidades ===================== */
const el = id => document.getElementById(id);
const fmt = (x,d=2)=> (Math.round(x*10**d)/10**d).toFixed(d);
const clamp = (x,a,b)=> Math.max(a, Math.min(b, x));
const rand = (()=>{ let s=1234567; return { seed:(x)=>{s=x;}, r:()=> (s=(s*1664525+1013904223)>>>0,(s>>>8)/16777216) }; })();
function sigma(z){ return 1/(1+Math.exp(-z)); }
function resizeCanvasToDisplaySize(canvas){
  const dpr = window.devicePixelRatio || 1;
  const rect = canvas.getBoundingClientRect();
  if(!rect.width || !rect.height) return;
  canvas.width  = Math.round(rect.width  * dpr);
  canvas.height = Math.round(rect.height * dpr);
}

/* ===================== Estado central (reactivo) ===================== */
const state = {
  v:-0.5, a:0.7,
  b0:0, bv:-0.5, ba:1.0, bva:0.8,
  eta:1.2, kappa:0.6, rho:0.7, gamma:0.2, lambda:1.0,
  N:220, kmean:10, nettype:"er", seeds:10,
  gridw:80, gridh:50, tele:8,
  speed:1.0,
  ss_thresh:0.80,
  culture:"custom"
};
const culturalPresets = {
  western: { b0:0,  bv:-0.8, ba:1.2, bva: 0.9 },
  eastern: { b0:0,  bv: 0.3, ba:1.1, bva:-0.2 },
  conflict:{ b0:0.5,bv:-1.2, ba:1.5, bva: 1.1 }
};

function shareProb(v,a){ const z = state.b0 + state.bv*v + state.ba*a + state.bva*v*a; return sigma(z); }
function alphaPrime(v,a){ return state.eta * state.kappa * shareProb(v,a); }
function likeScore(v,a){
  const sv = 0.5*(1+v);                  // positivo mejor
  const sa = Math.exp(-2*(a-0.2)**2);    // activación moderada
  return clamp(0.15 + 0.7*sv*sa, 0, 1);
}
function viralityParadoxScore(v,a){      // (15)
  return shareProb(v,a) * (1 - likeScore(v,a));
}
function E_eng(v,a){ return clamp(alphaPrime(v,a), 0, 1); }
function G_gap(v,a){ return E_eng(v,a) - state.lambda * likeScore(v,a); }

let updateTimer=null;
function scheduleUpdate(){ clearTimeout(updateTimer); updateTimer=setTimeout(()=>{ refreshAll(); }, 60); }
const stateProxy = new Proxy(state, {
  set(target, key, value){
    target[key] = value;
    const lab = el(key+"_val");
    if(lab){
      if(key==="speed") lab.textContent = Number(value).toFixed(1)+"×";
      else if(["N","kmean","seeds","gridw","gridh","tele"].includes(key)) lab.textContent = String(value);
      else lab.textContent = fmt(Number(value));
    }
    if(key==="culture"){
      el("culture_badge").textContent = "Preset: " + value;
    }
    scheduleUpdate();
    return true;
  }
});

/* ===================== Modelos por vista ===================== */
const timers = { graph:null, evo:null, ca:null };

/* ----- Grafo ----- */
const G = { nodes:[], links:[], adj:[], deg:[], Edeg:0, EK2:0, t:0,
            states:[], parent:[], infectedAt:[],
            seriesI:[], seriesC:[], chart:null,
            supers:[], supersSet:new Set(), contrib:[] };

function buildGraph(){
  const N = Math.floor(state.N);
  const k = Math.max(1, Math.floor(state.kmean/2));
  G.nodes = d3.range(N).map(i=>({id:i}));
  G.links = [];

  if(state.nettype==="er"){
    const p = state.kmean/(N-1);
    for(let i=0;i<N;i++)for(let j=i+1;j<N;j++){ if(rand.r()<p) G.links.push({source:i,target:j}); }
  }else{
    const m = Math.max(1,k);
    const deg = new Array(N).fill(0);
    G.links.push({source:0,target:1},{source:1,target:2},{source:2,target:0});
    deg[0]=deg[1]=deg[2]=2; let sum=6;
    for(let v=3;v<N;v++){
      const chosen=new Set();
      while(chosen.size<m){
        let r=rand.r()*sum, acc=0;
        for(let u=0;u<v;u++){ acc+=Math.max(1,deg[u]); if(acc>=r){ chosen.add(u); break; } }
      }
      chosen.forEach(u=>{ G.links.push({source:v,target:u}); deg[v]++; deg[u]++; sum+=2; });
    }
  }
  G.adj = d3.range(N).map(()=>[]);
  G.links.forEach(e=>{ G.adj[e.source].push(e.target); G.adj[e.target].push(e.source); });
  G.deg = G.adj.map(nei=>nei.length);
  G.Edeg = d3.mean(G.deg); G.EK2 = d3.mean(G.deg.map(d=>d*d));

  G.states = new Array(N).fill(0);
  G.parent = new Array(N).fill(-1);
  G.infectedAt = new Array(N).fill(Infinity);
  const seeds = Math.min(state.seeds,N);
  d3.shuffle(d3.range(N)).slice(0,seeds).forEach(i=>{ G.states[i]=2; G.infectedAt[i]=0; });
  G.t=0; G.seriesI=[seeds]; G.seriesC=[seeds];
  computeSupers();         // inicial
  drawGraph(); drawTree(); initGraphChart(); refreshGraphMetrics();
}
function expectedR0(){
  const ap = alphaPrime(state.v,state.a);
  return ap * (G.EK2 - G.Edeg) / Math.max(1e-6,G.Edeg);
}

/* Superspreader detection (14) */
function calculateNodeContributions(){
  const N=G.nodes.length; const contrib=new Array(N).fill(0);
  for(let i=0;i<N;i++){ const p=G.parent[i]; if(p>=0) contrib[p]++; }
  return contrib;
}
function identifySuperspreaders(threshold){ // threshold en [0..1]
  const contrib = calculateNodeContributions();
  const total = contrib.reduce((a,b)=>a+b,0);
  G.contrib = contrib;
  if(total===0) return [];
  const idx = contrib.map((v,i)=>({i,v})).filter(d=>d.v>0)
                   .sort((a,b)=>b.v-a.v);
  let cum=0; const out=[];
  for(const d of idx){ cum += d.v; out.push(d.i); if(cum/total >= threshold) break; }
  return out;
}
function computeSupers(){
  G.supers = identifySuperspreaders(state.ss_thresh);
  G.supersSet = new Set(G.supers);
}

/* Dibujo */
let graphSVG = d3.select("#graphSVG"), treeSVG=d3.select("#treeSVG"), simForce=null;
function drawGraph(){
  const W = graphSVG.node().clientWidth || 720, H = graphSVG.node().clientHeight || 470;
  graphSVG.attr("width",W).attr("height",H).selectAll("*").remove();

  const link = graphSVG.append("g").selectAll("line")
    .data(G.links).enter().append("line")
    .attr("stroke","#24304e").attr("stroke-opacity",0.6);

  const nodes = graphSVG.append("g").selectAll("circle")
    .data(G.nodes).enter().append("circle")
    .attr("r", d=> 3 + 0.4*G.deg[d.id])
    .attr("stroke","#0e1320").attr("stroke-width",0.8)
    .append("title");

  simForce = d3.forceSimulation(G.nodes)
    .force("link", d3.forceLink(G.links).id(d=>d.id).distance(30).strength(0.05))
    .force("charge", d3.forceManyBody().strength(-30))
    .force("center", d3.forceCenter(W/2,H/2))
    .on("tick", ()=>{
      graphSVG.selectAll("line")
        .attr("x1",d=>d.source.x).attr("y1",d=>d.source.y)
        .attr("x2",d=>d.target.x).attr("y2",d=>d.target.y);
      const color = s => s===0?"#7f8ca399": s===1?"#69b3ff": s===2?"#ffd166":"#ff6b6b";
      graphSVG.selectAll("circle")
        .attr("cx",d=>d.x).attr("cy",d=>d.y)
        .attr("fill", d=> color(G.states[d.id]))
        .attr("stroke", d=> G.supersSet.has(d.id) ? "#9bf6a5" : "#0e1320")
        .attr("stroke-width", d=> G.supersSet.has(d.id) ? 2.5 : 0.8)
        .select("title")
        .text(d=>`Nodo ${d.id}
deg=${G.deg[d.id]}
estado=${["S","E","I","R"][G.states[d.id]]}
tAct=${G.infectedAt[d.id]===Infinity?"–":G.infectedAt[d.id]}
contrib=${G.contrib[d.id]||0}${G.supersSet.has(d.id)?"  (SUPER)":""}`);
    });
}
function drawTree(){
  const W = treeSVG.node().clientWidth || 420, H = treeSVG.node().clientHeight || 470;
  treeSVG.attr("width",W).attr("height",H).selectAll("*").remove();
  const active = d3.range(G.nodes.length).filter(i=>G.infectedAt[i]!==Infinity);
  const byT = d3.group(active, i=>G.infectedAt[i]);
  const times = Array.from(byT.keys()).sort((a,b)=>a-b);
  const colW = Math.max(40, W/Math.max(1,times.length+1));
  const pos = new Map();
  times.forEach((t,ti)=>{
    const arr = byT.get(t)||[];
    const yStep = H/(arr.length+1);
    arr.forEach((n,idx)=> pos.set(n,{x:(ti+1)*colW, y:(idx+1)*yStep}) );
  });
  treeSVG.append("g").selectAll("path")
    .data(active.filter(i=>G.parent[i]>=0)).enter()
    .append("path")
    .attr("d", d=>{
      const p = pos.get(d), q = pos.get(G.parent[d]);
      if(!p||!q) return "";
      return `M${q.x},${q.y} C ${q.x+20},${q.y} ${p.x-20},${p.y} ${p.x},${p.y}`;
    })
    .attr("fill","none").attr("stroke",d=> G.supersSet.has(G.parent[d])?"#9bf6a5":"#2b3a5e")
    .attr("stroke-width", d=> G.supersSet.has(G.parent[d])?2:1);
  treeSVG.append("g").selectAll("circle")
    .data(active).enter().append("circle")
    .attr("cx", d=>pos.get(d)?.x||10).attr("cy", d=>pos.get(d)?.y||10).attr("r",4)
    .attr("fill", d=> G.supersSet.has(d) ? "#9bf6a5" : "#9bb2ff");
}

/* Dinámica */
function graphStep(){
  const N=G.nodes.length, ap=alphaPrime(state.v,state.a);
  const next = G.states.slice(); const newI=[];
  for(let j=0;j<N;j++){
    if(G.states[j]!==0) continue;
    const kI = G.adj[j].reduce((acc,u)=> acc + (G.states[u]===2?1:0), 0);
    const pSE = 1 - Math.pow(1-ap, kI);
    if(rand.r()<pSE){ next[j]=1;
      const cand = G.adj[j].filter(u=>G.states[u]===2);
      if(cand.length>0) G.parent[j]= cand[Math.floor(rand.r()*cand.length)];
      if(G.infectedAt[j]===Infinity) G.infectedAt[j]=G.t+1;
    }
  }
  for(let j=0;j<N;j++){ if(G.states[j]===1 && rand.r()<state.rho){ next[j]=2; newI.push(j); } }
  for(let j=0;j<N;j++){ if(G.states[j]===2 && rand.r()<state.gamma){ next[j]=3; } }
  G.states = next; G.t++;
  const I = G.states.filter(s=>s===2).length;
  const C = G.states.filter(s=>s!==0).length;
  G.seriesI.push(I); G.seriesC.push(C);
  computeSupers();        // actualizar después de cada paso
  drawGraph(); drawTree(); updateGraphChart(); refreshGraphMetrics();
}
function refreshGraphMetrics(){
  const R0 = expectedR0(), ap=alphaPrime(state.v,state.a), vps=viralityParadoxScore(state.v,state.a);
  const I = G.seriesI.length ? G.seriesI[G.seriesI.length-1] : 0;
  const C = G.seriesC.length ? G.seriesC[G.seriesC.length-1] : 0;

  // top-5 superspreaders
  const total = (G.contrib||[]).reduce((a,b)=>a+b,0) || 1;
  const top = (G.contrib||[]).map((v,i)=>({i,v})).filter(d=>d.v>0).sort((a,b)=>b.v-a.v).slice(0,5);

  el("metrics").innerHTML = `
    <div class="row" style="gap:12px; flex-wrap:wrap">
      <div class="badge">t = ${G.t}</div>
      <div class="badge">α′ = ${fmt(ap)}</div>
      <div class="badge">R₀ ≈ ${fmt(R0)}</div>
      <div class="badge">I(t) = ${I}</div>
      <div class="badge">C(t) = ${C}</div>
      <div class="badge">VPS (paradoja) ≈ ${fmt(vps)}</div>
      <div class="badge">Umbral SS = ${fmt(state.ss_thresh)}</div>
      <div class="badge">#Supers = ${G.supers.length}</div>
    </div>
    <div class="metric" style="margin-top:6px">
      <b>Top superspreaders</b> (contribución directa): ${
        top.length? top.map(d=>`#${d.i} (${fmt(100*d.v/total,1)}%)`).join(" · ") : "—"
      }
    </div>
    <div class="metric" style="margin-top:6px">
      <b>Grados</b> · E[K]=${fmt(G.Edeg)} · E[K²]=${fmt(G.EK2)} · Semillas=${state.seeds}
    </div>`;
}
/* Chart I/C */
function initGraphChart(){
  const ctx = el("chartGI").getContext("2d");
  if(G.chart) G.chart.destroy();
  G.chart = new Chart(ctx, {
    type:"line",
    data:{ labels:[0],
      datasets:[
        {label:"I(t)", data:[G.seriesI[0]], borderWidth:2, tension:0.25},
        {label:"C(t)", data:[G.seriesC[0]], borderWidth:2, tension:0.25}
      ]},
    options:{ responsive:true, animation:false,
      scales:{ x:{ticks:{color:"#9aa4b2"}}, y:{ticks:{color:"#9aa4b2"}}},
      plugins:{ legend:{labels:{color:"#c9d3f2"}}}}
  });
}
function updateGraphChart(){
  const L = G.seriesI.length;
  G.chart.data.labels = d3.range(L);
  G.chart.data.datasets[0].data = G.seriesI;
  G.chart.data.datasets[1].data = G.seriesC;
  G.chart.update();
}

/* ----- Evolutivo ----- */
const EVO = { pop:[], gen:0, fronts:[], chart:null, eliteTrace:[] };
function evoInit(){
  EVO.gen=0; EVO.eliteTrace=[];
  EVO.pop = d3.range(120).map(()=>({ v:-1+2*rand.r(), a:-1+2*rand.r(), F1:0, F2:0 }));
  evoEval(); evoDraw(); initParetoChart(); updateEvoMetrics();
}
function evoEval(){
  EVO.pop.forEach(p=>{
    const ap = alphaPrime(p.v,p.a);
    const deg = G.Edeg||Math.max(1,state.kmean);
    const k2  = G.EK2 || ((deg+2)*deg);
    const R0 = ap*(k2-deg)/Math.max(1e-6,deg);
    const size = 1/(1+Math.exp(-4*(R0-1)));
    p.F1 = size; p.F2 = -G_gap(p.v,p.a);
  });
  EVO.fronts = EVO.pop.filter(p=>{
    return !EVO.pop.some(q => (q!==p) && (q.F1>=p.F1 && q.F2>=p.F2) && (q.F1>p.F1 || q.F2>p.F2));
  });
  const best = EVO.pop.slice().sort((a,b)=>(b.F1+b.F2)-(a.F1+a.F2))[0];
  EVO.eliteTrace.push({v:best.v,a:best.a});
}
function evoNextGen(){
  function pick(){ return EVO.pop[Math.floor(rand.r()*EVO.pop.length)]; }
  const children=[];
  while(children.length<EVO.pop.length){
    const a=pick(), b=pick(), c=pick(), d=pick();
    const p1 = ((a.F1+a.F2)>(b.F1+b.F2))? a:b;
    const p2 = ((c.F1+c.F2)>(d.F1+d.F2))? c:d;
    const w = rand.r();
    let v = w*p1.v + (1-w)*p2.v;
    let A = w*p1.a + (1-w)*p2.a;
    v += (rand.r()-0.5)*0.2; A += (rand.r()-0.5)*0.2;
    v = clamp(v,-1,1); A = clamp(A,-1,1);
    children.push({v, a:A, F1:0, F2:0});
  }
  EVO.pop = children; EVO.gen++; evoEval(); evoDraw(); updateParetoChart(); updateEvoMetrics();
}
function evoDraw(){
  const svg = d3.select("#evoSVG");
  const W = svg.node().clientWidth || 900, H = svg.node().clientHeight || 470;
  svg.attr("width",W).attr("height",H).selectAll("*").remove();
  const x = d3.scaleLinear().domain([-1,1]).range([40,W-20]);
  const y = d3.scaleLinear().domain([-1,1]).range([H-30,20]);
  svg.append("g").attr("transform",`translate(0,${H-30})`).call(d3.axisBottom(x)).selectAll("text").attr("fill","#b8c1d9");
  svg.append("g").attr("transform","translate(40,0)").call(d3.axisLeft(y)).selectAll("text").attr("fill","#b8c1d9");
  svg.selectAll(".domain,.tick line").attr("stroke","#2b3554");

  svg.append("g").selectAll("circle").data(EVO.pop).enter().append("circle")
     .attr("cx",d=>x(d.v)).attr("cy",d=>y(d.a)).attr("r",3.5)
     .attr("fill","#5db1ff").attr("opacity",0.65)
     .append("title").text(d=>`v=${fmt(d.v)} a=${fmt(d.a)} F1=${fmt(d.F1)} F2=${fmt(d.F2)}`);

  svg.append("g").selectAll("circle").data(EVO.fronts).enter().append("circle")
     .attr("cx",d=>x(d.v)).attr("cy",d=>y(d.a)).attr("r",5)
     .attr("fill","#ffd166").attr("stroke","#0e1320");

  if(EVO.eliteTrace.length>1){
    const line = d3.line().x(d=>x(d.v)).y(d=>y(d.a)).curve(d3.curveCatmullRom.alpha(0.6));
    svg.append("path").datum(EVO.eliteTrace)
      .attr("d", line).attr("fill","none").attr("stroke","#9bf6a5").attr("stroke-width",2);
  }
  svg.append("circle").attr("cx",x(state.v)).attr("cy",y(state.a)).attr("r",6)
     .attr("fill","none").attr("stroke","#ff6b6b").attr("stroke-width",2);
}
function updateEvoMetrics(){
  const ap = alphaPrime(state.v,state.a);
  const deg = G.Edeg||Math.max(1,state.kmean);
  const k2  = G.EK2 || ((deg+2)*deg);
  const R0 = ap*(k2-deg)/Math.max(1e-6,deg);
  const F1 = 1/(1+Math.exp(-4*(R0-1)));
  const F2 = -G_gap(state.v,state.a);
  const vps = viralityParadoxScore(state.v,state.a);
  el("e_metrics").innerHTML = `
    <div class="row" style="gap:12px; flex-wrap:wrap">
      <div class="badge">Gen = ${EVO.gen}</div>
      <div class="badge">α′ = ${fmt(ap)}</div>
      <div class="badge">R₀ ≈ ${fmt(R0)}</div>
      <div class="badge">F₁ (alcance) ≈ ${fmt(F1)}</div>
      <div class="badge">F₂ (−G) ≈ ${fmt(F2)}</div>
      <div class="badge">VPS ≈ ${fmt(vps)}</div>
      <div class="badge">Pareto: ${EVO.fronts.length} puntos</div>
    </div>`;
}
function initParetoChart(){
  const ctx = el("chartPareto").getContext("2d");
  if(EVO.chart) EVO.chart.destroy();
  EVO.chart = new Chart(ctx, {
    type:"line",
    data:{ labels:[0], datasets:[
      {label:"|Pareto|", data:[0], borderWidth:2, tension:0.25},
      {label:"F₁ elite", data:[0], borderWidth:2, tension:0.25}
    ]},
    options:{ responsive:true, animation:false,
      scales:{ x:{ticks:{color:"#9aa4b2"}}, y:{ticks:{color:"#9aa4b2"}}},
      plugins:{ legend:{labels:{color:"#c9d3f2"}}}}
  });
  updateParetoChart();
}
function updateParetoChart(){
  const best = EVO.pop.slice().sort((a,b)=>(b.F1+b.F2)-(a.F1+a.F2))[0] || {F1:0};
  EVO.chart.data.labels.push(EVO.gen);
  EVO.chart.data.datasets[0].data.push(EVO.fronts.length);
  EVO.chart.data.datasets[1].data.push(best.F1);
  EVO.chart.update();
}

/* ----- Autómata ----- */
const CA = { W:80, H:50, grid:[], t:0, series:{S:[],E:[],I:[],R:[]}, chart:null };
function caInit(){
  CA.W = Math.floor(state.gridw); CA.H=Math.floor(state.gridh);
  CA.grid = new Array(CA.W*CA.H).fill(0);
  for(let s=0;s<10;s++){ CA.grid[Math.floor(rand.r()*CA.grid.length)] = 2; }
  CA.t=0; CA.series={S:[],E:[],I:[],R:[]};
  caMeasure(); caDraw(); initCAChart(); updateCAChart();
}
function idx(x,y){ return y*CA.W+x; }
function neighborsI(x,y){
  let c=0;
  for(let dx=-1;dx<=1;dx++) for(let dy=-1;dy<=1;dy++){
    if(dx===0 && dy===0) continue;
    const nx=x+dx, ny=y+dy;
    if(nx>=0 && nx<CA.W && ny>=0 && ny<CA.H) if(CA.grid[idx(nx,ny)]===2) c++;
  } return c;
}
function caStep(){
  const ap = alphaPrime(state.v,state.a);
  const next = CA.grid.slice();
  const T = Math.floor(state.tele);
  for(let t=0;t<T;t++){ const j=Math.floor(rand.r()*CA.grid.length); if(next[j]===0) next[j]=1; }
  for(let y=0;y<CA.H;y++) for(let x=0;x<CA.W;x++){
    const i=idx(x,y), s=CA.grid[i];
    if(s===0){ const kI=neighborsI(x,y); const p=1-Math.pow(1-ap,kI); if(rand.r()<p) next[i]=1; }
    else if(s===1){ if(rand.r()<state.rho) next[i]=2; }
    else if(s===2){ if(rand.r()<state.gamma) next[i]=3; }
  }
  CA.grid=next; CA.t++; caMeasure(); caDraw(); updateCAChart();
}
function caMeasure(){
  const c=[0,0,0,0]; for(const s of CA.grid) c[s]++;
  CA.series.S.push(c[0]); CA.series.E.push(c[1]); CA.series.I.push(c[2]); CA.series.R.push(c[3]);
}
function caDraw(){
  const cnv = el("gridCanvas"); resizeCanvasToDisplaySize(cnv);
  const ctx = cnv.getContext("2d");
  const {width:W, height:H} = cnv;
  const cw = Math.max(1, Math.floor(W/(CA.W))), ch = Math.max(1, Math.floor(H/(CA.H)));
  ctx.fillStyle="#0e1320"; ctx.fillRect(0,0,W,H);
  for(let y=0;y<CA.H;y++) for(let x=0;x<CA.W;x++){
    const s=CA.grid[idx(x,y)];
    ctx.fillStyle = s===0?"#7f8ca333": s===1?"#69b3ff": s===2?"#ffd166":"#ff6b6b";
    ctx.fillRect(Math.floor(x*cw), Math.floor(y*ch), cw-1, ch-1);
  }
}
function initCAChart(){
  const ctx = el("chartSER").getContext("2d");
  if(CA.chart) CA.chart.destroy();
  CA.chart = new Chart(ctx,{
    type:"line",
    data:{ labels:[0],
      datasets:[
        {label:"S", data:[CA.series.S[0]], borderWidth:2, tension:0.25},
        {label:"E", data:[CA.series.E[0]], borderWidth:2, tension:0.25},
        {label:"I", data:[CA.series.I[0]], borderWidth:2, tension:0.25},
        {label:"R", data:[CA.series.R[0]], borderWidth:2, tension:0.25}
      ]},
    options:{ responsive:true, animation:false,
      scales:{ x:{ticks:{color:"#9aa4b2"}}, y:{ticks:{color:"#9aa4b2"}}},
      plugins:{ legend:{labels:{color:"#c9d3f2"}}}}
  });
}
function updateCAChart(){
  const L = CA.series.S.length;
  CA.chart.data.labels = d3.range(L);
  CA.chart.data.datasets[0].data = CA.series.S;
  CA.chart.data.datasets[1].data = CA.series.E;
  CA.chart.data.datasets[2].data = CA.series.I;
  CA.chart.data.datasets[3].data = CA.series.R;
  CA.chart.update();
}

/* ===================== UI / timers / resize ===================== */
function stopAllTimers(){ for(const k of Object.keys(timers)){ if(timers[k]){ clearInterval(timers[k]); timers[k]=null; } } }

function applyCulturePreset(name){
  if(!culturalPresets[name]) return;
  const P = culturalPresets[name];
  // escribir sliders y stateProxy
  ["b0","bv","ba","bva"].forEach(k=>{
    const s = el(k); s.value = P[k]; stateProxy[k] = Number(P[k]);
  });
  stateProxy.culture = name;
}

function bindUI(){
  // sliders -> stateProxy
  ["v","a","b0","bv","ba","bva","eta","kappa","rho","gamma","lambda",
   "N","kmean","seeds","gridw","gridh","tele","speed","ss_thresh"]
  .forEach(id=>{
    const s = el(id);
    const write = ()=>{ stateProxy[id] = (s.type==="range")? Number(s.value) : s.value; };
    s.addEventListener("input", write); write();
  });

  el("nettype").addEventListener("change", e=>{ stateProxy.nettype = e.target.value; });
  el("culture").addEventListener("change", e=>{
    const v = e.target.value;
    if(v==="custom"){ stateProxy.culture = "custom"; }
    else applyCulturePreset(v);
  });

  // pestañas
  document.querySelectorAll(".tab").forEach(t=>{
    t.addEventListener("click", ()=>{
      document.querySelectorAll(".tab").forEach(x=>x.classList.remove("active"));
      t.classList.add("active");
      const id=t.dataset.tab;
      document.querySelectorAll(".view").forEach(v=>v.classList.remove("active"));
      el("view-"+id).classList.add("active");
      refreshAll();
    });
  });

  // botones grafo
  el("g_play").addEventListener("click", ()=>{ if(!timers.graph){ graphStep(); timers.graph=setInterval(graphStep, Math.max(60, 400/state.speed)); }});
  el("g_pause").addEventListener("click", ()=>{ if(timers.graph){ clearInterval(timers.graph); timers.graph=null; } });
  el("g_step").addEventListener("click", graphStep);
  el("g_reset").addEventListener("click", ()=>{ if(timers.graph){ clearInterval(timers.graph); timers.graph=null; } buildGraph(); });

  // evolutivo
  el("e_step").addEventListener("click", evoNextGen);
  el("e_run").addEventListener("click", ()=>{ if(!timers.evo){ evoNextGen(); timers.evo=setInterval(evoNextGen, Math.max(80, 600/state.speed)); }});
  el("e_pause").addEventListener("click", ()=>{ if(timers.evo){ clearInterval(timers.evo); timers.evo=null; } });
  el("e_reset").addEventListener("click", ()=>{ if(timers.evo){ clearInterval(timers.evo); timers.evo=null; } evoInit(); });

  // autómata
  el("c_play").addEventListener("click", ()=>{ if(!timers.ca){ caStep(); timers.ca=setInterval(caStep, Math.max(50, 200/state.speed)); }});
  el("c_pause").addEventListener("click", ()=>{ if(timers.ca){ clearInterval(timers.ca); timers.ca=null; } });
  el("c_step").addEventListener("click", caStep);
  el("c_reset").addEventListener("click", ()=>{ if(timers.ca){ clearInterval(timers.ca); timers.ca=null; } caInit(); });

  // resize (debounce)
  let rto=null;
  window.addEventListener("resize", ()=>{ clearTimeout(rto); rto=setTimeout(()=>{ refreshAll(); },150); });
}

function refreshAll(){
  computeSupers();
  drawGraph(); drawTree(); updateGraphChart(); refreshGraphMetrics();
  evoDraw(); updateEvoMetrics();
  caDraw(); updateCAChart();
}

async function initializeApp(){
  if(window.MathJax && MathJax.typesetPromise){ await MathJax.typesetPromise(); }
  bindUI();
  rand.seed(1234567);
  buildGraph(); evoInit(); caInit();
}

window.addEventListener('load', initializeApp);
</script>
</body>
</html>
