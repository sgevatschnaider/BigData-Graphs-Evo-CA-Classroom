<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Perspectiva Algebraica: Grafos de Cayley</title>
    <style>
        /* --- ESTILOS GENERALES Y TEMATIZACI√ìN --- */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg-primary: linear-gradient(135deg, #434343 0%, #000000 100%);
            --bg-secondary: rgba(255, 255, 255, 0.9);
            --text-primary: #111827;
            --text-secondary: #374151;
            --accent-primary: #7e22ce;
            --accent-secondary: #be185d;
            --card-bg: rgba(255, 255, 255, 0.75);
            --border-color: rgba(0, 0, 0, 0.1);
            --shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.2);
            --transition: all 0.3s ease-in-out;
        }

        [data-theme="dark"] {
            --bg-primary: linear-gradient(135deg, #1f2937 0%, #111827 100%);
            --bg-secondary: rgba(17, 24, 39, 0.9);
            --text-primary: #e5e7eb;
            --text-secondary: #9ca3af;
            --accent-primary: #a78bfa;
            --accent-secondary: #f472b6;
            --card-bg: rgba(31, 41, 55, 0.75);
            --border-color: rgba(255, 255, 255, 0.1);
            --shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.3);
        }

        html { scroll-behavior: smooth; }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            min-height: 100vh;
            overflow-x: hidden;
            position: relative;
            line-height: 1.7;
            transition: var(--transition);
        }

        /* --- BURBUJAS DE FONDO --- */
        .bubbles {
            position: fixed; top: 0; left: 0;
            width: 100%; height: 100%;
            pointer-events: none; z-index: -1;
        }
        .bubble {
            position: absolute; bottom: -150px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 50%;
            animation: rise 30s infinite ease-in;
        }
        @keyframes rise {
            0% { transform: translateY(0); opacity: 0; }
            10% { opacity: 0.4; }
            90% { opacity: 0.4; }
            100% { transform: translateY(-100vh); opacity: 0; }
        }

        /* --- LAYOUT Y CONTENEDORES --- */
        .container {
            max-width: 1000px; margin: 0 auto;
            padding: 2rem; position: relative; z-index: 1;
        }
        .header { text-align: center; margin-bottom: 3rem; }
        .main-title {
            font-size: clamp(2.5rem, 5vw, 3.8rem); font-weight: 800;
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            background-clip: text; margin-bottom: 1rem; color: white;
        }
        [data-theme="light"] .main-title { color: var(--text-primary); }
        .subtitle {
            font-size: 1.2rem; color: var(--text-secondary);
            max-width: 800px; margin: 0 auto;
        }
        .card {
            background: var(--card-bg);
            backdrop-filter: blur(15px); -webkit-backdrop-filter: blur(15px);
            border: 1px solid var(--border-color);
            border-radius: 20px; padding: 2.5rem;
            margin-bottom: 2.5rem; box-shadow: var(--shadow);
            transition: var(--transition);
        }
        .card:hover { transform: translateY(-5px); }
        h2 { font-size: 2rem; color: var(--accent-primary); margin-bottom: 1.5rem; }
        h3 { font-size: 1.5rem; color: var(--text-primary); margin: 2rem 0 1rem; }

        /* --- FORMATO DE TEXTO Y BLOQUES ESPECIALES --- */
        .formula {
            background: rgba(0, 0, 0, 0.05);
            border-left: 4px solid var(--accent-secondary);
            padding: 1rem; margin: 1rem 0; border-radius: 8px;
            font-family: 'SF Mono', 'Fira Code', 'JetBrains Mono', monospace;
            overflow-x: auto;
        }
        [data-theme="dark"] .formula { background: rgba(0, 0, 0, 0.2); }
        code {
            background-color: rgba(190, 24, 93, 0.1); color: var(--accent-secondary);
            padding: 0.2em 0.4em; border-radius: 5px;
            font-family: 'SF Mono', 'Fira Code', monospace;
        }
        strong { color: var(--accent-primary); }

        /* --- SIMULADOR INTERACTIVO --- */
        .simulator { text-align: center; }
        #cayley-canvas {
            width: 100%; max-width: 500px; height: 500px;
            background: rgba(0,0,0,0.05); border-radius: 15px;
            margin: 1rem auto; border: 1px solid var(--border-color);
        }
        [data-theme="dark"] #cayley-canvas { background: rgba(0,0,0,0.2); }
        .controls {
            display: grid; grid-template-columns: 1fr; gap: 1rem;
            max-width: 500px; margin: 1rem auto; text-align: left;
        }
        .slider {
            -webkit-appearance: none; width: 100%; height: 10px;
            background: rgba(0, 0, 0, 0.1); outline: none; border-radius: 5px;
        }
        .slider::-webkit-slider-thumb {
            -webkit-appearance: none; appearance: none;
            width: 22px; height: 22px; background: var(--accent-primary);
            cursor: pointer; border-radius: 50%;
        }
        .info-grid {
            display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem; margin-top: 1rem; font-family: 'SF Mono', 'Fira Code', monospace;
        }
        .info-box {
            background: rgba(0,0,0,0.05); padding: 1rem; border-radius: 10px;
        }
        [data-theme="dark"] .info-box { background: rgba(0,0,0,0.2); }
        .info-box strong { display: block; }
        .info-box span { color: var(--accent-secondary); font-weight: bold; }

        /* --- OTROS --- */
        .theme-toggle {
            position: fixed; top: 1.5rem; right: 1.5rem;
            width: 50px; height: 50px; border-radius: 50%;
            background: var(--card-bg); border: 1px solid var(--border-color);
            cursor: pointer; display: flex; align-items: center; justify: content: center;
            font-size: 1.2rem; color: var(--accent-primary);
            transition: var(--transition); z-index: 1000;
        }
        .theme-toggle:hover { transform: scale(1.1) rotate(360deg); box-shadow: var(--shadow); }
        footer { text-align: center; padding: 2rem; margin-top: 2rem; color: rgba(255,255,255,0.8); }
    </style>
</head>
<body data-theme="dark">

    <div class="bubbles" id="bubbles-container"></div>
    <button class="theme-toggle" id="theme-toggle-btn" title="Cambiar tema">üåô</button>

    <div class="container">
        <header class="header">
            <h1 class="main-title">Perspectiva Algebraica: Grafos de Cayley</h1>
            <p class="subtitle">Una conexi√≥n profunda entre la teor√≠a de grupos y la teor√≠a de grafos que proporciona una fuente sistem√°tica de grafos regulares y altamente sim√©tricos.</p>
        </header>

        <section class="card">
            <h2>La Construcci√≥n de un Grafo de Cayley</h2>
            <p>Para construir un grafo de Cayley, necesitamos dos ingredientes del √°lgebra abstracta:</p>
            <ul>
                <li><strong>Un grupo finito (G):</strong> Un conjunto de elementos con una operaci√≥n. Pensemos en ellos como los v√©rtices de nuestra red.</li>
                <li><strong>Un conjunto de generadores (X):</strong> Un subconjunto de <code>G</code> que puede generar todos los dem√°s elementos. Debe ser <strong>sim√©trico</strong> (si <code>x</code> est√°, su inverso <code>x‚Åª¬π</code> tambi√©n) y no contener al <strong>elemento neutro</strong>.</li>
            </ul>
            <p>El grafo de Cayley, <code>Cay(G, X)</code>, se define as√≠:</p>
            <ul>
                <li><strong>V√©rtices:</strong> Cada elemento del grupo <code>G</code> es un v√©rtice.</li>
                <li><strong>Aristas:</strong> Existe una arista entre <code>g</code> y <code>h</code> si se puede llegar de uno a otro aplicando un generador. Algebraicamente: <code>h = g ¬∑ x</code> para alg√∫n <code>x</code> en <code>X</code>.</li>
            </ul>
        </section>
        
        <section class="card">
            <h2>Propiedades Clave y M√°s All√° de la Regularidad</h2>
            <h3>Regularidad Garantizada</h3>
            <p>Por su propia construcci√≥n, todo grafo de Cayley es regular. Cada v√©rtice <code>g</code> tiene exactamente <code>|X|</code> vecinos (uno por cada generador en <code>X</code>). Por lo tanto, el grafo <code>Cay(G, X)</code> es <strong><code>|X|</code>-regular</strong>.</p>
            <h3>V√©rtice-Transitividad: La Simetr√≠a Perfecta</h3>
            <p>Una propiedad a√∫n m√°s profunda es que los grafos de Cayley son <strong>v√©rtice-transitivos</strong>. Esto significa que el grafo "se ve igual" desde cualquier v√©rtice. Formalmente, para cualquier par de v√©rtices <code>u</code> y <code>v</code>, existe una simetr√≠a (un automorfismo) del grafo que transforma <code>u</code> en <code>v</code>. Esta es la manifestaci√≥n geom√©trica de que en un grupo, todos los elementos son estructuralmente equivalentes.</p>
        </section>

        <section class="card simulator">
            <h2>Explorador Interactivo de Grafos de Cayley</h2>
            <canvas id="cayley-canvas" width="500" height="500"></canvas>
            <div class="controls">
                <div class="control-group">
                    <label for="graph-type-select">Tipo de Grafo de Cayley:</label>
                    <select id="graph-type-select" style="width: 100%; padding: 0.5rem; border-radius: 8px;">
                        <option value="cycle" selected>Ciclo (Cn)</option>
                        <option value="hypercube">Hipercubo (Qd)</option>
                        <option value="complete">Grafo Completo (Kn)</option>
                        <option value="dihedral">Grafo Diedral (Bipartito)</option>
                    </select>
                </div>
                <div class="control-group">
                    <label id="param-label" for="param-slider">Par√°metro (n): <span id="param-value">6</span></label>
                    <input type="range" min="3" max="15" value="6" class="slider" id="param-slider">
                </div>
            </div>
            <div class="info-grid">
                <div class="info-box"><strong>Grupo (G)</strong><span id="group-info">‚Ñ§‚ÇÜ</span></div>
                <div class="info-box"><strong>Generadores (X)</strong><span id="generators-info">{+1, -1}</span></div>
                <div class="info-box"><strong>Regularidad</strong><span id="regularity-info">2-regular</span></div>
            </div>
        </section>

        <section class="card">
            <h2>Ampliando el Cat√°logo de Ejemplos</h2>
            <h3>1. El Ciclo C<sub>n</sub> (Revisitado)</h3>
            <ul>
                <li><strong>Grupo (G):</strong> El grupo c√≠clico <code>‚Ñ§‚Çô</code> con la suma m√≥dulo <code>n</code>.</li>
                <li><strong>Generadores (X):</strong> <code>{+1, -1}</code>.</li>
                <li><strong>Grafo Resultante:</strong> <code>Cay(‚Ñ§‚Çô, {¬±1})</code> es el ciclo <strong>2-regular</strong> <code>C‚Çô</code>.</li>
            </ul>
            <h3>2. El Hipercubo Q<sub>d</sub> (Revisitado)</h3>
            <ul>
                <li><strong>Grupo (G):</strong> El grupo <code>(‚Ñ§‚ÇÇ)·µà</code> (cadenas binarias) con la operaci√≥n XOR.</li>
                <li><strong>Generadores (X):</strong> Los <code>d</code> vectores unitarios est√°ndar.</li>
                <li><strong>Grafo Resultante:</strong> <code>Cay((‚Ñ§‚ÇÇ)·µà, {e‚ÇÅ,...,e‚Çë})</code> es el hipercubo <strong>d-regular</strong> <code>Qd</code>.</li>
            </ul>
            <h3>3. El Grafo Completo K<sub>n</sub></h3>
            <ul>
                <li><strong>Grupo (G):</strong> El grupo c√≠clico <code>‚Ñ§‚Çô</code>.</li>
                <li><strong>Generadores (X):</strong> <strong>Todos</strong> los elementos no nulos de <code>‚Ñ§‚Çô</code>, es decir, <code>{1, 2, ..., n-1}</code>.</li>
                <li><strong>Grafo Resultante:</strong> <code>Cay(‚Ñ§‚Çô, {1,...,n-1})</code>. Como <code>|X| = n-1</code>, el grafo es <strong>(n-1)-regular</strong>. Cada v√©rtice <code>v</code> se conecta con <code>v+k</code> para todo <code>k</code> de 1 a <code>n-1</code>, lo que significa que se conecta con todos los dem√°s, formando el grafo completo <code>K‚Çô</code>.</li>
            </ul>
            <h3>4. Grafos Bipartitos Regulares (Grupo Diedral)</h3>
            <p>Podemos generar grafos bipartitos <code>n</code>-regulares usando el grupo de las simetr√≠as de un pol√≠gono de <code>n</code> lados.</p>
            <ul>
                <li><strong>Grupo (G):</strong> El grupo diedral <code>D‚Çô</code>, de orden <code>2n</code>. Sus elementos son <code>n</code> rotaciones y <code>n</code> reflexiones.</li>
                <li><strong>Generadores (X):</strong> El conjunto de las <code>n</code> reflexiones.</li>
                <li><strong>Grafo Resultante:</strong> <code>Cay(D‚Çô, {reflexiones})</code> es un grafo <strong><code>n</code>-regular</strong> y <strong>bipartito</strong>. Los v√©rtices se dividen naturalmente en dos particiones: las rotaciones y las reflexiones.</li>
            </ul>
        </section>

        <section class="card">
            <h2>Aplicaciones e Importancia</h2>
            <p>Los grafos de Cayley no son solo una curiosidad algebraica; son fundamentales en varias √°reas:</p>
            <ul>
                <li><strong>Topolog√≠as de Red:</strong> Su alta simetr√≠a los hace ideales para dise√±ar redes de interconexi√≥n en supercomputadoras y centros de datos. El hipercubo es un ejemplo cl√°sico de arquitectura de computaci√≥n paralela.</li>
                <li><strong>Dise√±o de Algoritmos:</strong> Propiedades como la v√©rtice-transitividad simplifican los algoritmos de enrutamiento y difusi√≥n de informaci√≥n en la red.</li>
                <li><strong>Modelado:</strong> Se utilizan para modelar espacios de estados en problemas combinatorios y puzzles, como el Cubo de Rubik, cuyo grafo de estados es un grafo de Cayley.</li>
            </ul>
        </section>

        <footer>
            <p>Material elaborado por el profesor Sergio Gevatschnaider</p>
        </footer>

    </div>

    <script>
    document.addEventListener('DOMContentLoaded', () => {
        // --- M√ìDULO 1: UI (TEMA Y BURBUJAS) ---
        const themeToggleBtn = document.getElementById('theme-toggle-btn');
        const bubblesContainer = document.getElementById('bubbles-container');
        const set_theme = (theme) => {
            document.body.setAttribute('data-theme', theme);
            localStorage.setItem('theme', theme);
            themeToggleBtn.textContent = theme === 'dark' ? '‚òÄÔ∏è' : 'üåô';
        };
        themeToggleBtn.addEventListener('click', () => {
            const new_theme = document.body.getAttribute('data-theme') === 'dark' ? 'light' : 'dark';
            set_theme(new_theme);
        });
        if (bubblesContainer) {
            setInterval(() => {
                const bubble = document.createElement('div');
                bubble.classList.add('bubble');
                const size = Math.random() * 80 + 20;
                bubble.style.width = `${size}px`;
                bubble.style.height = `${size}px`;
                bubble.style.left = `${Math.random() * 100}vw`;
                bubble.style.animationDuration = `${Math.random() * 15 + 15}s`;
                bubblesContainer.appendChild(bubble);
                setTimeout(() => bubble.remove(), 30000);
            }, 500);
        }
        set_theme(localStorage.getItem('theme') || 'dark');

        // --- M√ìDULO 2: CLASE DEL VISUALIZADOR DE CAYLEY ---
        class CayleyGraphVisualizer {
            constructor(canvasId) {
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d');
            }

            _getThemeColors() {
                return {
                    node: getComputedStyle(document.documentElement).getPropertyValue('--accent-primary').trim(),
                    node2: getComputedStyle(document.documentElement).getPropertyValue('--accent-secondary').trim(),
                    edge: getComputedStyle(document.documentElement).getPropertyValue('--text-secondary').trim(),
                    label: getComputedStyle(document.documentElement).getPropertyValue('--bg-secondary').trim(),
                };
            }
            
            _drawGraph(nodes, edges, colors) {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

                this.ctx.strokeStyle = colors.edge;
                this.ctx.lineWidth = 2;
                edges.forEach(edge => {
                    const from = nodes[edge.from];
                    const to = nodes[edge.to];
                    this.ctx.beginPath();
                    this.ctx.moveTo(from.x, from.y);
                    this.ctx.lineTo(to.x, to.y);
                    this.ctx.stroke();
                });

                nodes.forEach(node => {
                    this.ctx.beginPath();
                    this.ctx.arc(node.x, node.y, node.radius, 0, 2 * Math.PI);
                    this.ctx.fillStyle = node.color || colors.node;
                    this.ctx.fill();
                    
                    if (node.label !== undefined) {
                        this.ctx.fillStyle = colors.label;
                        this.ctx.font = `bold ${node.radius * 0.7}px Arial`;
                        this.ctx.textAlign = 'center';
                        this.ctx.textBaseline = 'middle';
                        this.ctx.fillText(node.label, node.x, node.y);
                    }
                });
            }

            drawCycle(n) {
                const nodes = [], edges = [];
                const centerX = this.canvas.width / 2, centerY = this.canvas.height / 2;
                const radius = Math.min(centerX, centerY) * 0.8;
                const nodeRadius = Math.max(10, 35 - n);

                for (let i = 0; i < n; i++) {
                    const angle = (i * 2 * Math.PI) / n - Math.PI / 2;
                    nodes.push({x: centerX+radius*Math.cos(angle), y: centerY+radius*Math.sin(angle), radius: nodeRadius, label: i});
                    edges.push({ from: i, to: (i + 1) % n });
                }
                this._drawGraph(nodes, edges, this._getThemeColors());
            }

            drawComplete(n) {
                 const nodes = [], edges = [];
                const centerX = this.canvas.width / 2, centerY = this.canvas.height / 2;
                const radius = Math.min(centerX, centerY) * 0.8;
                const nodeRadius = Math.max(10, 35 - n * 1.5);
                for(let i=0; i<n; i++){
                    const angle = (i * 2 * Math.PI) / n - Math.PI/2;
                    nodes.push({x: centerX+radius*Math.cos(angle), y: centerY+radius*Math.sin(angle), radius: nodeRadius, label: i});
                    for(let j=0; j<i; j++){
                        edges.push({from: i, to: j});
                    }
                }
                 this._drawGraph(nodes, edges, this._getThemeColors());
            }
            
            drawHypercube(d) {
                const n = 2 ** d;
                const nodes = [], edges = [];
                const nodeRadius = Math.max(8, 25 - n);
                const centerX = this.canvas.width/2, centerY = this.canvas.height/2;
                const scale = Math.min(centerX, centerY) * 0.8;

                for(let i=0; i<n; i++){
                    let pos = {x:0, y:0};
                    for(let j=0; j<d; j++){
                        if((i >> j) & 1){
                           pos.x += Math.cos(j * 2 * Math.PI / d);
                           pos.y += Math.sin(j * 2 * Math.PI / d);
                        }
                    }
                    nodes.push({x: centerX + pos.x * scale / d, y: centerY + pos.y * scale/d, radius: nodeRadius, label: i.toString(2).padStart(d, '0')});
                }
                
                for (let i = 0; i < n; i++) {
                    for (let bit = 0; bit < d; bit++) {
                        const neighbor = i ^ (1 << bit);
                        if (i < neighbor) edges.push({ from: i, to: neighbor });
                    }
                }
                this._drawGraph(nodes, edges, this._getThemeColors());
            }
            
            drawDihedral(n) {
                const nodes = [], edges = [];
                const colors = this._getThemeColors();
                const centerX = this.canvas.width / 2, centerY = this.canvas.height / 2;
                const r1 = Math.min(centerX, centerY) * 0.8; // rotations
                const r2 = Math.min(centerX, centerY) * 0.4; // reflections
                const nodeRadius = Math.max(8, 28 - n);

                // Rotations (outer circle)
                for(let i=0; i<n; i++){
                    const angle = (i * 2 * Math.PI) / n - Math.PI / 2;
                    nodes.push({x: centerX+r1*Math.cos(angle), y: centerY+r1*Math.sin(angle), radius: nodeRadius, label: `r${i}`, color: colors.node});
                }
                // Reflections (inner circle)
                for(let i=0; i<n; i++){
                    const angle = (i * 2 * Math.PI) / n - Math.PI / 2;
                     nodes.push({x: centerX+r2*Math.cos(angle), y: centerY+r2*Math.sin(angle), radius: nodeRadius, label: `s${i}`, color: colors.node2});
                }

                // Edges: each rotation is connected to n reflections
                for(let i=0; i<n; i++){ // for each rotation r_i
                    for(let j=0; j<n; j++){ // connect to reflection s_j
                         edges.push({ from: i, to: ( (i+j) % n) + n });
                    }
                }
                this._drawGraph(nodes, edges, colors);
            }
        }

        // --- M√ìDULO 3: CONTROLADOR ---
        const visualizer = new CayleyGraphVisualizer('cayley-canvas');
        const select = document.getElementById('graph-type-select');
        const slider = document.getElementById('param-slider');
        const paramLabel = document.getElementById('param-label');
        const paramValue = document.getElementById('param-value');
        const groupInfo = document.getElementById('group-info');
        const generatorsInfo = document.getElementById('generators-info');
        const regularityInfo = document.getElementById('regularity-info');

        function updateUI() {
            const type = select.value;
            let param = parseInt(slider.value);
            
            paramValue.textContent = param;

            if (type === 'cycle') {
                paramLabel.innerHTML = `Par√°metro (n): <span id="param-value">${param}</span>`;
                slider.min = 3; slider.max = 20;
                groupInfo.textContent = `‚Ñ§${param}`;
                generatorsInfo.textContent = "{+1, -1}";
                regularityInfo.textContent = "2-regular";
                visualizer.drawCycle(param);
            } else if (type === 'hypercube') {
                paramLabel.innerHTML = `Par√°metro (d): <span id="param-value">${param}</span>`;
                slider.min = 1; slider.max = 5;
                if (param > 5) { param = 5; slider.value = 5; }
                groupInfo.textContent = `(‚Ñ§‚ÇÇ) ${param}`;
                generatorsInfo.textContent = `{e‚ÇÅ...e${param}}`;
                regularityInfo.textContent = `${param}-regular`;
                visualizer.drawHypercube(param);
            } else if (type === 'complete'){
                paramLabel.innerHTML = `Par√°metro (n): <span id="param-value">${param}</span>`;
                slider.min = 2; slider.max = 12;
                groupInfo.textContent = `‚Ñ§${param}`;
                generatorsInfo.textContent = `{1..${param-1}}`;
                regularityInfo.textContent = `${param-1}-regular`;
                visualizer.drawComplete(param);
            } else if (type === 'dihedral'){
                paramLabel.innerHTML = `Par√°metro (n): <span id="param-value">${param}</span>`;
                slider.min = 3; slider.max = 10;
                 if (param < 3) { param = 3; slider.value = 3; }
                groupInfo.textContent = `D${param} (orden 2n)`;
                generatorsInfo.textContent = `{${param} reflexiones}`;
                regularityInfo.textContent = `${param}-regular`;
                visualizer.drawDihedral(param);
            }
        }

        select.addEventListener('change', () => {
            if (select.value === 'cycle') slider.value = 6;
            if (select.value === 'hypercube') slider.value = 3;
            if (select.value === 'complete') slider.value = 5;
            if (select.value === 'dihedral') slider.value = 4;
            updateUI();
        });
        slider.addEventListener('input', updateUI);
        
        const themeObserver = new MutationObserver(updateUI);
        themeObserver.observe(document.body, { attributes: true, attributeFilter: ['data-theme'] });

        updateUI(); // Initial draw
    });
    </script>
</body>
</html>