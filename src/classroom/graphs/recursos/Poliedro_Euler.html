<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Demostraci√≥n Visual - F√≥rmula de Euler</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    
    body {
      font-family: 'Segoe UI', system-ui, sans-serif;
      background: linear-gradient(135deg, #0a0e27 0%, #1a1f3a 100%);
      color: #e0e0e0;
      overflow-x: hidden;
    }

    .container {
      max-width: 1400px;
      margin: 0 auto;
      padding: 20px;
    }

    header {
      text-align: center;
      padding: 30px 0;
      background: linear-gradient(135deg, rgba(79, 124, 255, 0.1), rgba(138, 43, 226, 0.1));
      border-radius: 20px;
      margin-bottom: 30px;
      border: 1px solid rgba(79, 124, 255, 0.3);
    }

    h1 {
      font-size: 2.5em;
      margin-bottom: 10px;
      background: linear-gradient(135deg, #4f7cff, #b47cff);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }

    .formula-main {
      font-size: 1.8em;
      color: #ffd700;
      margin: 15px 0;
    }

    .grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 20px;
      margin-bottom: 20px;
    }

    .panel {
      background: rgba(30, 35, 60, 0.8);
      border-radius: 15px;
      padding: 25px;
      border: 1px solid rgba(79, 124, 255, 0.2);
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
    }

    .canvas-container {
      position: relative;
      width: 100%;
      height: 500px;
      background: rgba(10, 14, 39, 0.6);
      border-radius: 12px;
      overflow: hidden;
      border: 2px solid rgba(79, 124, 255, 0.3);
    }

    canvas {
      display: block;
      width: 100%;
      height: 100%;
    }

    .controls {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 15px;
      margin-bottom: 20px;
    }

    .control-group {
      background: rgba(20, 25, 45, 0.6);
      padding: 15px;
      border-radius: 10px;
      border: 1px solid rgba(79, 124, 255, 0.2);
    }

    label {
      display: block;
      margin-bottom: 8px;
      color: #a0a0ff;
      font-weight: 600;
      font-size: 0.9em;
    }

    select, input[type="range"] {
      width: 100%;
      padding: 8px;
      background: rgba(30, 35, 60, 0.8);
      border: 1px solid rgba(79, 124, 255, 0.3);
      border-radius: 6px;
      color: #e0e0e0;
      font-size: 1em;
    }

    input[type="range"] {
      cursor: pointer;
    }

    .btn-group {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }

    button {
      padding: 12px 24px;
      background: linear-gradient(135deg, #4f7cff, #6b8fff);
      border: none;
      border-radius: 8px;
      color: white;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s ease;
      font-size: 0.95em;
    }

    button:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(79, 124, 255, 0.4);
    }

    button.secondary {
      background: linear-gradient(135deg, #6b4fff, #8b6fff);
    }

    .stats {
      display: grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 15px;
      margin-bottom: 20px;
    }

    .stat-card {
      background: linear-gradient(135deg, rgba(79, 124, 255, 0.15), rgba(138, 43, 226, 0.15));
      padding: 20px;
      border-radius: 12px;
      text-align: center;
      border: 1px solid rgba(79, 124, 255, 0.3);
      transition: all 0.3s ease;
    }

    .stat-card:hover {
      transform: translateY(-4px);
      box-shadow: 0 8px 24px rgba(79, 124, 255, 0.3);
    }

    .stat-label {
      font-size: 0.9em;
      color: #a0a0ff;
      margin-bottom: 8px;
    }

    .stat-value {
      font-size: 2.5em;
      font-weight: bold;
      color: #fff;
    }

    .stat-formula {
      font-size: 0.85em;
      color: #ffd700;
      margin-top: 8px;
    }

    .result {
      background: linear-gradient(135deg, rgba(31, 139, 76, 0.2), rgba(31, 139, 76, 0.1));
      border: 2px solid #1f8b4c;
      padding: 20px;
      border-radius: 12px;
      text-align: center;
      font-size: 1.3em;
      margin-top: 20px;
    }

    .result.invalid {
      background: linear-gradient(135deg, rgba(176, 0, 32, 0.2), rgba(176, 0, 32, 0.1));
      border-color: #b00020;
    }

    .legend {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 10px;
      margin-top: 15px;
    }

    .legend-item {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 0.9em;
    }

    .legend-color {
      width: 20px;
      height: 20px;
      border-radius: 4px;
      border: 1px solid rgba(255, 255, 255, 0.3);
    }

    .info-box {
      background: rgba(79, 124, 255, 0.1);
      border-left: 4px solid #4f7cff;
      padding: 15px;
      border-radius: 8px;
      margin-top: 15px;
      font-size: 0.95em;
      line-height: 1.6;
    }

    .step-indicator {
      display: flex;
      justify-content: space-between;
      margin-bottom: 20px;
      padding: 15px;
      background: rgba(20, 25, 45, 0.6);
      border-radius: 10px;
    }

    .step {
      flex: 1;
      text-align: center;
      padding: 10px;
      border-radius: 8px;
      transition: all 0.3s ease;
      cursor: pointer;
    }

    .step.active {
      background: rgba(79, 124, 255, 0.3);
      border: 1px solid #4f7cff;
    }
    
    footer {
      text-align: center;
      padding: 20px;
      margin-top: 30px;
      color: #888;
      border-top: 1px solid rgba(79, 124, 255, 0.2);
    }

    @media (max-width: 968px) {
      .grid { grid-template-columns: 1fr; }
      .stats { grid-template-columns: repeat(2, 1fr); }
    }
  </style>
</head>
<body>
  <div class="container">
    <header>
      <h1>üî∑ Demostraci√≥n Visual de la F√≥rmula de Euler üî∑</h1>
      <div class="formula-main">V - E + F = œá</div>
      <p>Explora poliedros en 3D con proyecci√≥n esf√©rica interactiva</p>
    </header>

    <div class="stats">
      <div class="stat-card">
        <div class="stat-label">V√©rtices (V)</div>
        <div class="stat-value" id="vertexCount">0</div>
        <div class="stat-formula">Puntos</div>
      </div>
      <div class="stat-card">
        <div class="stat-label">Aristas (E)</div>
        <div class="stat-value" id="edgeCount">0</div>
        <div class="stat-formula">L√≠neas</div>
      </div>
      <div class="stat-card">
        <div class="stat-label">Caras (F)</div>
        <div class="stat-value" id="faceCount">0</div>
        <div class="stat-formula">Superficies</div>
      </div>
      <div class="stat-card">
        <div class="stat-label">œá (Chi)</div>
        <div class="stat-value" id="chiValue">0</div>
        <div class="stat-formula">V - E + F</div>
      </div>
    </div>

    <div class="result" id="result">
      Selecciona un poliedro para comenzar
    </div>

    <div class="panel">
      <h2 style="margin-bottom: 20px;">üéÆ Controles Interactivos</h2>
      
      <div class="controls">
        <div class="control-group">
          <label>Seleccionar Poliedro</label>
          <select id="polyhedronSelect">
            <option value="tetrahedron">Tetraedro (4 caras)</option>
            <option value="cube" selected>Cubo (6 caras)</option>
            <option value="octahedron">Octaedro (8 caras)</option>
            <option value="dodecahedron">Dodecaedro (12 caras)</option>
            <option value="icosahedron">Icosaedro (20 caras)</option>
          </select>
        </div>

        <div class="control-group">
          <label>Modo de Visualizaci√≥n</label>
          <select id="viewMode">
            <option value="solid">S√≥lido</option>
            <option value="wireframe">Alambre</option>
            <option value="vertices">Solo V√©rtices</option>
            <option value="edges">Solo Aristas</option>
            <option value="faces">Solo Caras</option>
          </select>
        </div>

        <div class="control-group">
          <label>Rotaci√≥n Autom√°tica</label>
          <input type="range" id="rotationSpeed" min="0" max="0.05" step="0.005" value="0.01">
        </div>

        <div class="control-group">
          <label>Escala: <span id="scaleValue">1.0</span></label>
          <input type="range" id="scaleSlider" min="0.5" max="2" step="0.1" value="1">
        </div>
      </div>

      <div class="btn-group">
        <button onclick="toggleProjection()">üåç Mostrar/Ocultar Esfera</button>
        <button onclick="highlightVertices()">üìç Destacar V√©rtices</button>
        <button onclick="highlightEdges()">üìè Destacar Aristas</button>
        <button onclick="highlightFaces()">üî∑ Destacar Caras</button>
        <button class="secondary" onclick="resetView()">‚Üª Reiniciar Vista</button>
      </div>

      <div class="legend">
        <div class="legend-item">
          <div class="legend-color" style="background: #ff6b6b;"></div>
          <span>V√©rtices</span>
        </div>
        <div class="legend-item">
          <div class="legend-color" style="background: #4ecdc4;"></div>
          <span>Aristas</span>
        </div>
        <div class="legend-item">
          <div class="legend-color" style="background: #ffd93d;"></div>
          <span>Caras</span>
        </div>
      </div>
    </div>

    <div class="grid">
      <div class="panel">
        <h2>üé® Vista 3D del Poliedro</h2>
        <div class="canvas-container">
          <canvas id="canvas3d"></canvas>
        </div>
        <div class="info-box">
          <strong>üí° Interacci√≥n:</strong> Arrastra para rotar ‚Ä¢ Scroll para zoom ‚Ä¢ Haz clic en elementos para resaltarlos
        </div>
      </div>

      <div class="panel">
        <h2>üåê Proyecci√≥n Esf√©rica</h2>
        <div class="canvas-container">
          <canvas id="canvasSphere"></canvas>
        </div>
        <div class="info-box">
          <strong>üîç Concepto:</strong> Cada poliedro convexo se puede proyectar en una esfera. La f√≥rmula V - E + F = 2 es invariante bajo esta proyecci√≥n.
        </div>
      </div>
    </div>

    <div class="panel">
      <h2>üìö Demostraci√≥n Paso a Paso</h2>
      <div class="step-indicator">
        <div class="step active" onclick="showStep(1)">
          <strong>1.</strong> Seleccionar
        </div>
        <div class="step" onclick="showStep(2)">
          <strong>2.</strong> Contar V
        </div>
        <div class="step" onclick="showStep(3)">
          <strong>3.</strong> Contar E
        </div>
        <div class="step" onclick="showStep(4)">
          <strong>4.</strong> Contar F
        </div>
        <div class="step" onclick="showStep(5)">
          <strong>5.</strong> Calcular œá
        </div>
      </div>
      <div id="stepContent" class="info-box">
        Paso 1: Selecciona un poliedro y observa su estructura en 3D.
      </div>
    </div>
  </div>

  <footer>
    <p>Material elaborado por el profesor Sergio Gevatschnaider</p>
  </footer>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    let scene, camera, renderer, polyhedron, sphereWireframe;
    let scene2, camera2, renderer2, projectedPolyhedron, projectionSphere;
    let rotationSpeed = 0.01;
    let showSphere = true;
    let currentStep = 1;

    const polyhedronData = {
      tetrahedron: { V: 4, E: 6, F: 4, geometry: null },
      cube: { V: 8, E: 12, F: 6, geometry: null },
      octahedron: { V: 6, E: 12, F: 8, geometry: null },
      dodecahedron: { V: 20, E: 30, F: 12, geometry: null },
      icosahedron: { V: 12, E: 30, F: 20, geometry: null }
    };

    function init() {
      // Escena principal (poliedro)
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(75, 1, 0.1, 1000);
      camera.position.z = 5;

      const canvas = document.getElementById('canvas3d');
      renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
      renderer.setSize(canvas.offsetWidth, canvas.offsetHeight);
      renderer.setClearColor(0x0a0e27, 1);

      // Escena de proyecci√≥n esf√©rica
      scene2 = new THREE.Scene();
      camera2 = new THREE.PerspectiveCamera(75, 1, 0.1, 1000);
      camera2.position.z = 5;

      const canvas2 = document.getElementById('canvasSphere');
      renderer2 = new THREE.WebGLRenderer({ canvas: canvas2, antialias: true, alpha: true });
      renderer2.setSize(canvas2.offsetWidth, canvas2.offsetHeight);
      renderer2.setClearColor(0x0a0e27, 1);

      // Luces
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
      const pointLight = new THREE.PointLight(0xffffff, 0.8);
      pointLight.position.set(10, 10, 10);
      scene.add(ambientLight, pointLight);
      scene2.add(ambientLight.clone(), pointLight.clone());

      // Crear poliedros
      createPolyhedron('cube');
      createProjectionSphere();

      // Event listeners
      document.getElementById('polyhedronSelect').addEventListener('change', (e) => {
        createPolyhedron(e.target.value);
      });

      document.getElementById('rotationSpeed').addEventListener('input', (e) => {
        rotationSpeed = parseFloat(e.target.value);
      });

      document.getElementById('scaleSlider').addEventListener('input', (e) => {
        const scale = parseFloat(e.target.value);
        document.getElementById('scaleValue').textContent = scale.toFixed(1);
        if (polyhedron) polyhedron.scale.set(scale, scale, scale);
        if (projectedPolyhedron) projectedPolyhedron.scale.set(scale, scale, scale);
      });

      document.getElementById('viewMode').addEventListener('change', (e) => {
        updateViewMode(e.target.value);
      });

      // Mouse interaction
      let isDragging = false;
      let previousMousePosition = { x: 0, y: 0 };

      canvas.addEventListener('mousedown', () => isDragging = true);
      canvas.addEventListener('mouseup', () => isDragging = false);
      canvas.addEventListener('mousemove', (e) => {
        if (isDragging && polyhedron) {
          const deltaX = e.clientX - previousMousePosition.x;
          const deltaY = e.clientY - previousMousePosition.y;
          polyhedron.rotation.y += deltaX * 0.01;
          polyhedron.rotation.x += deltaY * 0.01;
          if (projectedPolyhedron) {
            projectedPolyhedron.rotation.y = polyhedron.rotation.y;
            projectedPolyhedron.rotation.x = polyhedron.rotation.x;
          }
        }
        previousMousePosition = { x: e.clientX, y: e.clientY };
      });

      animate();
    }

    function createPolyhedron(type) {
      if (polyhedron) scene.remove(polyhedron);
      if (projectedPolyhedron) scene2.remove(projectedPolyhedron);

      let geometry;
      switch(type) {
        case 'tetrahedron':
          geometry = new THREE.TetrahedronGeometry(2);
          break;
        case 'cube':
          geometry = new THREE.BoxGeometry(2, 2, 2);
          break;
        case 'octahedron':
          geometry = new THREE.OctahedronGeometry(2);
          break;
        case 'dodecahedron':
          geometry = new THREE.DodecahedronGeometry(2);
          break;
        case 'icosahedron':
          geometry = new THREE.IcosahedronGeometry(2);
          break;
      }

      const material = new THREE.MeshPhongMaterial({
        color: 0x4f7cff,
        transparent: true,
        opacity: 0.8,
        side: THREE.DoubleSide
      });

      polyhedron = new THREE.Mesh(geometry, material);
      scene.add(polyhedron);

      // Wireframe
      const wireframe = new THREE.LineSegments(
        new THREE.EdgesGeometry(geometry),
        new THREE.LineBasicMaterial({ color: 0x4ecdc4, linewidth: 2 })
      );
      polyhedron.add(wireframe);

      // V√©rtices
      const vertices = geometry.attributes.position;
      const vertexGeometry = new THREE.SphereGeometry(0.1, 16, 16);
      const vertexMaterial = new THREE.MeshBasicMaterial({ color: 0xff6b6b });
      
      const uniqueVertices = new Set();
      for (let i = 0; i < vertices.count; i++) {
        const v = new THREE.Vector3(
          vertices.getX(i),
          vertices.getY(i),
          vertices.getZ(i)
        );
        const key = `${v.x.toFixed(4)},${v.y.toFixed(4)},${v.z.toFixed(4)}`;
        if (!uniqueVertices.has(key)) {
          uniqueVertices.add(key);
          const sphere = new THREE.Mesh(vertexGeometry, vertexMaterial);
          sphere.position.copy(v);
          polyhedron.add(sphere);
        }
      }

      // Proyecci√≥n en esfera
      projectedPolyhedron = polyhedron.clone();
      scene2.add(projectedPolyhedron);

      updateStats(type);
    }

    function createProjectionSphere() {
      const sphereGeometry = new THREE.SphereGeometry(3, 32, 32);
      const sphereMaterial = new THREE.MeshBasicMaterial({
        color: 0x6b4fff,
        transparent: true,
        opacity: 0.1,
        wireframe: true
      });
      projectionSphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
      scene2.add(projectionSphere);
    }

    function updateStats(type) {
      const data = polyhedronData[type];
      document.getElementById('vertexCount').textContent = data.V;
      document.getElementById('edgeCount').textContent = data.E;
      document.getElementById('faceCount').textContent = data.F;
      
      const chi = data.V - data.E + data.F;
      document.getElementById('chiValue').textContent = chi;

      const result = document.getElementById('result');
      if (chi === 2) {
        result.className = 'result';
        result.innerHTML = `‚úì <strong>${data.V} - ${data.E} + ${data.F} = ${chi}</strong> ‚Äî ¬°La f√≥rmula de Euler se cumple!`;
      } else {
        result.className = 'result invalid';
        result.innerHTML = `‚úó Resultado: ${chi} (esperado: 2 para poliedros convexos)`;
      }
    }

    function updateViewMode(mode) {
      if (!polyhedron) return;
      
      polyhedron.material.visible = true;
      polyhedron.material.opacity = 0.8;
      
      polyhedron.children.forEach(child => {
        child.visible = true;
      });

      switch(mode) {
        case 'wireframe':
          polyhedron.material.opacity = 0.2;
          break;
        case 'vertices':
          polyhedron.material.visible = false;
          polyhedron.children.forEach((child, i) => {
            if (i === 0) child.visible = false; // wireframe
          });
          break;
        case 'edges':
          polyhedron.material.visible = false;
          polyhedron.children.forEach((child, i) => {
            if (i !== 0) child.visible = false; // only wireframe
          });
          break;
        case 'faces':
          polyhedron.children.forEach(child => {
            child.visible = false;
          });
          break;
      }
    }

    function toggleProjection() {
      showSphere = !showSphere;
      if (projectionSphere) {
        projectionSphere.visible = showSphere;
      }
    }

    function highlightVertices() {
      if (!polyhedron) return;
      polyhedron.children.forEach((child, i) => {
        if (i > 0) { // v√©rtices
          child.material.emissive = new THREE.Color(0xff6b6b);
          setTimeout(() => {
            child.material.emissive = new THREE.Color(0x000000);
          }, 1000);
        }
      });
    }

    function highlightEdges() {
      if (!polyhedron) return;
      const wireframe = polyhedron.children[0];
      const originalColor = wireframe.material.color.clone();
      wireframe.material.color = new THREE.Color(0xffff00);
      setTimeout(() => {
        wireframe.material.color = originalColor;
      }, 1000);
    }

    function highlightFaces() {
      if (!polyhedron) return;
      const originalColor = polyhedron.material.color.clone();
      polyhedron.material.color = new THREE.Color(0xffd93d);
      polyhedron.material.emissive = new THREE.Color(0xffd93d);
      polyhedron.material.emissiveIntensity = 0.3;
      setTimeout(() => {
        polyhedron.material.color = originalColor;
        polyhedron.material.emissive = new THREE.Color(0x000000);
      }, 1000);
    }

    function resetView() {
      if (polyhedron) {
        polyhedron.rotation.set(0, 0, 0);
        polyhedron.scale.set(1, 1, 1);
      }
      if (projectedPolyhedron) {
        projectedPolyhedron.rotation.set(0, 0, 0);
        projectedPolyhedron.scale.set(1, 1, 1);
      }
      document.getElementById('scaleSlider').value = 1;
      document.getElementById('scaleValue').textContent = '1.0';
    }

    function showStep(step) {
      currentStep = step;
      document.querySelectorAll('.step').forEach((el, i) => {
        el.classList.toggle('active', i + 1 === step);
      });

      const content = document.getElementById('stepContent');
      const type = document.getElementById('polyhedronSelect').value;
      const data = polyhedronData[type];

      const steps = [
        `<strong>Paso 1:</strong> Observa el poliedro seleccionado en 3D. Puedes rotarlo arrastrando con el mouse.`,
        `<strong>Paso 2:</strong> Contemos los v√©rtices (V). Este poliedro tiene <span style="color: #ff6b6b; font-size: 1.2em;"><strong>${data.V} v√©rtices</strong></span>. Son los puntos donde se encuentran las aristas.`,
        `<strong>Paso 3:</strong> Ahora contemos las aristas (E). Hay <span style="color: #4ecdc4; font-size: 1.2em;"><strong>${data.E} aristas</strong></span>. Son las l√≠neas que conectan los v√©rtices.`,
        `<strong>Paso 4:</strong> Finalmente, las caras (F). Este poliedro tiene <span style="color: #ffd93d; font-size: 1.2em;"><strong>${data.F} caras</strong></span>. Son las superficies planas.`,
        `<strong>Paso 5:</strong> Aplicamos la f√≥rmula: V - E + F = ${data.V} - ${data.E} + ${data.F} = <span style="color: #4eff4e; font-size: 1.3em;"><strong>${data.V - data.E + data.F}</strong></span><br><br>‚úì Para todos los poliedros convexos, el resultado siempre es <strong>2</strong>. Esta es la caracter√≠stica de Euler œá = 2.`
      ];

      content.innerHTML = steps[step - 1];

      // Highlight corresponding elements
      if (step === 2) highlightVertices();
      if (step === 3) highlightEdges();
      if (step === 4) highlightFaces();
    }

    function animate() {
      requestAnimationFrame(animate);

      if (polyhedron) {
        polyhedron.rotation.y += rotationSpeed;
        polyhedron.rotation.x += rotationSpeed * 0.5;
      }

      if (projectedPolyhedron) {
        projectedPolyhedron.rotation.y = polyhedron.rotation.y;
        projectedPolyhedron.rotation.x = polyhedron.rotation.x;
      }

      if (projectionSphere) {
        projectionSphere.rotation.y += rotationSpeed * 0.3;
      }

      renderer.render(scene, camera);
      renderer2.render(scene2, camera2);
    }

    window.addEventListener('resize', () => {
      const canvas = document.getElementById('canvas3d');
      const canvas2 = document.getElementById('canvasSphere');
      
      camera.aspect = canvas.offsetWidth / canvas.offsetHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(canvas.offsetWidth, canvas.offsetHeight);

      camera2.aspect = canvas2.offsetWidth / canvas2.offsetHeight;
      camera2.updateProjectionMatrix();
      renderer2.setSize(canvas2.offsetWidth, canvas2.offsetHeight);
    });

    init();
  </script>
</body>
</html>