<!DOCTYPE html>
<html lang="es" data-theme="light">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>K√∂nigsberg ‚Äî Grafo Equivalente (Interactivo)</title>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap" rel="stylesheet">
<style>
:root{
  --bg: #f8fafc;
  --paper: #ffffff;
  --ink: #0f172a;
  --muted: #64748b;
  --border-color: #e2e8f0;
  --bridge: #b45309;
  --bridge-hover: #f59e0b;
  --used: #94a3b8;
  --ok: #16a34a;
  --warn: #f59e0b;
  --accent: #2563eb;
  --success: #059669;
  --shadow: 0 12px 28px rgba(2,6,23,.08);
  --glow: 0 0 20px rgba(22,163,74,.3);
  --dfs-explore: #8b5cf6;
  --dfs-backtrack: #ef4444;
}

[data-theme="dark"] {
  --bg: #0f172a;
  --paper: #1e293b;
  --ink: #f1f5f9;
  --muted: #94a3b8;
  --border-color: #334155;
  --bridge: #f59e0b;
  --bridge-hover: #fbbf24;
  --used: #475569;
  --ok: #22c55e;
  --warn: #f59e0b;
  --accent: #3b82f6;
  --success: #10b981;
  --shadow: 0 12px 28px rgba(0,0,0,.3);
  --glow: 0 0 20px rgba(34,197,94,.4);
}
*{box-sizing:border-box}
body{margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,Arial;background:var(--bg);color:var(--ink);transition: background .2s, color .2s;}
header{position:sticky;top:0;background:var(--paper);border-bottom:1px solid var(--border-color);box-shadow:var(--shadow);z-index:10}
.wrap{max-width:1100px;margin:0 auto;padding:14px 18px}
h1{margin:.1rem 0;font-size:clamp(20px,3.2vw,28px)}
.sub{color:var(--muted);font-size:.95rem;line-height:1.5}
.controls{display:flex;flex-wrap:wrap;gap:8px;margin-top:10px}
button{border:none;border-radius:10px;padding:9px 13px;font-weight:700;background:var(--paper); color: var(--ink); box-shadow:var(--shadow);cursor:pointer;transition:.18s transform,.18s box-shadow,.18s background, .18s color}
button:hover{transform:translateY(-1px);box-shadow:0 8px 25px rgba(2,6,23,.12)}
.primary{background:var(--accent);color:#fff}
[data-theme="dark"] .primary:hover{background:#2563eb;}
.warn{background:var(--warn);color:#fff}
[data-theme="dark"] .warn:hover{background:#d97706;}
.success{background:var(--success);color:#fff}
[data-theme="dark"] .success:hover{background:#047857;}
.ghost{background:var(--paper);color:var(--ink);border:1px solid var(--border-color)}
.ghost:hover{background:var(--bg);border-color:var(--accent)}
.explore{background:var(--dfs-explore); color:white;}

button:focus-visible, .node:focus-visible { outline: 2px solid var(--accent); outline-offset: 2px; }

.main{max-width:1100px;margin:14px auto;padding:0 18px}
.panel{background:var(--paper);border:1px solid var(--border-color);border-radius:14px;padding:12px 14px;box-shadow:var(--shadow);margin-bottom:14px}
.stats{display:grid;grid-template-columns:repeat(auto-fit,minmax(220px,1fr));gap:10px}
.stat{background:var(--bg);border:1px solid var(--border-color);border-radius:10px;padding:8px 10px;transition:.2s transform}
.stat:hover{transform:translateY(-1px)}
.mono{font-family:ui-monospace,Menlo,Consolas,monospace;background:var(--paper);border:1px solid var(--border-color);border-radius:6px;padding:1px 6px}
.explanation{background:linear-gradient(135deg, var(--bg), var(--paper));border-left:4px solid var(--accent);padding:12px;border-radius:8px;margin:12px 0;font-size:.9rem;line-height:1.6}

.board{position:relative;background:var(--paper);border:1px solid var(--border-color);border-radius:18px;box-shadow:var(--shadow);overflow:hidden}
svg{display:block;width:100%;height:auto;background:linear-gradient(135deg, #eef2ff, #e2e8f0)}
[data-theme="dark"] svg{background:linear-gradient(135deg, var(--bg), #1e293b);}

/* Grafo */
.edge{fill:none;stroke:var(--muted);stroke-width:2.6;cursor:pointer;transition:.18s stroke,.18s opacity,.18s stroke-width}
.edge:hover{stroke:var(--bridge-hover);stroke-width:3.2;filter:drop-shadow(0 0 8px rgba(245,158,11,.4))}
.edge.available{stroke:var(--ok);stroke-width:3.2;filter:var(--glow);animation:pulse 2s infinite}
@keyframes pulse{0%,100%{opacity:1}50%{opacity:.8}}
.edge.used{stroke:var(--used);opacity:.7;cursor:not-allowed}
.edge.dfs-explore { stroke: var(--dfs-explore); stroke-width: 3.5px; }
.edge.dfs-backtrack { stroke: var(--dfs-backtrack); opacity: 0.8; stroke-dasharray: 4 4; animation: dash 1s linear infinite;}
@keyframes dash { to { stroke-dashoffset: -20; }}

.node{fill:#ef4444;stroke:var(--paper);stroke-width:3;cursor:pointer;transition:.2s transform,.2s filter}
.node:hover{transform:scale(1.1);filter:drop-shadow(0 0 8px rgba(239,68,68,.4))}
.node.active{fill:var(--ok);filter:drop-shadow(0 0 12px var(--glow))}
.label{font:700 14px/1 Inter,system-ui,sans-serif; fill:var(--ink);-webkit-user-select:none;user-select:none}
.big{font:800 16px/1 Inter,system-ui,sans-serif}
#walker-graph{fill:var(--ink); stroke:var(--paper); stroke-width:2;filter:drop-shadow(0 0 6px rgba(17,24,39,.6))}
.ripple{position:absolute;border:2px solid var(--accent);border-radius:50%;transform:translate(-50%,-50%);animation:ripple .9s ease-out forwards;pointer-events:none}
@keyframes ripple{from{opacity:1;width:0;height:0}to{opacity:0;width:70px;height:70px}}
.shake{animation:shake .4s}
@keyframes shake{10%,90%{transform:translateX(-1px)}20%,80%{transform:translateX(2px)}30%,50%,70%{transform:translateX(-4px)}40%,60%{transform:translateX(4px)}}
.toast{position:fixed;right:14px;top:14px;background:var(--paper);color:var(--ink);padding:10px 12px;border-radius:10px;transform:translateX(125%);transition:.25s transform;box-shadow:var(--shadow);z-index:40;max-width:300px; border: 1px solid var(--border-color);}
.toast.show{transform:none}

.progress-bar{width:100%;height:4px;background:var(--border-color);border-radius:2px;overflow:hidden;margin:8px 0}
.progress-fill{height:100%;background:linear-gradient(90deg,var(--accent),var(--success));transition:width .3s ease}
.celebration{position:fixed;inset:0;pointer-events:none;z-index:30}
.particle{position:absolute;width:8px;height:8px;border-radius:50%;animation:particle 2s ease-out forwards}
@keyframes particle{
  0%{transform:translate(0,0) scale(1);opacity:1}
  100%{transform:translate(var(--dx),var(--dy)) scale(0);opacity:0}
}

footer{max-width:1100px;margin:18px auto;padding:0 18px 26px;color:var(--muted);text-align:center}
footer hr{border:none;border-top:1px solid var(--border-color);margin:18px 0;}

/* Modals */
.modal-overlay{position:fixed;inset:0;background:rgba(0,0,0,.5);display:flex;align-items:center;justify-content:center;z-index:100}
.modal-content{background:var(--paper);border:1px solid var(--border-color);border-radius:16px;padding:24px;max-width:600px;max-height:80vh;overflow-y:auto;box-shadow:var(--shadow)}
.paths-modal, .dfs-modal{max-width:90vw; max-height:90vh; width: 1200px;}
.paths-info{margin-bottom:16px;padding:12px;background:var(--bg);border-radius:8px;border-left:4px solid var(--accent)}
.paths-container{max-height:400px;overflow-y:auto;border:1px solid var(--border-color);border-radius:8px;background:var(--paper)}
.path-item{background:var(--bg);border:1px solid var(--border-color);border-radius:8px;padding:10px;cursor:pointer;transition:.2s transform,.2s background}
.path-item:hover{background:var(--paper);transform:translateY(-1px)}
.path-item.selected{background:var(--accent);color:#fff;border-color:var(--accent)}
.path-item.selected .path-number{color:#fff}
[data-theme="dark"] .path-item.selected{color:#fff;}
.path-item .path-number{font-weight:700;color:var(--accent);margin-bottom:4px}
.path-item .path-sequence{font-family:ui-monospace,Menlo,Consolas,monospace;font-size:.9rem;word-break:break-all}
.paths-actions{display:flex;gap:8px;justify-content:flex-end;margin-top:16px;flex-wrap:wrap}
.paths-controls{display:flex;gap:8px;justify-content:flex-end;margin-bottom:10px;flex-wrap:wrap}
#step-controls {position:fixed;top:20px;left:50%;transform:translateX(-50%);background:var(--paper);border:1px solid var(--border-color);border-radius:12px;padding:15px;box-shadow:var(--shadow);z-index:50;display:flex;gap:10px;align-items:center;}

/* DFS Explorer Modal */
.dfs-explorer-content { display: grid; grid-template-columns: 1fr 350px; gap: 16px; height: 60vh;}
.dfs-main-panel { display: flex; flex-direction: column; }
.dfs-side-panel { display: flex; flex-direction: column; gap: 12px; font-size: 0.9rem; }
.dfs-panel { background: var(--bg); border: 1px solid var(--border-color); border-radius: 8px; padding: 12px; }
.dfs-panel h4 { margin: 0 0 8px; border-bottom: 1px solid var(--border-color); padding-bottom: 8px; color: var(--accent); }
.dfs-log-container { flex-grow: 1; overflow-y: auto; font-family: ui-monospace, mono; font-size: 0.85rem; }
.dfs-log-entry { padding: 4px; border-radius: 4px; margin-bottom: 2px; }
.dfs-log-entry.push { color: var(--dfs-explore); }
.dfs-log-entry.pop { color: var(--dfs-backtrack); background-color: rgba(239, 68, 68, 0.1); }
.dfs-log-entry.solution { color: var(--success); font-weight: bold; }
.dfs-stack { display: flex; flex-wrap: wrap; gap: 4px; }
.dfs-stack-item { background: var(--paper); border: 1px solid var(--border-color); padding: 4px 8px; border-radius: 6px; font-weight: bold; }
.dfs-stats-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
</style>
</head>
<body>
<header>
  <div class="wrap">
    <h1>üåâ Los 7 Puentes de K√∂nigsberg ‚Äî Grafo Equivalente</h1>
    <div class="sub">
      <strong>Problema hist√≥rico:</strong> ¬øEs posible cruzar cada puente exactamente una vez y regresar al punto de partida?
      Selecciona un v√©rtice y cruza puentes una sola vez. Usa los escenarios para ver c√≥mo se logra un camino o un ciclo euleriano.
    </div>
    <div class="controls" role="toolbar" aria-label="Controles">
      <button id="btn-euler" class="primary">üîç Analizar Grados</button>
      <button id="btn-camino" class="primary">üõ§Ô∏è Crear Camino Euleriano</button>
      <button id="btn-ciclo" class="primary">üîÑ Crear Ciclo Euleriano</button>
      <button id="btn-reset" class="warn">‚ôªÔ∏è Reiniciar Grafo Original</button>
      <button id="btn-theme" class="ghost">üåô Tema</button>
      <button id="btn-help" class="ghost">‚ùì Ayuda</button>
      <button id="btn-find-paths" class="success">üîç Encontrar Todos los Caminos</button>
      <button id="btn-explore-dfs" class="explore">üë®‚Äçüíª Explorar con DFS</button>
    </div>
  </div>
</header>

<main class="main">
  <div class="explanation">
    <strong>¬øPor qu√© es imposible?</strong> El teorema de Euler establece que un grafo tiene un camino euleriano si y solo si tiene 0 o 2 v√©rtices de grado impar.
    En K√∂nigsberg, todos los v√©rtices (A:5, B:3, C:3, D:3) tienen grado impar, por lo que es imposible encontrar tal recorrido.
  </div>

  <div class="panel">
    <div class="stats">
      <div class="stat"><b>üìç Posici√≥n:</b> <span id="pos" class="mono">‚Äî</span></div>
      <div class="stat"><b>üåâ Puentes usados:</b> <span id="count" class="mono">0</span> / <span id="total" class="mono">7</span></div>
      <div class="stat"><b>üõ§Ô∏è Ruta:</b> <span id="path" class="mono">‚Äî</span></div>
      <div class="stat"><b>üìä Grados (A,B,C,D):</b> <span id="deg" class="mono">5, 3, 3, 3</span></div>
    </div>
    <div class="progress-bar">
      <div class="progress-fill" id="progress" style="width:0%"></div>
    </div>
  </div>

  <div id="board" class="board">
    <svg viewBox="0 0 800 520" aria-label="Grafo equivalente a los puentes de K√∂nigsberg" style="aspect-ratio: 16/9">
      <!-- Aristas -->
      <g id="edges"></g>
      <!-- Nodos -->
      <g id="nodes">
        <circle class="node" id="node-C" cx="120" cy="90" r="9" tabindex="0" />
        <text class="label big" x="120" y="70" text-anchor="middle">C</text>
        <circle class="node" id="node-A" cx="120" cy="260" r="9" tabindex="0" />
        <text class="label big" x="120" y="240" text-anchor="middle">A</text>
        <circle class="node" id="node-B" cx="120" cy="430" r="9" tabindex="0" />
        <text class="label big" x="120" y="450" text-anchor="middle">B</text>
        <circle class="node" id="node-D" cx="680" cy="260" r="9" tabindex="0" />
        <text class="label big" x="680" y="240" text-anchor="middle">D</text>
      </g>
      <!-- Walker -->
      <circle id="walker-graph" r="7" cx="120" cy="260" style="display:none"/>
    </svg>
  </div>
</main>

<div id="toast" class="toast" role="status" aria-live="polite"></div>
<div id="celebration" class="celebration"></div>

<!-- Modal de Ayuda -->
<div id="help-modal" class="modal-overlay" style="display:none">
  <div class="modal-content">
    <h3>üéì Gu√≠a de Uso - Puentes de K√∂nigsberg</h3>
    <div class="help-sections">
      <div class="help-section">
        <h4>üìñ El Problema</h4>
        <p>En 1736, Leonhard Euler resolvi√≥ si era posible cruzar cada uno de los 7 puentes de K√∂nigsberg exactamente una vez y regresar al punto de partida.</p>
      </div>
      <div class="help-section">
        <h4>üéØ C√≥mo Jugar</h4>
        <ul>
          <li>Haz clic en un v√©rtice (A, B, C, D) para comenzar</li>
          <li>Haz clic en un puente disponible (resaltado en verde) para cruzarlo</li>
          <li>Intenta cruzar todos los puentes sin repetir</li>
        </ul>
      </div>
      <div class="help-section">
        <h4>üî¨ Teorema de Euler</h4>
        <p>Un grafo tiene un camino euleriano si y solo si tiene 0 o 2 v√©rtices de grado impar. En K√∂nigsberg, todos los v√©rtices son impares (A:5, B:3, C:3, D:3), por lo que es imposible.</p>
      </div>
      <div class="help-section">
        <h4>üß™ Experimenta</h4>
        <p>Usa los botones para modificar el grafo y ver c√≥mo cambia la posibilidad de encontrar un recorrido euleriano.</p>
      </div>
    </div>
    <button id="close-help" class="primary">Entendido</button>
  </div>
</div>

<!-- Modal de Caminos Eulerianos -->
<div id="paths-modal" class="modal-overlay" style="display:none">
  <div class="modal-content paths-modal">
    <h3>üõ§Ô∏è Todos los Caminos Eulerianos Posibles</h3>
    <div class="paths-info">
      <p id="paths-summary">Analizando el grafo...</p>
    </div>
    <div class="paths-container">
      <div id="paths-list" class="paths-list"></div>
    </div>
    <div class="paths-actions">
      <button id="btn-animate-path" class="primary">‚ñ∂Ô∏è Animar Camino</button>
      <button id="btn-step-by-step" class="primary">üë£ Paso a Paso</button>
      <button id="btn-copy-path" class="ghost">üìã Copiar</button>
      <button id="close-paths" class="warn">Cerrar</button>
    </div>
  </div>
</div>

<!-- Modal Explorador DFS -->
<div id="dfs-modal" class="modal-overlay" style="display:none">
  <div class="modal-content dfs-modal">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px;">
      <h3>üë®‚Äçüíª Explorador DFS con Backtracking</h3>
      <div class="controls">
          <button id="dfs-play" class="primary">‚ñ∂Ô∏è Play</button>
          <button id="dfs-step" class="ghost"> Avanzar</button>
          <select id="dfs-speed" class="ghost" style="padding: 8px;">
              <option value="1000">Lento</option>
              <option value="500" selected>Normal</option>
              <option value="100">R√°pido</option>
          </select>
          <button id="dfs-reset" class="ghost">‚ôªÔ∏è Reiniciar</button>
          <button id="close-dfs" class="warn">Cerrar</button>
      </div>
    </div>
    <div class="dfs-explorer-content">
      <div class="dfs-main-panel dfs-panel">
        <h4>Log de Operaciones</h4>
        <div id="dfs-log" class="dfs-log-container"></div>
      </div>
      <div class="dfs-side-panel">
        <div class="dfs-panel">
          <h4>üìö Stack de DFS</h4>
          <div id="dfs-stack" class="dfs-stack"></div>
        </div>
        <div class="dfs-panel">
          <h4>üìä Estad√≠sticas</h4>
          <div class="dfs-stats-grid">
            <span>Pasos:</span> <b id="dfs-steps">0</b>
            <span>Backtracks:</span> <b id="dfs-backtracks">0</b>
            <span>Soluciones:</span> <b id="dfs-solutions">0</b>
            <span>Profundidad Max:</span> <b id="dfs-max-depth">0</b>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>


<footer>
  <hr>
  <div>Material elaborado por el profesor Sergio Gevatschnaider</div>
  <div style="font-size:.85rem;margin-top:4px;">
    El problema de K√∂nigsberg fue resuelto por Leonhard Euler en 1736, marcando el nacimiento de la teor√≠a de grafos.
  </div>
</footer>

<script>
/* ===== Datos del grafo ===== */
const G_LAYOUT = {A:{x:120,y:260}, B:{x:120,y:430}, C:{x:120,y:90}, D:{x:680,y:260}};
const BASE_EDGES = [
  {id:"AC1", u:"A", v:"C", n:2, k:0}, {id:"AC2", u:"A", v:"C", n:2, k:1},
  {id:"AB1", u:"A", v:"B", n:2, k:0}, {id:"AB2", u:"A", v:"B", n:2, k:1},
  {id:"AD",  u:"A", v:"D", n:1, k:0},
  {id:"CD",  u:"C", v:"D", n:1, k:0},
  {id:"BD",  u:"B", v:"D", n:1, k:0},
];
let current = null, used = new Set(), seq = [], edges = structuredClone(BASE_EDGES);
let allPaths = [], selectedPathIndex = 0;
let isStepByStepMode = false, stepByStepIndex = 0;

/* ===== Referencias UI ===== */
const $edges = document.getElementById("edges");
const $pos = document.getElementById("pos"), $count = document.getElementById("count"), $total = document.getElementById("total");
const $path = document.getElementById("path"), $deg = document.getElementById("deg"), $toast = document.getElementById("toast"), $board = document.getElementById("board");
const $progress = document.getElementById("progress");
const walkerG = document.getElementById("walker-graph");

/* ===== Utilidades ===== */
function toast(msg, ms = 3500) {
  $toast.textContent = msg;
  $toast.classList.add("show");
  clearTimeout(window._tt);
  window._tt = setTimeout(() => $toast.classList.remove('show'), ms);
}

function setPos(v) {
  current = v;
  $pos.textContent = v || "‚Äî";
  if (v && seq.length === 0) seq.push(v);
  updateUI();
  updateNodeStates();
}

function otherEnd(e, at) { return e.u === at ? e.v : e.u; }
function available(from) { return edges.filter(e => !used.has(e.id) && (e.u === from || e.v === from)); }

function degs() {
  const d = {A:0, B:0, C:0, D:0};
  edges.forEach(e => { d[e.u]++; d[e.v]++; });
  return d;
}

function eulerMsg() {
  const d = degs();
  const odd = Object.keys(d).filter(k => d[k] % 2 === 1);
  return {
    d,
    odd,
    text: odd.length === 0 ? "üéâ ¬°Todos los grados son pares: Ciclo Euleriano posible!"
                        : odd.length === 2 ? `‚úÖ Dos impares (${odd.join(", ")}): Camino Euleriano posible!`
                                         : `‚ùå ${odd.length} impares (${odd.join(", ")}): Recorrido imposible.`
  };
}

function ripple(el) {
  const rect = el.getBoundingClientRect();
  const r = document.createElement('div');
  r.className = 'ripple';
  r.style.left = (rect.left + rect.width / 2) + 'px';
  r.style.top = (rect.top + rect.height / 2) + 'px';
  document.body.appendChild(r);
  setTimeout(() => r.remove(), 900);
}

function bump() {
  $board.classList.add('shake');
  setTimeout(() => $board.classList.remove('shake'), 350);
}

function updateNodeStates() {
  Object.keys(G_LAYOUT).forEach(node => {
    const el = document.getElementById(`node-${node}`);
    if (el) el.classList.toggle('active', node === current);
  });
}

function createCelebration() {
  const celebration = document.getElementById('celebration');
  celebration.innerHTML = '';
  for (let i = 0; i < 50; i++) {
    const p = document.createElement('div');
    p.className = 'particle';
    p.style.left = `${Math.random()*100}%`;
    p.style.top = `${Math.random()*100}%`;
    p.style.background = `hsl(${Math.random()*360}, 70%, 60%)`;
    p.style.setProperty('--dx', `${Math.random()*200-100}px`);
    p.style.setProperty('--dy', `${Math.random()*200-100}px`);
    celebration.appendChild(p);
  }
  setTimeout(() => celebration.innerHTML = '', 2000);
}

/* ===== Renderizado y UI ===== */
function pathFor(u, v, k, n) {
  const p = G_LAYOUT[u], q = G_LAYOUT[v];
  const dx = q.x - p.x, dy = q.y - p.y, len = Math.hypot(dx, dy) || 1;
  const nx = dx/len, ny = dy/len, px = -ny, py = nx;
  const offset = (n === 1) ? 0 : (k % 2 === 0) ? 38 : -38;
  const c1x = p.x + dx*0.25 + px*offset, c1y = p.y + dy*0.25 + py*offset,
        c2x = p.x + dx*0.75 + px*offset, c2y = p.y + dy*0.75 + py*offset;
  return `M ${p.x} ${p.y} C ${c1x} ${c1y}, ${c2x} ${c2y}, ${q.x} ${q.y}`;
}

function renderEdges() {
  $edges.innerHTML = "";
  edges.forEach(e => {
    const p = document.createElementNS("http://www.w3.org/2000/svg", "path");
    p.setAttribute("d", pathFor(e.u, e.v, e.k, e.n));
    p.id = e.id;
    p.classList.add("edge");
    p.addEventListener("click", () => tryCross(e));
    $edges.appendChild(p);
  });
  $total.textContent = String(edges.length);
}

function updateUI() {
  edges.forEach(e => {
    const el = document.getElementById(e.id);
    if (!el) return;
    const isUsed = used.has(e.id);
    el.classList.toggle('used', isUsed);
    el.classList.toggle('available', !!(current && !isUsed && (e.u === current || e.v === current)));
  });

  const info = eulerMsg();
  const degreesDisplay = Object.entries(info.d)
    .map(([v, d]) => `${v}:${d}${d%2===0?'(par)':'(impar)'}`)
    .join(', ');
  $deg.textContent = `${degreesDisplay} ‚Äî ${info.text}`;

  const progress = edges.length > 0 ? (used.size / edges.length) * 100 : 0;
  $progress.style.width = `${progress}%`;
}

/* ===== L√≥gica del Juego ===== */
function reset() {
  setGraphState(structuredClone(BASE_EDGES));
}

function clearCurrentPath() {
    used.clear();
    seq = [];
    current = null;
    $pos.textContent = "‚Äî";
    $count.textContent = "0";
    $path.textContent = "‚Äî";
    $progress.style.width = "0%";
    walkerG.style.display = "none";
    updateNodeStates();
    updateUI();
}

function setGraphState(newEdges) {
  edges = newEdges;
  clearCurrentPath();
  renderEdges();
  updateUI();
}

document.getElementById("btn-camino").addEventListener("click", () => {
  const newEdges = structuredClone(BASE_EDGES).filter(e => e.id !== "AD");
  setGraphState(newEdges);
  toast(`üõ§Ô∏è Grafo modificado para permitir un Camino Euleriano.`, 4000);
});

document.getElementById("btn-ciclo").addEventListener("click", () => {
  let base = structuredClone(BASE_EDGES);
  const newEdges = [
    ...base.map(e => e.id === "AD" ? { ...e, n: 2 } : e),
    {id:"AD-extra", u:"A", v:"D", n:2, k:1},
    {id:"BC-extra", u:"B", v:"C", n:1, k:0}
  ];
  setGraphState(newEdges);
  toast(`üîÑ Grafo modificado para permitir un Ciclo Euleriano.`, 4000);
});

Object.keys(G_LAYOUT).forEach(v => {
  document.getElementById(`node-${v}`)?.addEventListener("click", (evt) => {
    if (used.size > 0 && current) {
      toast("Ruta en curso. Usa Reiniciar para cambiar de inicio.");
      return;
    }
    setPos(v);
    toast(`üö∂ Inicio en ${v}. Elige un puente para cruzar.`);
    ripple(evt.target);
    walkerG.setAttribute("cx", G_LAYOUT[v].x);
    walkerG.setAttribute("cy", G_LAYOUT[v].y);
    walkerG.style.display = "";
  });
});

function tryCross(e) {
  if (!e) { toast("Arista inexistente."); return; }
  if (used.has(e.id)) { toast("‚ùå Ese puente ya fue usado."); bump(); return; }
  if (!current) { toast("üìç Elige un v√©rtice inicial (A, B, C o D)."); bump(); return; }
  if (e.u !== current && e.v !== current) { toast("üîó Debe ser un puente conectado a tu posici√≥n actual."); bump(); return; }

  const next = otherEnd(e, current);
  animateAlong(e, () => {
    used.add(e.id);
    if (seq.length === 0) seq.push(current);
    seq.push(next);
    setPos(next);
    $count.textContent = String(used.size);
    $path.textContent = seq.join(' ‚Üí ');

    if (used.size === edges.length) {
      toast("üéâ ¬°Felicidades! Se cruzaron todos los puentes.", 4000);
      createCelebration();
    } else if (available(next).length === 0) {
      toast(`üö´ Atrapado en ${next}. No hay m√°s puentes disponibles.`);
    }
  });
}

function animateAlong(e, done, reverse = false) {
  const path = document.getElementById(e.id);
  if (!path) { done && done(); return; }
  const len = path.getTotalLength(), start = performance.now(), duration = 500;
  walkerG.style.display = "";
  requestAnimationFrame(function step(t) {
    let k = Math.min(1, (t - start) / duration);
    if (reverse) k = 1 - k;
    const pt = path.getPointAtLength(k * len);
    walkerG.setAttribute('cx', pt.x);
    walkerG.setAttribute('cy', pt.y);
    if ((!reverse && k < 1) || (reverse && k > 0)) {
        requestAnimationFrame(step);
    } else {
        done && done();
    }
  });
}

/* ===== Botones y Eventos ===== */
document.getElementById("btn-reset").addEventListener("click", () => { reset(); toast("üîÑ Grafo original de K√∂nigsberg restaurado."); });
document.getElementById("btn-euler").addEventListener("click", () => toast(eulerMsg().text, 4000));
document.getElementById("btn-theme").addEventListener("click", () => {
  const isDark = document.documentElement.dataset.theme === 'dark';
  const newTheme = isDark ? 'light' : 'dark';
  document.documentElement.dataset.theme = newTheme;
  localStorage.setItem('theme', newTheme);
  document.getElementById("btn-theme").textContent = newTheme === 'dark' ? '‚òÄÔ∏è Tema' : 'üåô Tema';
});
document.getElementById("btn-help").addEventListener("click", () => document.getElementById("help-modal").style.display = "flex");
document.getElementById("close-help").addEventListener("click", () => document.getElementById("help-modal").style.display = "none");
document.addEventListener('keydown', (e) => {
  if (e.key === 'Escape') {
    ['help-modal', 'paths-modal', 'dfs-modal'].forEach(id => document.getElementById(id).style.display = 'none');
  }
});

/* ===== B√∫squeda de Caminos Eulerianos ===== */
function removeDuplicateVertexSequences(paths) {
    const uniquePaths = [];
    const seen = new Set();
    for (const path of paths) {
        const key = path.join('‚Üí');
        if (!seen.has(key)) {
            seen.add(key);
            uniquePaths.push(path);
        }
    }
    return uniquePaths;
}

function findAllEulerianPaths() {
  const { odd } = eulerMsg();
  if (odd.length > 2) return { possible: false, paths: [], message: "‚ùå No es posible: m√°s de 2 v√©rtices impares" };
  if (odd.length === 0) return findEulerianCycles();
  return findEulerianPaths(odd[0], odd[1]);
}

function findEulerianPaths(start, end) {
  const paths = [];
  const adj = buildAdjacencyList();
  function dfs(curr, path, used) {
    if (used.size === edges.length) {
      if (curr === end) paths.push([...path]);
      return;
    }
    (adj[curr] || []).forEach(edge => {
      if (!used.has(edge.id)) {
        used.add(edge.id);
        path.push(otherEnd(edge, curr));
        dfs(otherEnd(edge, curr), path, used);
        path.pop();
        used.delete(edge.id);
      }
    });
  }
  dfs(start, [start], new Set());
  const unique = removeDuplicateVertexSequences(paths);
  return { possible: true, paths: unique, message: `‚úÖ Encontrados ${unique.length} caminos √∫nicos de ${start} a ${end}` };
}

function findEulerianCycles() {
  const paths = [], adj = buildAdjacencyList(), start = Object.keys(G_LAYOUT)[0];
  function dfs(curr, path, used) {
    if (used.size === edges.length) {
      if (curr === start) paths.push([...path]);
      return;
    }
    (adj[curr] || []).forEach(edge => {
      if (!used.has(edge.id)) {
        used.add(edge.id);
        path.push(otherEnd(edge, curr));
        dfs(otherEnd(edge, curr), path, used);
        path.pop();
        used.delete(edge.id);
      }
    });
  }
  dfs(start, [start], new Set());
  const rotationalUnique = removeDuplicateCycles(paths);
  const finalUnique = removeDuplicateVertexSequences(rotationalUnique);
  return { possible: true, paths: finalUnique, message: `üîÑ Encontrados ${finalUnique.length} ciclos √∫nicos` };
}

function buildAdjacencyList() {
  const adj = {};
  edges.forEach(e => {
    (adj[e.u] = adj[e.u] || []).push(e);
    (adj[e.v] = adj[e.v] || []).push(e);
  });
  return adj;
}

function removeDuplicateCycles(paths) {
  const unique = [], seen = new Set();
  for (const path of paths) {
    if (path.length < 2 || path[0] !== path[path.length - 1]) continue;
    const copy = path.slice(0, -1);
    const minV = copy.reduce((a, b) => a < b ? a : b);
    const minIdx = copy.indexOf(minV);
    const norm = [...copy.slice(minIdx), ...copy.slice(0, minIdx)];
    const rev = [norm[0], ...norm.slice(1).reverse()];
    const key1 = norm.join('‚Üí'), key2 = rev.join('‚Üí');
    if (!seen.has(key1) && !seen.has(key2)) {
      seen.add(key1); seen.add(key2);
      unique.push(path);
    }
  }
  return unique;
}

/* ===== Modal de Caminos ===== */
document.getElementById("btn-find-paths").addEventListener("click", showAllPaths);
document.getElementById("close-paths").addEventListener("click", () => document.getElementById("paths-modal").style.display = "none");
document.getElementById("btn-animate-path").addEventListener("click", () => {
  document.getElementById("paths-modal").style.display = "none";
  animateSelectedPath();
});

function showAllPaths() {
  const result = findAllEulerianPaths();
  allPaths = result.paths;
  selectedPathIndex = 0;
  
  document.getElementById('paths-summary').textContent = result.message;
  
  const list = document.getElementById('paths-list');
  list.innerHTML = '';
  if (allPaths.length > 0) {
    allPaths.forEach((path, i) => {
      const item = document.createElement('div');
      item.className = 'path-item';
      item.onclick = () => selectPath(i);
      const isCycle = path[0] === path[path.length - 1];
      item.innerHTML = `<div class="path-number">${isCycle?'Ciclo':'Camino'} ${i + 1}</div><div class="path-sequence">${path.join(' ‚Üí ')}</div>`;
      list.appendChild(item);
    });
    selectPath(0);
  } else {
    list.innerHTML = '<p style="text-align:center;padding:20px;">No se encontraron caminos</p>';
  }
  
  document.getElementById('paths-modal').style.display = 'flex';
}

function selectPath(index) {
  selectedPathIndex = index;
  document.querySelectorAll('.path-item').forEach((item, i) => item.classList.toggle('selected', i === index));
}

function animateSelectedPath() {
  if (allPaths.length === 0) return;
  const path = allPaths[selectedPathIndex];
  clearCurrentPath();
  let step = 0;
  function animateStep() {
    if (step >= path.length - 1) { toast(`üéâ ¬°Recorrido completado!`, 3000); return; }
    const u = path[step], v = path[step + 1];
    const edge = edges.find(e => !used.has(e.id) && ((e.u===u&&e.v===v)||(e.u===v&&e.v===u)));
    if (edge) {
      setPos(u);
      setTimeout(() => { tryCross(edge); step++; setTimeout(animateStep, 800); }, 500);
    } else { step++; animateStep(); }
  }
  animateStep();
}

/* ===== Explorador DFS ===== */
const dfsPlayer = {
  transcript: [],
  currentIndex: -1,
  interval: null,
  speed: 500,
  stats: { steps: 0, backtracks: 0, solutions: 0, maxDepth: 0 },
  isPlaying: false
};

function generateDfsTranscript() {
    const transcript = [];
    const { odd } = eulerMsg();
    const adj = buildAdjacencyList();
    const startNode = (odd.length === 2) ? odd[0] : Object.keys(G_LAYOUT)[0];
    const endNode = (odd.length === 2) ? odd[1] : startNode;

    function dfs(curr, path, usedEdges) {
        if (path.length > dfsPlayer.stats.maxDepth) dfsPlayer.stats.maxDepth = path.length;

        if (usedEdges.size === edges.length) {
            if (curr === endNode) {
                transcript.push({ type: 'solution', path: [...path] });
                dfsPlayer.stats.solutions++;
            }
            return;
        }

        const availableEdges = adj[curr].filter(e => !usedEdges.has(e.id));
        if (availableEdges.length === 0) {
            transcript.push({ type: 'dead_end', from: curr });
        }

        for (const edge of availableEdges) {
            const next = otherEnd(edge, curr);
            transcript.push({ type: 'push', from: curr, to: next, edgeId: edge.id, path: [...path, next] });
            usedEdges.add(edge.id);
            path.push(next);
            
            dfs(next, path, usedEdges);
            
            path.pop();
            usedEdges.delete(edge.id);
            transcript.push({ type: 'pop', from: next, to: curr, edgeId: edge.id, path: [...path] });
        }
    }
    
    dfsPlayer.stats = { steps: 0, backtracks: 0, solutions: 0, maxDepth: 0 };
    transcript.push({ type: 'start', node: startNode, path: [startNode] });
    dfs(startNode, [startNode], new Set());
    
    dfsPlayer.transcript = transcript;
    dfsPlayer.currentIndex = -1;
}

function renderDfsStep() {
    const step = dfsPlayer.transcript[dfsPlayer.currentIndex];
    if (!step) {
        if(dfsPlayer.isPlaying) toggleDfsPlay();
        return;
    }

    const logContainer = document.getElementById('dfs-log');
    const logEntry = document.createElement('div');
    logEntry.classList.add('dfs-log-entry');
    
    // Reset edge styles
    document.querySelectorAll('.edge.dfs-explore, .edge.dfs-backtrack').forEach(el => {
        el.classList.remove('dfs-explore', 'dfs-backtrack');
    });

    switch(step.type) {
        case 'start':
            logEntry.textContent = `‚ñ∂Ô∏è Iniciando b√∫squeda desde ${step.node}`;
            walkerG.setAttribute('cx', G_LAYOUT[step.node].x);
            walkerG.setAttribute('cy', G_LAYOUT[step.node].y);
            walkerG.style.display = 'block';
            break;
        case 'push':
            dfsPlayer.stats.steps++;
            logEntry.classList.add('push');
            logEntry.textContent = `üü¢ Explorando ${step.from} ‚Üí ${step.to}`;
            document.getElementById(step.edgeId)?.classList.add('dfs-explore');
            animateAlong(step, null, false);
            break;
        case 'pop':
            dfsPlayer.stats.backtracks++;
            logEntry.classList.add('pop');
            logEntry.textContent = `üîô Backtrack desde ${step.from} hacia ${step.to}`;
            document.getElementById(step.edgeId)?.classList.add('dfs-backtrack');
            animateAlong(step, null, true);
            break;
        case 'solution':
            logEntry.classList.add('solution');
            logEntry.textContent = `üèÜ ¬°Soluci√≥n encontrada! ${step.path.join(' ‚Üí ')}`;
            break;
        case 'dead_end':
            logEntry.classList.add('pop');
            logEntry.textContent = `üö´ Callej√≥n sin salida en ${step.from}`;
            break;
    }
    
    // Update Stack
    const stackContainer = document.getElementById('dfs-stack');
    stackContainer.innerHTML = '';
    (step.path || []).forEach(node => {
        const item = document.createElement('span');
        item.className = 'dfs-stack-item';
        item.textContent = node;
        stackContainer.appendChild(item);
    });

    // Update Stats
    document.getElementById('dfs-steps').textContent = dfsPlayer.stats.steps;
    document.getElementById('dfs-backtracks').textContent = dfsPlayer.stats.backtracks;
    document.getElementById('dfs-solutions').textContent = dfsPlayer.stats.solutions;
    document.getElementById('dfs-max-depth').textContent = dfsPlayer.stats.maxDepth;

    logContainer.appendChild(logEntry);
    logContainer.scrollTop = logContainer.scrollHeight;
}

function stepDfs(forward = true) {
    if (forward) {
        if (dfsPlayer.currentIndex < dfsPlayer.transcript.length - 1) {
            dfsPlayer.currentIndex++;
            renderDfsStep();
        } else {
            if (dfsPlayer.isPlaying) toggleDfsPlay();
        }
    }
}

function toggleDfsPlay() {
    const btn = document.getElementById('dfs-play');
    dfsPlayer.isPlaying = !dfsPlayer.isPlaying;
    if (dfsPlayer.isPlaying) {
        btn.textContent = '‚è∏Ô∏è Pause';
        dfsPlayer.interval = setInterval(() => stepDfs(true), dfsPlayer.speed);
    } else {
        btn.textContent = '‚ñ∂Ô∏è Play';
        clearInterval(dfsPlayer.interval);
    }
}

function resetDfsExplorer() {
    clearCurrentPath();
    if (dfsPlayer.isPlaying) toggleDfsPlay();
    dfsPlayer.currentIndex = -1;
    document.getElementById('dfs-log').innerHTML = '';
    document.getElementById('dfs-stack').innerHTML = '';
    dfsPlayer.stats = { steps: 0, backtracks: 0, solutions: 0, maxDepth: 0 };
    renderDfsStep();
}

document.getElementById('btn-explore-dfs').addEventListener('click', () => {
    generateDfsTranscript();
    resetDfsExplorer();
    document.getElementById('dfs-modal').style.display = 'flex';
});
document.getElementById('close-dfs').addEventListener('click', () => {
    if (dfsPlayer.isPlaying) toggleDfsPlay();
    document.getElementById('dfs-modal').style.display = 'none';
});
document.getElementById('dfs-play').addEventListener('click', toggleDfsPlay);
document.getElementById('dfs-step').addEventListener('click', () => stepDfs(true));
document.getElementById('dfs-reset').addEventListener('click', resetDfsExplorer);
document.getElementById('dfs-speed').addEventListener('change', (e) => {
    dfsPlayer.speed = parseInt(e.target.value, 10);
    if (dfsPlayer.isPlaying) {
        toggleDfsPlay(); // Pause
        toggleDfsPlay(); // and Play again with new speed
    }
});

/* ===== Inicializaci√≥n ===== */
(function init() {
  const theme = localStorage.getItem('theme') || 'light';
  document.documentElement.dataset.theme = theme;
  document.getElementById("btn-theme").textContent = theme === 'dark' ? '‚òÄÔ∏è Tema' : 'üåô Tema';
  renderEdges();
  updateUI();
})();
</script>
</body>
</html>