<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>K√∂nigsberg ‚Äî Grafo Equivalente (Interactivo)</title>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800&display=swap" rel="stylesheet">
<style>
:root{
  --bg:#f8fafc; --paper:#ffffff; --ink:#0f172a; --muted:#64748b;
  --bridge:#b45309; --bridge-hover:#f59e0b; --used:#94a3b8;
  --ok:#16a34a; --warn:#f59e0b; --accent:#2563eb; --success:#059669;
  --shadow:0 12px 28px rgba(2,6,23,.08);
  --glow:0 0 20px rgba(22,163,74,.3);
}

[data-theme="dark"] {
  --bg:#0f172a; --paper:#1e293b; --ink:#f1f5f9; --muted:#94a3b8;
  --bridge:#f59e0b; --bridge-hover:#fbbf24; --used:#475569;
  --ok:#22c55e; --warn:#f59e0b; --accent:#3b82f6; --success:#10b981;
  --shadow:0 12px 28px rgba(0,0,0,.3);
  --glow:0 0 20px rgba(34,197,94,.4);
}
*{box-sizing:border-box}
body{margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,Arial;background:var(--bg);color:var(--ink)}
header{position:sticky;top:0;background:var(--paper);border-bottom:1px solid #e2e8f0;box-shadow:var(--shadow);z-index:10}
.wrap{max-width:1100px;margin:0 auto;padding:14px 18px}
h1{margin:.1rem 0;font-size:clamp(20px,3.2vw,28px)}
.sub{color:var(--muted);font-size:.95rem;line-height:1.5}
.controls{display:flex;flex-wrap:wrap;gap:8px;margin-top:10px}
button{border:none;border-radius:10px;padding:9px 13px;font-weight:700;background:#fff;box-shadow:var(--shadow);cursor:pointer;transition:.18s transform,.18s box-shadow,.18s background}
button:hover{transform:translateY(-1px);box-shadow:0 8px 25px rgba(2,6,23,.12)}
.primary{background:var(--accent);color:#fff}
.primary:hover{background:#1d4ed8}
.warn{background:var(--warn);color:#fff}
.warn:hover{background:#d97706}
.success{background:var(--success);color:#fff}
.success:hover{background:#047857}
.ghost{background:var(--paper);color:var(--ink);border:1px solid #e2e8f0}
.ghost:hover{background:#f1f5f9;border-color:var(--accent)}

/* Mejoras de accesibilidad */
@media (prefers-reduced-motion: reduce) {
  * { animation-duration: 0.01ms !important; animation-iteration-count: 1 !important; transition-duration: 0.01ms !important; }
}

/* Focus visible para accesibilidad */
button:focus-visible, .node:focus-visible { outline: 2px solid var(--accent); outline-offset: 2px; }

.main{max-width:1100px;margin:14px auto;padding:0 18px}
.panel{background:var(--paper);border:1px solid #e2e8f0;border-radius:14px;padding:12px 14px;box-shadow:var(--shadow);margin-bottom:14px}
.stats{display:grid;grid-template-columns:repeat(auto-fit,minmax(220px,1fr));gap:10px}
.stat{background:#f1f5f9;border:1px solid #e2e8f0;border-radius:10px;padding:8px 10px;transition:.2s transform}
.stat:hover{transform:translateY(-1px)}
.mono{font-family:ui-monospace,Menlo,Consolas,monospace;background:#fff;border:1px solid #e2e8f0;border-radius:6px;padding:1px 6px}
.explanation{background:linear-gradient(135deg,#eef2ff,#f0f9ff);border-left:4px solid var(--accent);padding:12px;border-radius:8px;margin:12px 0;font-size:.9rem;line-height:1.6}

.board{position:relative;background:var(--paper);border:1px solid #e2e8f0;border-radius:18px;box-shadow:var(--shadow);overflow:hidden}
svg{display:block;width:100%;height:auto;background:linear-gradient(135deg,#eef2ff,#e2e8f0)}

/* Grafo mejorado */
.edge{fill:none;stroke:#64748b;stroke-width:2.6;cursor:pointer;transition:.18s stroke,.18s opacity,.18s stroke-width}
.edge:hover{stroke:var(--bridge-hover);stroke-width:3.2;filter:drop-shadow(0 0 8px rgba(245,158,11,.4))}
.edge.available{stroke:var(--ok);stroke-width:3.2;filter:var(--glow);animation:pulse 2s infinite}
@keyframes pulse{0%,100%{opacity:1}50%{opacity:.8}}
.edge.used{stroke:var(--used);opacity:.7;cursor:not-allowed}
.node{fill:#ef4444;stroke:#fff;stroke-width:3;cursor:pointer;transition:.2s transform,.2s filter}
.node:hover{transform:scale(1.1);filter:drop-shadow(0 0 8px rgba(239,68,68,.4))}
.node.active{fill:#16a34a;filter:drop-shadow(0 0 12px rgba(22,163,74,.6))}
.label{font:700 14px/1 Inter,system-ui,sans-serif; fill:var(--ink);-webkit-user-select:none;user-select:none}
.big{font:800 16px/1 Inter,system-ui,sans-serif}

/* Walker y feedback mejorados */
#walker-graph{fill:#111827; stroke:#fff; stroke-width:2;filter:drop-shadow(0 0 6px rgba(17,24,39,.6))}
.ripple{position:absolute;border:2px solid rgba(37,99,235,.65);border-radius:50%;transform:translate(-50%,-50%);animation:ripple .9s ease-out forwards;pointer-events:none}
@keyframes ripple{from{opacity:1;width:0;height:0}to{opacity:0;width:70px;height:70px}}
.shake{animation:shake .4s}
@keyframes shake{10%,90%{transform:translateX(-1px)}20%,80%{transform:translateX(2px)}30%,50%,70%{transform:translateX(-4px)}40%,60%{transform:translateX(4px)}}
.toast{position:fixed;right:14px;top:14px;background:#111827;color:#fff;padding:10px 12px;border-radius:10px;transform:translateX(125%);transition:.25s transform;box-shadow:var(--shadow);z-index:40;max-width:300px}
.toast.show{transform:none}

/* Nuevos efectos visuales */
.progress-bar{width:100%;height:4px;background:#e2e8f0;border-radius:2px;overflow:hidden;margin:8px 0}
.progress-fill{height:100%;background:linear-gradient(90deg,var(--accent),var(--success));transition:width .3s ease}
.celebration{position:fixed;inset:0;pointer-events:none;z-index:30}
.particle{position:absolute;width:8px;height:8px;border-radius:50%;animation:particle 2s ease-out forwards}

@keyframes particle{
  0%{transform:translate(0,0) scale(1);opacity:1}
  100%{transform:translate(var(--dx),var(--dy)) scale(0);opacity:0}
}

footer{max-width:1100px;margin:18px auto;padding:0 18px 26px;color:#334155;text-align:center}

/* Modal de ayuda */
.modal-overlay{position:fixed;inset:0;background:rgba(0,0,0,.5);display:flex;align-items:center;justify-content:center;z-index:100}
.modal-content{background:var(--paper);border-radius:16px;padding:24px;max-width:600px;max-height:80vh;overflow-y:auto;box-shadow:var(--shadow);border:1px solid #e2e8f0}
.modal-content h3{margin:0 0 16px;color:var(--ink)}
.help-sections{display:grid;gap:16px;margin-bottom:20px}
.help-section h4{margin:0 0 8px;color:var(--accent)}
.help-section p{margin:0;line-height:1.6;color:var(--ink)}
.help-section ul{margin:8px 0;padding-left:20px}
.help-section li{margin:4px 0;line-height:1.5}

/* Modal de caminos */
.paths-modal{max-width:800px;max-height:90vh}
.paths-info{margin-bottom:16px;padding:12px;background:#f8fafc;border-radius:8px;border-left:4px solid var(--accent)}
.paths-container{max-height:400px;overflow-y:auto;border:1px solid #e2e8f0;border-radius:8px;background:var(--paper)}
.paths-list{display:grid;gap:8px;padding:12px}
.path-item{background:#f1f5f9;border:1px solid #e2e8f0;border-radius:8px;padding:10px;cursor:pointer;transition:.2s transform,.2s background}
.path-item:hover{background:#e2e8f0;transform:translateY(-1px)}
.path-item.selected{background:var(--accent);color:#fff;border-color:var(--accent)}
.path-item .path-number{font-weight:700;color:var(--accent);margin-bottom:4px}
.path-item.selected .path-number{color:#fff}
.path-item .path-sequence{font-family:ui-monospace,Menlo,Consolas,monospace;font-size:.9rem;word-break:break-all}
.path-item .path-details{font-size:.8rem;color:var(--muted);margin-top:4px}
.paths-actions{display:flex;gap:8px;justify-content:flex-end;margin-top:16px;flex-wrap:wrap}
.paths-stats{margin-top:10px;padding:10px;background:#f1f5f9;border:1px solid #e2e8f0;border-radius:8px;display:grid;grid-template-columns:repeat(auto-fit,minmax(150px,1fr));gap:8px}
.stat-row{display:flex;justify-content:space-between;align-items:center}
.paths-controls{display:flex;gap:8px;justify-content:flex-end;margin-bottom:10px;flex-wrap:wrap}
</style>
</head>
<body>
<header>
  <div class="wrap">
    <h1>üåâ Los 7 Puentes de K√∂nigsberg ‚Äî Grafo Equivalente</h1>
    <div class="sub">
      <strong>Problema hist√≥rico:</strong> ¬øEs posible cruzar cada puente exactamente una vez y regresar al punto de partida? 
      Selecciona un v√©rtice y cruza puentes una sola vez. Usa los escenarios para ver c√≥mo se logra un camino o un ciclo euleriano.
    </div>
    <div class="controls" role="toolbar" aria-label="Controles">
      <button id="btn-euler" class="primary">üîç Analizar Grados</button>
      <button id="btn-camino" class="primary">üõ§Ô∏è Crear Camino Euleriano</button>
      <button id="btn-ciclo" class="primary">üîÑ Crear Ciclo Euleriano</button>
      <button id="btn-reset" class="warn">‚ôªÔ∏è Reiniciar Grafo Original</button>
      <button id="btn-theme" class="ghost">üåô Tema</button>
      <button id="btn-help" class="ghost">‚ùì Ayuda</button>
      <button id="btn-find-paths" class="success">üîç Encontrar Todos los Caminos</button>
    </div>
  </div>
</header>

<main class="main">
  <div class="explanation">
    <strong>¬øPor qu√© es imposible?</strong> El teorema de Euler establece que un grafo tiene un camino euleriano si y solo si tiene 0 o 2 v√©rtices de grado impar. 
    En K√∂nigsberg, todos los v√©rtices (A:5, B:3, C:3, D:3) tienen grado impar, por lo que es imposible encontrar tal recorrido.
  </div>

  <div class="panel">
    <div class="stats">
      <div class="stat"><b>üìç Posici√≥n:</b> <span id="pos" class="mono">‚Äî</span></div>
      <div class="stat"><b>üåâ Puentes usados:</b> <span id="count" class="mono">0</span> / <span id="total" class="mono">7</span></div>
      <div class="stat"><b>üõ§Ô∏è Ruta:</b> <span id="path" class="mono">‚Äî</span></div>
      <div class="stat"><b>üìä Grados (A,B,C,D):</b> <span id="deg" class="mono">5, 3, 3, 3</span></div>
    </div>
    <div class="progress-bar">
      <div class="progress-fill" id="progress" style="width:0%"></div>
    </div>
  </div>

  <div id="board" class="board">
    <svg viewBox="0 0 800 520" aria-label="Grafo equivalente a los puentes de K√∂nigsberg" style="aspect-ratio: 16/9">
      <!-- Aristas -->
      <g id="edges"></g>
      <!-- Nodos -->
      <g id="nodes">
        <circle class="node" id="node-C" cx="120" cy="90" r="9" tabindex="0" />
        <text class="label big" x="120" y="70" text-anchor="middle">C</text>
        <circle class="node" id="node-A" cx="120" cy="260" r="9" tabindex="0" />
        <text class="label big" x="120" y="240" text-anchor="middle">A</text>
        <circle class="node" id="node-B" cx="120" cy="430" r="9" tabindex="0" />
        <text class="label big" x="120" y="450" text-anchor="middle">B</text>
        <circle class="node" id="node-D" cx="680" cy="260" r="9" tabindex="0" />
        <text class="label big" x="680" y="240" text-anchor="middle">D</text>
      </g>
      <!-- Walker -->
      <circle id="walker-graph" r="7" cx="120" cy="260" style="display:none"/>
    </svg>
  </div>
</main>

<div id="toast" class="toast" role="status" aria-live="polite"></div>
<div id="celebration" class="celebration"></div>

<!-- Modal de Ayuda -->
<div id="help-modal" class="modal-overlay" style="display:none">
  <div class="modal-content">
    <h3>üéì Gu√≠a de Uso - Puentes de K√∂nigsberg</h3>
    <div class="help-sections">
      <div class="help-section">
        <h4>üìñ El Problema</h4>
        <p>En 1736, Leonhard Euler resolvi√≥ si era posible cruzar cada uno de los 7 puentes de K√∂nigsberg exactamente una vez y regresar al punto de partida.</p>
      </div>
      <div class="help-section">
        <h4>üéØ C√≥mo Jugar</h4>
        <ul>
          <li>Haz clic en un v√©rtice (A, B, C, D) para comenzar</li>
          <li>Haz clic en un puente disponible (resaltado en verde) para cruzarlo</li>
          <li>Intenta cruzar todos los puentes sin repetir</li>
        </ul>
      </div>
      <div class="help-section">
        <h4>üî¨ Teorema de Euler</h4>
        <p>Un grafo tiene un camino euleriano si y solo si tiene 0 o 2 v√©rtices de grado impar. En K√∂nigsberg, todos los v√©rtices son impares (A:5, B:3, C:3, D:3), por lo que es imposible.</p>
      </div>
      <div class="help-section">
        <h4>üß™ Experimenta</h4>
        <p>Usa los botones para modificar el grafo y ver c√≥mo cambia la posibilidad de encontrar un recorrido euleriano.</p>
      </div>
    </div>
    <button id="close-help" class="primary">Entendido</button>
  </div>
</div>

<!-- Modal de Caminos Eulerianos -->
<div id="paths-modal" class="modal-overlay" style="display:none">
  <div class="modal-content paths-modal">
    <h3>üõ§Ô∏è Todos los Caminos Eulerianos Posibles</h3>
    <div class="paths-info">
      <p id="paths-summary">Analizando el grafo...</p>
      <div class="paths-stats" id="paths-stats" style="display:none">
        <div class="stat-row">
          <span><strong>Total de caminos:</strong> <span id="total-paths">0</span></span>
          <span><strong>Longitud promedio:</strong> <span id="avg-length">0</span> pasos</span>
        </div>
        <div class="stat-row">
          <span><strong>Punto de partida m√°s com√∫n:</strong> <span id="most-common-start">-</span></span>
          <span><strong>Punto final m√°s com√∫n:</strong> <span id="most-common-end">-</span></span>
        </div>
      </div>
    </div>
    <div class="paths-controls">
      <button id="btn-generate-step" class="ghost">üé≤ Generar Recorrido Aleatorio</button>
      <button id="btn-show-all" class="ghost">üìã Mostrar Todos</button>
      <button id="btn-export-paths" class="ghost">üíæ Exportar</button>
    </div>
    <div class="paths-container">
      <div id="paths-list" class="paths-list"></div>
    </div>
    <div class="paths-actions">
      <button id="btn-animate-path" class="primary">‚ñ∂Ô∏è Animar Camino</button>
      <button id="btn-step-by-step" class="primary">üë£ Paso a Paso</button>
      <button id="btn-copy-path" class="ghost">üìã Copiar</button>
      <button id="close-paths" class="warn">Cerrar</button>
    </div>
  </div>
</div>

<footer>
  <hr style="border:none;border-top:1px solid #e2e8f0;margin:18px 0;">
  <div>Material elaborado por el profesor Sergio Gevatschnaider</div>
  <div style="font-size:.85rem;margin-top:4px;color:var(--muted)">
    El problema de K√∂nigsberg fue resuelto por Leonhard Euler en 1736, marcando el nacimiento de la teor√≠a de grafos.
  </div>
</footer>

<script>
/* ===== Datos del grafo ===== */
const G_LAYOUT = {A:{x:120,y:260}, B:{x:120,y:430}, C:{x:120,y:90}, D:{x:680,y:260}};
const BASE_EDGES = [
  {id:"AC1", u:"A", v:"C", n:2, k:0}, {id:"AC2", u:"A", v:"C", n:2, k:1},
  {id:"AB1", u:"A", v:"B", n:2, k:0}, {id:"AB2", u:"A", v:"B", n:2, k:1},
  {id:"AD",  u:"A", v:"D", n:1, k:0},
  {id:"CD",  u:"C", v:"D", n:1, k:0},
  {id:"BD",  u:"B", v:"D", n:1, k:0},
];
let current = null, used = new Set(), seq = [], edges = structuredClone(BASE_EDGES);
let allPaths = [], selectedPathIndex = 0;
let isStepByStepMode = false, stepByStepIndex = 0;

/* ===== Referencias UI ===== */
const $edges = document.getElementById("edges");
const $pos = document.getElementById("pos"), $count = document.getElementById("count"), $total = document.getElementById("total");
const $path = document.getElementById("path"), $deg = document.getElementById("deg"), $toast = document.getElementById("toast"), $board = document.getElementById("board");
const $progress = document.getElementById("progress");
const walkerG = document.getElementById("walker-graph");

/* ===== Utilidades mejoradas ===== */
function toast(msg, ms = 3500) { 
  $toast.textContent = msg; 
  $toast.classList.add("show"); 
  clearTimeout(window._tt); 
  window._tt = setTimeout(() => $toast.classList.remove('show'), ms); 
}

function setPos(v) { 
  current = v; 
  $pos.textContent = v || "‚Äî"; 
  if (v && seq.length === 0) seq.push(v); 
  updateUI(); 
  updateNodeStates();
}

function otherEnd(e, at) { return e.u === at ? e.v : e.u; }
function available(from) { return edges.filter(e => !used.has(e.id) && (e.u === from || e.v === from)); }

function degs() { 
  const d = {A:0, B:0, C:0, D:0}; 
  edges.forEach(e => { d[e.u]++; d[e.v]++; }); 
  return d; 
}

function eulerMsg() { 
  const d = degs(); 
  const odd = Object.keys(d).filter(k => d[k] % 2 === 1);
  return { 
    d, 
    odd, 
    text: odd.length === 0 ? "üéâ ¬°Todos los grados son pares: Ciclo Euleriano posible!"
                        : odd.length === 2 ? `‚úÖ Dos impares (${odd.join(", ")}): Camino Euleriano posible!`
                                         : `‚ùå ${odd.length} impares (${odd.join(", ")}): Recorrido imposible.` 
  }; 
}

function reset() { 
  used.clear(); 
  seq = []; 
  edges = structuredClone(BASE_EDGES); 
  setPos(null); 
  $count.textContent = "0"; 
  $path.textContent = "‚Äî"; 
  $progress.style.width = "0%";
  walkerG.style.display = "none"; 
  renderEdges(); 
  updateUI(); 
  updateNodeStates();
}

function ripple(el) { 
  const rect = el.getBoundingClientRect(); 
  const r = document.createElement('div'); 
  r.className = 'ripple'; 
  r.style.left = (rect.left + rect.width / 2) + 'px'; 
  r.style.top = (rect.top + rect.height / 2) + 'px'; 
  document.body.appendChild(r); 
  setTimeout(() => r.remove(), 900); 
}

function bump(el) { 
  $board.classList.add('shake'); 
  setTimeout(() => $board.classList.remove('shake'), 350); 
}

function updateNodeStates() {
  ["A", "B", "C", "D"].forEach(node => {
    const el = document.getElementById(`node-${node}`);
    if (el) {
      el.classList.toggle('active', node === current);
    }
  });
}

function createCelebration() {
  const celebration = document.getElementById('celebration');
  celebration.innerHTML = '';
  
  for (let i = 0; i < 50; i++) {
    const particle = document.createElement('div');
    particle.className = 'particle';
    particle.style.left = Math.random() * 100 + '%';
    particle.style.top = Math.random() * 100 + '%';
    particle.style.background = `hsl(${Math.random() * 360}, 70%, 60%)`;
    particle.style.setProperty('--dx', (Math.random() * 200 - 100) + 'px');
    particle.style.setProperty('--dy', (Math.random() * 200 - 100) + 'px');
    celebration.appendChild(particle);
  }
  
  setTimeout(() => {
    celebration.innerHTML = '';
  }, 2000);
}

/* ===== Dibujo de aristas mejorado ===== */
function pathFor(u, v, k, n) { 
  const p = G_LAYOUT[u], q = G_LAYOUT[v]; 
  const dx = q.x - p.x, dy = q.y - p.y, len = Math.hypot(dx, dy) || 1;
  const nx = dx / len, ny = dy / len, px = -ny, py = nx, offset = (n === 1) ? 0 : (k % 2 === 0) ? 38 : -38;
  const c1x = p.x + dx * 0.25 + px * offset, c1y = p.y + dy * 0.25 + py * offset, 
        c2x = p.x + dx * 0.75 + px * offset, c2y = p.y + dy * 0.75 + py * offset;
  return `M ${p.x} ${p.y} C ${c1x} ${c1y}, ${c2x} ${c2y}, ${q.x} ${q.y}`;
}

function renderEdges() { 
  $edges.innerHTML = ""; 
  edges.forEach(e => { 
    const d = pathFor(e.u, e.v, e.k, e.n);
    const p = document.createElementNS("http://www.w3.org/2000/svg", "path"); 
    p.setAttribute("d", d); 
    p.setAttribute("id", e.id); 
    p.setAttribute("class", "edge");
    p.addEventListener("click", () => tryCross(e)); 
    $edges.appendChild(p); 
  }); 
  $total.textContent = String(edges.length);
}

function updateUI() {
  edges.forEach(e => { 
    const el = document.getElementById(e.id); 
    if (!el) return; 
    const isUsed = used.has(e.id); 
    el.classList.toggle('used', isUsed);
    const can = current && !isUsed && (e.u === current || e.v === current); 
    el.classList.toggle('available', Boolean(can)); 
  }); 
  const info = eulerMsg(); 
  $deg.textContent = `A:${info.d.A}, B:${info.d.B}, C:${info.d.C}, D:${info.d.D} ‚Äî ${info.text}`;
  
  // Actualizar barra de progreso
  const progress = (used.size / edges.length) * 100;
  $progress.style.width = progress + '%';
}

/* ===== Interacci√≥n mejorada ===== */
Object.keys(G_LAYOUT).forEach(v => {
  document.getElementById(`node-${v}`)?.addEventListener("click", (evt) => {
    if (used.size > 0 && current) { 
      toast("Ruta en curso. Usa Reiniciar para cambiar de inicio."); 
      return; 
    }
    setPos(v); 
    toast(`üö∂ Inicio en ${v}. Elige un puente para cruzar.`); 
    ripple(evt.target); 
    walkerG.setAttribute("cx", G_LAYOUT[v].x); 
    walkerG.setAttribute("cy", G_LAYOUT[v].y); 
    walkerG.style.display = "";
  });
});

function tryCross(e) {
  if (!e) { toast("Arista inexistente."); return; }
  if (used.has(e.id)) { toast("‚ùå Ese puente ya fue usado."); bump($board); return; }
  if (!current) { toast("üìç Elige un v√©rtice inicial (A, B, C o D)."); bump($board); return; }
  if (e.u !== current && e.v !== current) { toast("üîó Debe ser un puente conectado a tu posici√≥n actual."); bump($board); return; }
  
  const next = otherEnd(e, current);
  animateAlong(e, () => {
    used.add(e.id); 
    setPos(next); 
    seq.push(next); 
    $count.textContent = String(used.size); 
    $path.textContent = seq.join(' ‚Üí ');
    
    if (used.size === edges.length) { 
      toast("üéâ ¬°Felicidades! Se cruzaron todos los puentes.", 4000);
      createCelebration();
      return; 
    }
    if (available(next).length === 0 && used.size < edges.length) { 
      toast(`üö´ Atrapado en ${next}. No hay m√°s puentes disponibles.`); 
    }
  });
}

/* Animaci√≥n del caminante mejorada */
function animateAlong(e, done) {
  const path = document.getElementById(e.id), len = path.getTotalLength(), start = performance.now(), duration = 700;
  walkerG.style.display = "";
  requestAnimationFrame(function step(t) { 
    const k = Math.min(1, (t - start) / duration), pt = path.getPointAtLength(k * len);
    walkerG.setAttribute('cx', pt.x); 
    walkerG.setAttribute('cy', pt.y); 
    if (k < 1) requestAnimationFrame(step); 
    else done && done(); 
  });
}

/* ===== Botones de Control y Escenarios ===== */
document.getElementById("btn-euler").addEventListener("click", () => toast(eulerMsg().text, 4000));
document.getElementById("btn-reset").addEventListener("click", () => { reset(); toast("üîÑ Grafo original de K√∂nigsberg restaurado."); });

// Toggle de tema
document.getElementById("btn-theme").addEventListener("click", () => {
  const isDark = document.documentElement.getAttribute('data-theme') === 'dark';
  document.documentElement.setAttribute('data-theme', isDark ? 'light' : 'dark');
  document.getElementById("btn-theme").textContent = isDark ? 'üåô Tema' : '‚òÄÔ∏è Tema';
  localStorage.setItem('theme', isDark ? 'light' : 'dark');
});

// Modal de ayuda
document.getElementById("btn-help").addEventListener("click", () => {
  document.getElementById("help-modal").style.display = "flex";
});

document.getElementById("close-help").addEventListener("click", () => {
  document.getElementById("help-modal").style.display = "none";
});

// Cerrar modales con Escape
document.addEventListener('keydown', (e) => {
  if (e.key === 'Escape') {
    document.getElementById("help-modal").style.display = "none";
    document.getElementById("paths-modal").style.display = "none";
  }
});

// Cargar tema guardado
const savedTheme = localStorage.getItem('theme') || 'light';
document.documentElement.setAttribute('data-theme', savedTheme);
document.getElementById("btn-theme").textContent = savedTheme === 'dark' ? '‚òÄÔ∏è Tema' : 'üåô Tema';

// Event listeners para el modal de caminos
document.getElementById("btn-find-paths").addEventListener("click", showAllPaths);
document.getElementById("close-paths").addEventListener("click", () => {
  document.getElementById("paths-modal").style.display = "none";
});
document.getElementById("btn-animate-path").addEventListener("click", () => {
  document.getElementById("paths-modal").style.display = "none";
  animateSelectedPath();
});
document.getElementById("btn-step-by-step").addEventListener("click", startStepByStep);
document.getElementById("btn-copy-path").addEventListener("click", copySelectedPath);

// Nuevos event listeners para funcionalidades adicionales
document.getElementById("btn-generate-step").addEventListener("click", generateRandomPath);
document.getElementById("btn-show-all").addEventListener("click", showAllPathsList);
document.getElementById("btn-export-paths").addEventListener("click", exportPaths);

document.getElementById("btn-camino").addEventListener("click", () => {
  reset();
  edges = edges.filter(e => e.id !== "AD");
  renderEdges(); 
  updateUI();
  toast("üõ§Ô∏è Se quit√≥ el puente AD. Ahora B y C son los √∫nicos v√©rtices impares, permitiendo un camino euleriano entre ellos.", 5000);
});

document.getElementById("btn-ciclo").addEventListener("click", () => {
  reset();
  const originalAD = edges.find(e => e.id === "AD");
  if (originalAD) originalAD.n = 2;
  
  edges.push({id:"AD-extra", u:"A", v:"D", n:2, k:1});
  edges.push({id:"BC-extra", u:"B", v:"C", n:1, k:0});
  renderEdges(); 
  updateUI();
  toast("üîÑ Se a√±adieron puentes AD y BC. Ahora todos los v√©rtices tienen grado par, permitiendo un ciclo euleriano.", 5000);
});

/* ===== Algoritmo para encontrar todos los caminos eulerianos ===== */
function findAllEulerianPaths() {
  const d = degs();
  const oddVertices = Object.keys(d).filter(k => d[k] % 2 === 1);
  
  if (oddVertices.length > 2) {
    return { possible: false, paths: [], message: "‚ùå No es posible: m√°s de 2 v√©rtices impares" };
  }
  
  if (oddVertices.length === 0) {
    // Ciclo euleriano - empezar desde cualquier v√©rtice
    return findEulerianCycles();
  } else {
    // Camino euleriano - empezar desde un v√©rtice impar
    return findEulerianPaths(oddVertices[0], oddVertices[1]);
  }
}

function findEulerianPaths(start, end) {
  const paths = [];
  const adjacency = buildAdjacencyList();
  
  function dfs(current, path, usedEdges) {
    if (usedEdges.size === edges.length) {
      if (current === end) {
        paths.push([...path]);
      }
      return;
    }
    
    const neighbors = adjacency[current] || [];
    for (const edge of neighbors) {
      if (!usedEdges.has(edge.id)) {
        usedEdges.add(edge.id);
        const next = edge.u === current ? edge.v : edge.u;
        path.push(next);
        dfs(next, path, usedEdges);
        path.pop();
        usedEdges.delete(edge.id);
      }
    }
  }
  
  dfs(start, [start], new Set());
  return { possible: true, paths, message: `‚úÖ Encontrados ${paths.length} caminos eulerianos de ${start} a ${end}` };
}

function findEulerianCycles() {
  const paths = [];
  const adjacency = buildAdjacencyList();
  
  // Probar desde cada v√©rtice como punto de partida
  for (const start of Object.keys(G_LAYOUT)) {
    function dfs(current, path, usedEdges) {
      if (usedEdges.size === edges.length) {
        // Solo agregar si realmente regresamos al punto de partida
        if (current === start) {
          paths.push([...path]);
        }
        return;
      }
      
      const neighbors = adjacency[current] || [];
      for (const edge of neighbors) {
        if (!usedEdges.has(edge.id)) {
          usedEdges.add(edge.id);
          const next = edge.u === current ? edge.v : edge.u;
          path.push(next);
          dfs(next, path, usedEdges);
          path.pop();
          usedEdges.delete(edge.id);
        }
      }
    }
    
    dfs(start, [start], new Set());
  }
  
  // Eliminar duplicados (caminos que son rotaciones del mismo ciclo)
  const uniquePaths = removeDuplicateCycles(paths);
  
  return { 
    possible: true, 
    paths: uniquePaths, 
    message: `üîÑ Encontrados ${uniquePaths.length} ciclos eulerianos √∫nicos` 
  };
}

function buildAdjacencyList() {
  const adjacency = {};
  edges.forEach(edge => {
    if (!adjacency[edge.u]) adjacency[edge.u] = [];
    if (!adjacency[edge.v]) adjacency[edge.v] = [];
    adjacency[edge.u].push(edge);
    adjacency[edge.v].push(edge);
  });
  return adjacency;
}

function removeDuplicateCycles(paths) {
  const unique = [];
  const seen = new Set();
  
  for (const path of paths) {
    // Verificar que realmente sea un ciclo (el √∫ltimo v√©rtice debe ser igual al primero)
    if (path[0] !== path[path.length - 1]) {
      continue; // No es un ciclo, saltarlo
    }
    
    // Normalizar el ciclo (empezar desde el v√©rtice m√°s peque√±o)
    const minIndex = path.indexOf(Math.min(...path));
    const normalized = [...path.slice(minIndex), ...path.slice(0, minIndex)];
    const key = normalized.join('‚Üí');
    
    if (!seen.has(key)) {
      seen.add(key);
      unique.push(path);
    }
  }
  
  return unique;
}

function showAllPaths() {
  const result = findAllEulerianPaths();
  allPaths = result.paths;
  selectedPathIndex = 0;
  
  document.getElementById('paths-summary').textContent = result.message;
  
  // Mostrar estad√≠sticas si hay caminos
  const statsDiv = document.getElementById('paths-stats');
  if (result.possible && allPaths.length > 0) {
    updatePathsStats();
    statsDiv.style.display = 'grid';
  } else {
    statsDiv.style.display = 'none';
  }
  
  const pathsList = document.getElementById('paths-list');
  pathsList.innerHTML = '';
  
  if (result.possible && allPaths.length > 0) {
    allPaths.forEach((path, index) => {
      const pathItem = document.createElement('div');
      pathItem.className = 'path-item';
      pathItem.onclick = () => selectPath(index);
      
      const isCycle = path[0] === path[path.length - 1];
      const typeText = isCycle ? 'Ciclo' : 'Camino';
      const endInfo = isCycle ? `Regresa a ${path[0]}` : `Termina en ${path[path.length-1]}`;
      
      // Verificaci√≥n adicional para depuraci√≥n
      const verification = isCycle ? 
        `‚úÖ Ciclo v√°lido: ${path[0]} ‚Üí ... ‚Üí ${path[path.length-1]}` :
        `üõ§Ô∏è Camino: ${path[0]} ‚Üí ... ‚Üí ${path[path.length-1]}`;
      
      pathItem.innerHTML = `
        <div class="path-number">${typeText} ${index + 1}</div>
        <div class="path-sequence">${path.join(' ‚Üí ')}</div>
        <div class="path-details">
          <small>Longitud: ${path.length} pasos | Inicio: ${path[0]} | ${endInfo}</small>
          <br><small style="color: var(--accent);">${verification}</small>
        </div>
      `;
      
      pathsList.appendChild(pathItem);
    });
    
    // Seleccionar el primer camino
    selectPath(0);
  } else {
    pathsList.innerHTML = '<p style="text-align:center;color:var(--muted);padding:20px;">No se encontraron caminos eulerianos</p>';
  }
  
  document.getElementById('paths-modal').style.display = 'flex';
}

function updatePathsStats() {
  if (allPaths.length === 0) return;
  
  // Calcular estad√≠sticas
  const totalPaths = allPaths.length;
  const avgLength = Math.round(allPaths.reduce((sum, path) => sum + path.length, 0) / totalPaths);
  
  // Contar puntos de inicio y fin
  const startCounts = {}, endCounts = {};
  allPaths.forEach(path => {
    const start = path[0], end = path[path.length - 1];
    startCounts[start] = (startCounts[start] || 0) + 1;
    endCounts[end] = (endCounts[end] || 0) + 1;
  });
  
  const mostCommonStart = Object.keys(startCounts).reduce((a, b) => startCounts[a] > startCounts[b] ? a : b);
  const mostCommonEnd = Object.keys(endCounts).reduce((a, b) => endCounts[a] > endCounts[b] ? a : b);
  
  // Actualizar UI
  document.getElementById('total-paths').textContent = totalPaths;
  document.getElementById('avg-length').textContent = avgLength;
  document.getElementById('most-common-start').textContent = `${mostCommonStart} (${startCounts[mostCommonStart]})`;
  document.getElementById('most-common-end').textContent = `${mostCommonEnd} (${endCounts[mostCommonEnd]})`;
}

function selectPath(index) {
  selectedPathIndex = index;
  
  // Actualizar selecci√≥n visual
  document.querySelectorAll('.path-item').forEach((item, i) => {
    item.classList.toggle('selected', i === index);
  });
}

function animateSelectedPath() {
  if (allPaths.length === 0) return;
  
  const path = allPaths[selectedPathIndex];
  reset();
  
  // Animar el camino paso a paso
  let step = 0;
  
  function animateStep() {
    // Verificar si es realmente un ciclo (el √∫ltimo v√©rtice debe ser igual al primero)
    const isCycle = path[0] === path[path.length - 1];
    const shouldContinue = step < path.length - 1;
    
    if (!shouldContinue) {
      const message = isCycle ? 
        `üéâ ¬°Ciclo euleriano completado! Regresaste a ${path[0]}` :
        `üéâ ¬°Camino euleriano completado! De ${path[0]} a ${path[path.length-1]}`;
      toast(message, 3000);
      return;
    }
    
    const currentVertex = path[step];
    const nextVertex = path[step + 1];
    
    // Encontrar la arista entre currentVertex y nextVertex
    const edge = edges.find(e => 
      (e.u === currentVertex && e.v === nextVertex) || 
      (e.u === nextVertex && e.v === currentVertex)
    );
    
    if (edge && !used.has(edge.id)) {
      setPos(currentVertex);
      setTimeout(() => {
        tryCross(edge);
        step++;
        setTimeout(animateStep, 800);
      }, 500);
    } else {
      step++;
      animateStep();
    }
  }
  
  animateStep();
}

function copySelectedPath() {
  if (allPaths.length === 0) return;
  
  const path = allPaths[selectedPathIndex];
  const pathText = path.join(' ‚Üí ');
  
  navigator.clipboard.writeText(pathText).then(() => {
    toast('üìã Camino copiado al portapapeles', 2000);
  }).catch(() => {
    // Fallback para navegadores que no soportan clipboard API
    const textArea = document.createElement('textarea');
    textArea.value = pathText;
    document.body.appendChild(textArea);
    textArea.select();
    document.execCommand('copy');
    document.body.removeChild(textArea);
    toast('üìã Camino copiado al portapapeles', 2000);
  });
}

function generateRandomPath() {
  if (allPaths.length === 0) return;
  
  const randomIndex = Math.floor(Math.random() * allPaths.length);
  selectPath(randomIndex);
  toast(`üé≤ Camino aleatorio seleccionado: ${randomIndex + 1}`, 2000);
}

function showAllPathsList() {
  if (allPaths.length === 0) return;
  
  const allPathsText = allPaths.map((path, index) => 
    `Camino ${index + 1}: ${path.join(' ‚Üí ')}`
  ).join('\n\n');
  
  // Crear modal temporal para mostrar todos los caminos
  const modal = document.createElement('div');
  modal.className = 'modal-overlay';
  modal.style.display = 'flex';
  modal.innerHTML = `
    <div class="modal-content" style="max-width: 90vw; max-height: 80vh;">
      <h3>üìã Todos los Caminos Eulerianos (${allPaths.length})</h3>
      <div style="max-height: 60vh; overflow-y: auto; font-family: monospace; white-space: pre-wrap; background: #f8f9fa; padding: 15px; border-radius: 8px; border: 1px solid #e2e8f0;">
${allPathsText}
      </div>
      <div style="margin-top: 15px; text-align: right;">
        <button onclick="this.closest('.modal-overlay').remove()" class="warn">Cerrar</button>
      </div>
    </div>
  `;
  
  document.body.appendChild(modal);
}

function exportPaths() {
  if (allPaths.length === 0) return;
  
  const data = {
    timestamp: new Date().toISOString(),
    graph: {
      vertices: Object.keys(G_LAYOUT),
      edges: edges.map(e => ({ from: e.u, to: e.v, id: e.id }))
    },
    paths: allPaths.map((path, index) => ({
      id: index + 1,
      sequence: path,
      length: path.length,
      start: path[0],
      end: path[path.length - 1]
    })),
    statistics: {
      totalPaths: allPaths.length,
      averageLength: Math.round(allPaths.reduce((sum, path) => sum + path.length, 0) / allPaths.length)
    }
  };
  
  const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = `konigsberg-paths-${new Date().toISOString().split('T')[0]}.json`;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
  
  toast('üíæ Caminos exportados como JSON', 2000);
}

function startStepByStep() {
  if (allPaths.length === 0) return;
  
  isStepByStepMode = true;
  stepByStepIndex = 0;
  document.getElementById('paths-modal').style.display = 'none';
  
  const path = allPaths[selectedPathIndex];
  reset();
  
  toast(`üë£ Modo paso a paso iniciado. Haz clic en "Siguiente" para continuar.`, 3000);
  
  // Mostrar controles de paso a paso
  showStepByStepControls(path);
}

function showStepByStepControls(path) {
  // Crear controles temporales
  const controls = document.createElement('div');
  controls.id = 'step-controls';
  controls.style.cssText = `
    position: fixed; top: 20px; left: 50%; transform: translateX(-50%);
    background: var(--paper); border: 1px solid #e2e8f0; border-radius: 12px;
    padding: 15px; box-shadow: var(--shadow); z-index: 50; display: flex; gap: 10px;
  `;
  
  const isCycle = path[0] === path[path.length - 1];
  const typeText = isCycle ? 'Ciclo Euleriano' : 'Camino Euleriano';
  const currentVertex = path[stepByStepIndex];
  const nextVertex = path[stepByStepIndex + 1];
  
  controls.innerHTML = `
    <div style="margin-right: 15px; font-weight: 600;">
      <div style="font-size: 0.9rem; color: var(--muted); margin-bottom: 2px;">${typeText}</div>
      <div>Paso ${stepByStepIndex + 1} de ${path.length - 1}: ${currentVertex} ‚Üí ${nextVertex}</div>
    </div>
    <button onclick="nextStep()" class="primary">Siguiente</button>
    <button onclick="previousStep()" class="ghost">Anterior</button>
    <button onclick="endStepByStep()" class="warn">Terminar</button>
  `;
  
  document.body.appendChild(controls);
  
  // Posicionar en el v√©rtice actual
  if (stepByStepIndex < path.length) {
    setPos(path[stepByStepIndex]);
  }
}

function nextStep() {
  if (!isStepByStepMode || allPaths.length === 0) return;
  
  const path = allPaths[selectedPathIndex];
  const isCycle = path[0] === path[path.length - 1];
  
  // Completamos todos los pasos del camino
  if (stepByStepIndex >= path.length - 1) {
    const message = isCycle ? 
      `üéâ ¬°Ciclo euleriano completado! Regresaste a ${path[0]}` :
      `üéâ ¬°Camino euleriano completado! De ${path[0]} a ${path[path.length-1]}`;
    toast(message, 2000);
    endStepByStep();
    return;
  }
  
  const currentVertex = path[stepByStepIndex];
  const nextVertex = path[stepByStepIndex + 1];
  
  // Encontrar y cruzar la arista
  const edge = edges.find(e => 
    (e.u === currentVertex && e.v === nextVertex) || 
    (e.u === nextVertex && e.v === currentVertex)
  );
  
  if (edge && !used.has(edge.id)) {
    setPos(currentVertex);
    setTimeout(() => {
      tryCross(edge);
      stepByStepIndex++;
      updateStepControls(path);
    }, 300);
  } else {
    stepByStepIndex++;
    updateStepControls(path);
  }
}

function previousStep() {
  if (!isStepByStepMode || stepByStepIndex <= 0) return;
  
  stepByStepIndex--;
  const path = allPaths[selectedPathIndex];
  
  // Resetear y reconstruir hasta el paso anterior
  reset();
  for (let i = 0; i < stepByStepIndex; i++) {
    const currentVertex = path[i];
    const nextVertex = path[i + 1];
    const edge = edges.find(e => 
      (e.u === currentVertex && e.v === nextVertex) || 
      (e.u === nextVertex && e.v === currentVertex)
    );
    if (edge) {
      used.add(edge.id);
      seq.push(nextVertex);
    }
  }
  
  setPos(path[stepByStepIndex]);
  updateUI();
  updateStepControls(path);
}

function updateStepControls(path) {
  const controls = document.getElementById('step-controls');
  if (!controls) return;
  
  const stepInfo = controls.querySelector('div');
  const isCycle = path[0] === path[path.length - 1];
  
  if (stepByStepIndex < path.length - 1) {
    const currentVertex = path[stepByStepIndex];
    const nextVertex = path[stepByStepIndex + 1];
    const progress = `${stepByStepIndex + 1} de ${path.length - 1}`;
    
    if (isCycle && stepByStepIndex === path.length - 2) {
      stepInfo.textContent = `Paso ${progress}: ${currentVertex} ‚Üí ${nextVertex} (regresando a ${path[0]})`;
    } else {
      stepInfo.textContent = `Paso ${progress}: ${currentVertex} ‚Üí ${nextVertex}`;
    }
  } else {
    const message = isCycle ? 
      `Paso ${stepByStepIndex + 1} de ${path.length - 1}: ¬°Ciclo completado!` :
      `Paso ${stepByStepIndex + 1} de ${path.length - 1}: ¬°Camino completado!`;
    stepInfo.textContent = message;
  }
}

function endStepByStep() {
  isStepByStepMode = false;
  stepByStepIndex = 0;
  
  const controls = document.getElementById('step-controls');
  if (controls) {
    controls.remove();
  }
  
  toast('üë£ Modo paso a paso terminado', 2000);
}

/* ===== Inicializaci√≥n ===== */
renderEdges();
updateUI();
</script>
</body>
</html>


